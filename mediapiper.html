<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mediapiper · Holistic Preview</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined">
  <style>
    html, body {
      height: 100%;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      display: flex;
      overflow: hidden;
      background: radial-gradient(120% 120% at 10% 10%, #0d1525 0%, #04070d 48%, #02040a 100%);
    }
    .preview-layout {
      position: relative;
      flex: 1;
      display: flex;
      width: 100vw;
      height: 100vh;
      min-width: 0;
      min-height: 0;
      align-items: stretch;
      justify-content: center;
      gap: 0;
    }
    .preview-canvas {
      position: relative;
      flex: 1 1 auto;
      width: 100%;
      height: 100%;
      min-width: 0;
      min-height: 0;
      background: #000;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #mediapiper-sketch {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .preview-canvas canvas {
      display: block;
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 100%;
    }
    .preview-canvas video {
      display: none;
    }
    .panel {
      position: absolute;
      top: 0;
      right: 0;
      flex: 0 0 auto;
      width: clamp(260px, 26vw, 340px);
      max-width: 380px;
      background: rgba(10, 14, 24, 0.95);
      border-left: 1px solid rgba(255, 255, 255, 0.12);
      padding: 1rem 1.2rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      /* backdrop-filter: blur(20px); */
      height: 100%;
      overflow-y: auto;
      transform: translateX(100%);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.32s ease, opacity 0.32s ease;
      z-index: 30;
      box-shadow: -18px 0 48px rgba(0, 0, 0, 0.45);
    }
    .panel.is-open {
      transform: translateX(0);
      opacity: 1;
      pointer-events: auto;
    }
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }
    .panel-header h2 {
      margin: 0;
      font-size: 1.05rem;
      font-weight: 600;
    }
    .panel-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    .panel-actions .panel-close {
      margin-left: 0.25rem;
    }
    .panel-actions .icon-button {
      padding: 0.4rem;
    }
    .panel-content {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .control-row {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 0.75rem;
      flex-wrap: wrap;
      color: rgba(245, 247, 255, 0.8);
      font-size: 0.92rem;
    }
    .control-row label {
      flex: 1;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .control-row input[type="checkbox"] {
      accent-color: #ff4081;
      width: 1.1rem;
      height: 1.1rem;
    }
    .status-chip {
      background: rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      padding: 0.15rem 0.65rem;
      font-size: 0.8rem;
      color: rgba(245, 247, 255, 0.7);
    }
    .segment-preview {
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(5, 9, 18, 0.72);
      text-align: center;
      padding: 0.4rem;
    }
    .segment-preview canvas {
      width: 100%;
      height: auto;
      display: block;
    }
    .overlay-toggles {
      display: grid;
      gap: 0.55rem;
    }
    .overlay-toggles-header {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 90px 90px;
      padding: 0 0.45rem;
      font-size: 0.72rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(245, 247, 255, 0.45);
    }
    .overlay-toggle {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 90px 90px;
      align-items: center;
      gap: 0.35rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 0.55rem 0.65rem;
    }
    .overlay-name {
      color: rgba(245, 247, 255, 0.82);
      font-size: 0.9rem;
      font-weight: 500;
    }
    .overlay-switch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      color: rgba(245, 247, 255, 0.75);
      font-size: 0.82rem;
    }
    .overlay-switch input[type="checkbox"] {
      accent-color: #ff4081;
      width: 1.05rem;
      height: 1.05rem;
    }
    .tip {
      font-size: 0.83rem;
      color: rgba(245, 247, 255, 0.65);
      line-height: 1.4;
    }
    .panel-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(5, 9, 18, 0.55);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.32s ease;
      z-index: 20;
    }
    .panel-backdrop.is-visible {
      opacity: 1;
      pointer-events: auto;
    }
    .panel-toggle {
      position: absolute;
      top: 1rem;
      right: 1rem;
      z-index: 40;
      width: 2.75rem;
      height: 2.75rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(9, 13, 22, 0.92);
      color: #f5f7ff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.28);
    }
    .panel-toggle:hover {
      background: rgba(13, 19, 30, 0.96);
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.24);
    }
    .panel-toggle:active {
      transform: translateY(0);
    }
    .panel-toggle .material-icons-outlined {
      font-size: 24px;
    }
    .panel-toggle.panel-toggle-open {
      opacity: 0;
      pointer-events: none;
      transform: translateY(0);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
</head>
<body>
  <main class="preview-layout">
    <section class="preview-canvas">
      <div id="mediapiper-sketch"></div>
      <video id="mediapiper-video" muted></video>
    </section>
    <button id="panel-toggle" class="panel-toggle icon-button" type="button" title="Hide control panel" aria-label="Hide control panel" aria-expanded="true" aria-controls="mediapiper-panel">
      <span class="material-icons-outlined" aria-hidden="true">close</span>
    </button>
    <div id="panel-backdrop" class="panel-backdrop is-visible"></div>
    <aside class="panel is-open" id="mediapiper-panel" role="dialog" aria-modal="false" aria-label="Mediapiper control panel" aria-hidden="false" tabindex="-1">
      <div class="panel-header">
        <h2>Streams</h2>
        <div class="panel-actions">
          <span id="mediapiper-status" class="status-chip">Initializing…</span>
          <button id="mediapiper-toggle-source" class="icon-button" title="Toggle video source" aria-label="Toggle video source">
            <span class="material-icons-outlined" aria-hidden="true">switch_video</span>
          </button>
          <button id="mediapiper-reset" class="icon-button" title="Reset overlays" aria-label="Reset overlays">
            <span class="material-icons-outlined" aria-hidden="true">refresh</span>
          </button>
          <button id="panel-close" class="icon-button panel-close" type="button" title="Hide control panel" aria-label="Hide control panel">
            <span class="material-icons-outlined" aria-hidden="true">close</span>
          </button>
        </div>
      </div>
      <div class="panel-content">
        <div class="control-row">
          <label>
            <input type="checkbox" id="mediapiper-mirror" checked>
            Mirror webcam
          </label>
        </div>
        <div class="overlay-toggles">
          <div class="overlay-toggles-header">
            <span>Stream</span>
            <span>Main</span>
            <span>Preview</span>
          </div>
          <div class="overlay-toggle">
            <span class="overlay-name">Source Underlay</span>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-underlay-main" checked>
              <span>Main</span>
            </label>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-underlay-preview">
              <span>Preview</span>
            </label>
          </div>
          <div class="overlay-toggle">
            <span class="overlay-name">Pose Landmarks</span>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-pose-main" checked>
              <span>Main</span>
            </label>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-pose-preview">
              <span>Preview</span>
            </label>
          </div>
          <div class="overlay-toggle">
            <span class="overlay-name">Left Hand</span>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-left-hand-main" checked>
              <span>Main</span>
            </label>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-left-hand-preview">
              <span>Preview</span>
            </label>
          </div>
          <div class="overlay-toggle">
            <span class="overlay-name">Right Hand</span>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-right-hand-main" checked>
              <span>Main</span>
            </label>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-right-hand-preview">
              <span>Preview</span>
            </label>
          </div>
          <div class="overlay-toggle">
            <span class="overlay-name">Face Mesh</span>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-face-main" checked>
              <span>Main</span>
            </label>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-face-preview">
              <span>Preview</span>
            </label>
          </div>
          <div class="overlay-toggle">
            <span class="overlay-name">Segmentation Mask</span>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-segmentation-main" checked>
              <span>Main</span>
            </label>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-segmentation-preview" checked>
              <span>Preview</span>
            </label>
          </div>
          <div class="overlay-toggle">
            <span class="overlay-name">Depth (Z)</span>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-depth-main" checked>
              <span>Main</span>
            </label>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-depth-preview">
              <span>Preview</span>
            </label>
          </div>
          <div class="overlay-toggle">
            <span class="overlay-name">Performance HUD</span>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-performance-main" checked>
              <span>Main</span>
            </label>
            <label class="overlay-switch">
              <input type="checkbox" id="overlay-performance-preview">
              <span>Preview</span>
            </label>
          </div>
        </div>
        <div class="segment-preview" aria-hidden="false">
          <canvas id="segmentation-preview" width="320" height="180"></canvas>
          <!-- <div class="tip">Preview canvas renders any stream with its Preview toggle enabled.</div> -->
        </div>
        <div class="tip">
          Toggle Main overlays to affect the canvas, and use Preview toggles to stage diagnostics or capture snapshots.
        </div>
      </div>
    </aside>
  </main>

  <script type="module">
// const SAMPLE_VIDEO_URL = "https://thefoxofsky.github.io/project_pages/RealisDance-DiT/video/mv/2.mp4";
const SAMPLE_VIDEO_URL = "https://thefoxofsky.github.io/project_pages/RealisDance-DiT/video/mv/4.mp4";
// const SAMPLE_VIDEO_URL= "https://media.gettyimages.com/id/1432864804/video/a-man-and-a-woman-dance-outdoors-in-preparation-for-a-performance-healthy-lifestyle.mp4?s=mp4-640x640-gi&k=20&c=QenL_gqhEWh665fqtFCuOXsZCdf-EgTSK2JCf_XnPLM=";
// const SAMPLE_VIDEO_URL = "https://media.gettyimages.com/id/1481811636/video/for-us-dance-is-a-way-of-life.mp4?s=mp4-640x640-gi&k=20&c=-eEh1Svdu4dKJCEXijI7d4WOfGWVtAe9Gv_5mmqJYQA=";

    const videoEl = document.getElementById("mediapiper-video");
    const sketchContainer = document.getElementById("mediapiper-sketch");
    const statusLabel = document.getElementById("mediapiper-status");
    const toggleSourceBtn = document.getElementById("mediapiper-toggle-source");
    const resetBtn = document.getElementById("mediapiper-reset");
    const mirrorCheckbox = document.getElementById("mediapiper-mirror");
    const overlayControls = {
      underlay: {
        main: document.getElementById("overlay-underlay-main"),
        preview: document.getElementById("overlay-underlay-preview")
      },
      pose: {
        main: document.getElementById("overlay-pose-main"),
        preview: document.getElementById("overlay-pose-preview")
      },
      leftHand: {
        main: document.getElementById("overlay-left-hand-main"),
        preview: document.getElementById("overlay-left-hand-preview")
      },
      rightHand: {
        main: document.getElementById("overlay-right-hand-main"),
        preview: document.getElementById("overlay-right-hand-preview")
      },
      face: {
        main: document.getElementById("overlay-face-main"),
        preview: document.getElementById("overlay-face-preview")
      },
      segmentation: {
        main: document.getElementById("overlay-segmentation-main"),
        preview: document.getElementById("overlay-segmentation-preview")
      },
      depth: {
        main: document.getElementById("overlay-depth-main"),
        preview: document.getElementById("overlay-depth-preview")
      },
      performance: {
        main: document.getElementById("overlay-performance-main"),
        preview: document.getElementById("overlay-performance-preview")
      }
    };
    const panelEl = document.getElementById("mediapiper-panel");
    const panelToggleBtn = document.getElementById("panel-toggle");
    const panelCloseBtn = document.getElementById("panel-close");
    const panelBackdrop = document.getElementById("panel-backdrop");
    const panelToggleIcon = panelToggleBtn?.querySelector(".material-icons-outlined");
const previewCanvas = document.getElementById("segmentation-preview");
const previewCtx = previewCanvas.getContext("2d", { willReadFrequently: true }) || previewCanvas.getContext("2d");
const previewSection = document.querySelector(".segment-preview");

const SEGMENTATION_COLOR = { r: 15, g: 139, b: 168 };
const SEGMENTATION_ALPHA = 0.6;

const segmentationTintCanvas = document.createElement("canvas");
const segmentationTintCtx = segmentationTintCanvas.getContext("2d", { willReadFrequently: true }) || segmentationTintCanvas.getContext("2d");

const waitForVideoReady = (video) => {
  if (video.readyState >= 2) {
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    const handleReady = () => {
      cleanup();
      resolve();
    };
    const handleError = (event) => {
      cleanup();
      reject(new Error(event?.message || "Video failed to load"));
    };
    const cleanup = () => {
      video.removeEventListener("loadeddata", handleReady);
      video.removeEventListener("loadedmetadata", handleReady);
      video.removeEventListener("error", handleError);
    };
    video.addEventListener("loadeddata", handleReady, { once: true });
    video.addEventListener("loadedmetadata", handleReady, { once: true });
    video.addEventListener("error", handleError, { once: true });
  });
};

const SAFE_POSE_CONNECTIONS = typeof POSE_CONNECTIONS !== "undefined"
  ? POSE_CONNECTIONS
  : [
      [11, 13], [13, 15], [12, 14], [14, 16],
      [11, 12], [23, 24], [11, 23], [12, 24],
      [23, 25], [25, 27], [24, 26], [26, 28],
      [27, 29], [28, 30]
    ];

const SAFE_HAND_CONNECTIONS = typeof HAND_CONNECTIONS !== "undefined"
  ? HAND_CONNECTIONS
  : [
      [0, 1], [1, 2], [2, 3], [3, 4],
      [0, 5], [5, 6], [6, 7], [7, 8],
      [5, 9], [9, 10], [10, 11], [11, 12],
      [9, 13], [13, 14], [14, 15], [15, 16],
      [13, 17], [17, 18], [18, 19], [19, 20],
      [0, 17]
    ];

const SAFE_FACEMESH_TESSELATION = typeof FACEMESH_TESSELATION !== "undefined"
  ? FACEMESH_TESSELATION
  : [];

    videoEl.muted = true;
    videoEl.loop = true;
    videoEl.crossOrigin = "anonymous";
    videoEl.setAttribute("playsinline", "");
    videoEl.setAttribute("webkit-playsinline", "");

    let holistic = null;

    let currentSource = "camera";
    let camera = null;
    let sampleHandle = null;
    let latestResults = null;
    let holisticBusy = false;
    let isPanelOpen = panelEl?.classList.contains("is-open");
let segmentationBuffer = null;
let segmentationMaskAvailable = false;

    const DEFAULT_OVERLAY_STATE = {
      mirror: true,
      underlay: { main: true, preview: false },
      pose: { main: true, preview: false },
      leftHand: { main: true, preview: false },
      rightHand: { main: true, preview: false },
      face: { main: true, preview: false },
      segmentation: { main: true, preview: true },
      depth: { main: true, preview: false },
      performance: { main: true, preview: false }
    };

    const overlayState = {
      mirror: mirrorCheckbox?.checked ?? DEFAULT_OVERLAY_STATE.mirror
    };
    for (const [key, defaults] of Object.entries(DEFAULT_OVERLAY_STATE)) {
      if (key === "mirror") continue;
      overlayState[key] = { main: defaults.main, preview: defaults.preview };
    }

const performanceMetrics = {
  fps: 0,
  frameMs: 0,
  inferenceMs: 0,
  source: "camera"
};

let lastFrameTimestamp = performance.now();
let smoothedFps = 0;
let smoothedFrameMs = 0;
let smoothedInferenceMs = 0;

const resetPerformanceMetrics = () => {
  performanceMetrics.fps = 0;
  performanceMetrics.frameMs = 0;
  performanceMetrics.inferenceMs = 0;
  performanceMetrics.source = currentSource;
  smoothedFps = 0;
  smoothedFrameMs = 0;
  smoothedInferenceMs = 0;
  lastFrameTimestamp = performance.now();
  drawPreviewCanvas();
};

const recordInferenceTime = (ms) => {
  if (!Number.isFinite(ms) || ms <= 0) return;
  smoothedInferenceMs = smoothedInferenceMs ? (smoothedInferenceMs * 0.8 + ms * 0.2) : ms;
  performanceMetrics.inferenceMs = smoothedInferenceMs;
};

const updateOverlayState = () => {
  for (const [key, controls] of Object.entries(overlayControls)) {
    if (!overlayState[key]) {
      overlayState[key] = { main: false, preview: false };
    }
    overlayState[key].main = controls.main?.checked ?? false;
    overlayState[key].preview = controls.preview?.checked ?? false;
  }
  overlayState.mirror = mirrorCheckbox?.checked ?? DEFAULT_OVERLAY_STATE.mirror;
  if (previewSection) {
    const previewVisible = Object.keys(overlayControls).some((key) => overlayState[key]?.preview);
    previewSection.style.display = previewVisible ? "" : "none";
    previewSection.setAttribute("aria-hidden", previewVisible ? "false" : "true");
  }
  drawPreviewCanvas();
};

const setPanelState = (open, { skipFocus = false } = {}) => {
  if (!panelEl || !panelToggleBtn || !panelBackdrop) {
    return;
  }
  isPanelOpen = open;
  panelEl.classList.toggle("is-open", open);
  panelBackdrop.classList.toggle("is-visible", open);
  panelEl.setAttribute("aria-hidden", open ? "false" : "true");
  panelToggleBtn.setAttribute("aria-expanded", open ? "true" : "false");
  panelToggleBtn.setAttribute("title", open ? "Hide control panel" : "Show control panel");
  panelToggleBtn.setAttribute("aria-label", open ? "Hide control panel" : "Show control panel");
  panelToggleBtn.classList.toggle("panel-toggle-open", open);
  if (panelToggleIcon) {
    panelToggleIcon.textContent = open ? "close" : "tune";
  }
  if (panelCloseBtn) {
    panelCloseBtn.setAttribute("title", "Hide control panel");
    panelCloseBtn.setAttribute("aria-label", "Hide control panel");
  }
  if (open) {
    try {
      panelEl.focus({ preventScroll: true });
    } catch (err) {
      panelEl.focus();
    }
  } else if (!skipFocus) {
    try {
      panelToggleBtn.focus({ preventScroll: true });
    } catch (err) {
      panelToggleBtn.focus();
    }
  }
};

const openPanel = (options) => setPanelState(true, options);
const closePanel = (options) => setPanelState(false, options);
const togglePanel = () => setPanelState(!isPanelOpen);

const waitForHolisticIdle = async () => {
  while (holisticBusy) {
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
};

const resetHolistic = async () => {
  await waitForHolisticIdle();
  if (holistic && typeof holistic.close === "function") {
    try {
      await holistic.close();
    } catch (err) {
      console.warn("Holistic close failed", err);
    }
  }
  holisticBusy = false;
  holistic = createHolistic();
};
    setPanelState(Boolean(isPanelOpen), { skipFocus: true });
    updateOverlayState();

    const overlayInputs = Object.values(overlayControls)
      .flatMap((controls) => [controls.main, controls.preview])
      .filter(Boolean);

    overlayInputs.forEach((input) => {
      input.addEventListener("change", updateOverlayState);
    });

    if (mirrorCheckbox) {
      mirrorCheckbox.addEventListener("change", updateOverlayState);
    }

    if (panelToggleBtn) {
      panelToggleBtn.addEventListener("click", () => {
        togglePanel();
      });
    }
    if (panelCloseBtn) {
      panelCloseBtn.addEventListener("click", () => {
        closePanel();
      });
    }
    if (panelBackdrop) {
      panelBackdrop.addEventListener("click", () => {
        closePanel();
      });
    }
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && !event.defaultPrevented && isPanelOpen) {
        closePanel({ skipFocus: true });
      }
    });

    const applyStatus = (text) => {
      statusLabel.textContent = text;
    };

    const segmentationOffscreen = document.createElement("canvas");
    const segmentationOffCtx = segmentationOffscreen.getContext("2d", { willReadFrequently: true }) || segmentationOffscreen.getContext("2d");

function clearPreviewCanvas() {
  if (!previewCtx) return;
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
}

function drawPreviewCanvas() {
  if (!previewCtx || !previewCanvas) {
    return;
  }
  const previewActive = Object.keys(overlayControls).some((key) => overlayState[key]?.preview);
  if (!previewActive) {
    clearPreviewCanvas();
    return;
  }
  clearPreviewCanvas();

  const ctx = previewCtx;
  const width = previewCanvas.width;
  const height = previewCanvas.height;

  ctx.save();
  ctx.fillStyle = "#050912";
  ctx.fillRect(0, 0, width, height);

  const shouldMirror = overlayState.mirror && currentSource === "camera";
  if (shouldMirror) {
    ctx.translate(width, 0);
    ctx.scale(-1, 1);
  }

  if (overlayState.underlay?.preview && videoEl.readyState >= 2) {
    ctx.globalAlpha = 1;
    ctx.drawImage(videoEl, 0, 0, width, height);
  }

  if (overlayState.segmentation?.preview && segmentationMaskAvailable && segmentationTintCanvas.width) {
    ctx.globalAlpha = 1;
    ctx.drawImage(segmentationTintCanvas, 0, 0, width, height);
  }

  if (latestResults) {
    const { poseLandmarks, leftHandLandmarks, rightHandLandmarks, faceLandmarks } = latestResults;

    const drawConnectorSet = (landmarks, connections, color, lineWidth) => {
      if (!landmarks) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.globalAlpha = 0.9;
      for (let i = 0; i < connections.length; i++) {
        const [startIndex, endIndex] = connections[i];
        const start = landmarks[startIndex];
        const end = landmarks[endIndex];
        if (!start || !end) continue;
        ctx.beginPath();
        ctx.moveTo(start.x * width, start.y * height);
        ctx.lineTo(end.x * width, end.y * height);
        ctx.stroke();
      }
      ctx.restore();
    };

    const drawLandmarkDots = (landmarks, color, size) => {
      if (!landmarks) return;
      ctx.save();
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.9;
      for (const lm of landmarks) {
        ctx.beginPath();
        ctx.arc(lm.x * width, lm.y * height, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    };

    if (overlayState.pose?.preview && poseLandmarks) {
      drawConnectorSet(poseLandmarks, SAFE_POSE_CONNECTIONS, "rgba(76, 201, 240, 0.9)", Math.max(1.4, width * 0.0035));
      drawLandmarkDots(poseLandmarks, "rgba(76, 201, 240, 0.7)", Math.max(2.4, width * 0.01));
    }
    if (overlayState.leftHand?.preview && leftHandLandmarks) {
      drawConnectorSet(leftHandLandmarks, SAFE_HAND_CONNECTIONS, "rgba(255, 112, 150, 0.95)", Math.max(1.2, width * 0.003));
      drawLandmarkDots(leftHandLandmarks, "rgba(255, 112, 150, 0.9)", Math.max(2.2, width * 0.009));
    }
    if (overlayState.rightHand?.preview && rightHandLandmarks) {
      drawConnectorSet(rightHandLandmarks, SAFE_HAND_CONNECTIONS, "rgba(255, 143, 163, 0.95)", Math.max(1.2, width * 0.003));
      drawLandmarkDots(rightHandLandmarks, "rgba(255, 143, 163, 0.9)", Math.max(2.2, width * 0.009));
    }
    if (overlayState.face?.preview && faceLandmarks) {
      ctx.save();
      ctx.strokeStyle = "rgba(249, 199, 79, 0.85)";
      ctx.lineWidth = Math.max(0.8, width * 0.0025);
      ctx.globalAlpha = 0.85;
      if (SAFE_FACEMESH_TESSELATION.length) {
        ctx.beginPath();
        for (let i = 0; i < SAFE_FACEMESH_TESSELATION.length; i++) {
          const [startIndex, endIndex] = SAFE_FACEMESH_TESSELATION[i];
          const start = faceLandmarks[startIndex];
          const end = faceLandmarks[endIndex];
          if (!start || !end) continue;
          ctx.moveTo(start.x * width, start.y * height);
          ctx.lineTo(end.x * width, end.y * height);
        }
        ctx.stroke();
      } else {
        ctx.fillStyle = "rgba(249, 199, 79, 0.75)";
        for (const lm of faceLandmarks) {
          ctx.beginPath();
          ctx.arc(lm.x * width, lm.y * height, Math.max(1.5, width * 0.004), 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.restore();
    }
    if (overlayState.depth?.preview && poseLandmarks) {
      ctx.save();
      ctx.globalAlpha = 0.6;
      for (const lm of poseLandmarks) {
        const { color, size } = depthStyle(lm.z ?? 0);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(lm.x * width, lm.y * height, Math.max(size * 0.08, 2.4), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  ctx.restore();

  if (overlayState.performance?.preview) {
    const fpsText = Number.isFinite(performanceMetrics.fps) && performanceMetrics.fps > 0
      ? performanceMetrics.fps.toFixed(1)
      : "--";
    const frameText = Number.isFinite(performanceMetrics.frameMs) && performanceMetrics.frameMs > 0
      ? performanceMetrics.frameMs.toFixed(1)
      : "--";
    const inferenceText = Number.isFinite(performanceMetrics.inferenceMs) && performanceMetrics.inferenceMs > 0
      ? performanceMetrics.inferenceMs.toFixed(1)
      : "--";
    const lines = [
      `FPS: ${fpsText}`,
      `Frame: ${frameText} ms`,
      `Inference: ${inferenceText} ms`,
      `Source: ${performanceMetrics.source}`
    ];
    const padding = 8;
    const lineHeight = 16;
    const boxWidth = width - padding * 2;
    const boxHeight = padding * 2 + lines.length * lineHeight;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(9, 13, 22, 0.86)";
    ctx.fillRect(padding, padding, boxWidth, boxHeight);
    ctx.fillStyle = "rgba(245, 247, 255, 0.92)";
    ctx.font = "12px 'Inter', 'Helvetica Neue', Arial, sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
    lines.forEach((line, index) => {
      ctx.fillText(line, padding + 10, padding + 6 + index * lineHeight);
    });
    ctx.restore();
  }
}

const resetSegmentationData = () => {
  segmentationBuffer = null;
  segmentationMaskAvailable = false;
  segmentationTintCanvas.width = 0;
  segmentationTintCanvas.height = 0;
  latestResults = null;
  clearPreviewCanvas();
  drawPreviewCanvas();
};

function refreshSegmentationTint() {
  if (!segmentationBuffer) {
    segmentationTintCanvas.width = 0;
    segmentationTintCanvas.height = 0;
    segmentationMaskAvailable = false;
    clearPreviewCanvas();
    return;
  }
  const width = segmentationBuffer.width || segmentationOffscreen.width;
  const height = segmentationBuffer.height || segmentationOffscreen.height;
  segmentationTintCanvas.width = width;
  segmentationTintCanvas.height = height;
  const tinted = segmentationTintCtx.createImageData(width, height);
  const src = segmentationBuffer.data;
  const dst = tinted.data;
  const len = width * height;
  for (let i = 0; i < len; i++) {
    const alpha = src[i * 4] / 255;
    dst[i * 4] = SEGMENTATION_COLOR.r;
    dst[i * 4 + 1] = SEGMENTATION_COLOR.g;
    dst[i * 4 + 2] = SEGMENTATION_COLOR.b;
    dst[i * 4 + 3] = Math.round(alpha * SEGMENTATION_ALPHA * 255);
  }
  segmentationTintCtx.putImageData(tinted, 0, 0);
  segmentationMaskAvailable = true;
  drawPreviewCanvas();
}

const handleHolisticResults = (results) => {
  latestResults = results;
  if (results.segmentationMask) {
    segmentationOffscreen.width = results.segmentationMask.width || videoEl.videoWidth || 640;
    segmentationOffscreen.height = results.segmentationMask.height || videoEl.videoHeight || 480;
    segmentationOffCtx.globalCompositeOperation = "copy";
    segmentationOffCtx.drawImage(results.segmentationMask, 0, 0, segmentationOffscreen.width, segmentationOffscreen.height);
    segmentationBuffer = segmentationOffCtx.getImageData(0, 0, segmentationOffscreen.width, segmentationOffscreen.height);
    refreshSegmentationTint();
  } else {
    segmentationBuffer = null;
    refreshSegmentationTint();
  }
};

const createHolistic = () => {
  const instance = new Holistic({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
  });
  instance.setOptions({
    modelComplexity: 1,
    smoothLandmarks: true,
    enableSegmentation: true,
    refineFaceLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  instance.onResults(handleHolisticResults);
  return instance;
};

holistic = createHolistic();

    async function startCamera() {
      stopSampleVideo();
      await resetHolistic();
      resetSegmentationData();
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          aspectRatio: { ideal: 16 / 9 }
        },
        audio: false
      });
      videoEl.srcObject = stream;
      await videoEl.play();
      applyStatus("Live camera ready");

      camera = new Camera(videoEl, {
        onFrame: async () => {
          if (currentSource !== "camera") {
            return;
          }
          if (!videoEl.videoWidth || !videoEl.videoHeight) {
            return;
          }
          if (holisticBusy) {
            return;
          }
          holisticBusy = true;
          try {
            const inferenceStart = performance.now();
            await holistic.send({ image: videoEl });
            recordInferenceTime(performance.now() - inferenceStart);
          } finally {
            holisticBusy = false;
          }
        },
        width: videoEl.videoWidth || 960,
        height: videoEl.videoHeight || 720
      });
      currentSource = "camera";
      resetPerformanceMetrics();
      camera.start();
    }

    async function startSampleVideo() {
      stopCamera();
      stopSampleVideo();
      await resetHolistic();
      resetSegmentationData();
      videoEl.srcObject = null;
      videoEl.src = SAMPLE_VIDEO_URL;
      try {
        await waitForVideoReady(videoEl);
      } catch (err) {
        console.error("Sample video failed to load", err);
        applyStatus("Sample video load failed");
        return;
      }
      await videoEl.play();
      applyStatus("Using sample video");
      currentSource = "sample";
      resetPerformanceMetrics();

      const loop = async () => {
        if (currentSource !== "sample") {
          return;
        }
        if (videoEl.ended) {
          videoEl.currentTime = 0;
          await videoEl.play();
        }
        if (currentSource === "sample" && !videoEl.paused && videoEl.readyState >= 2) {
          if (!holisticBusy) {
            holisticBusy = true;
            try {
              const inferenceStart = performance.now();
              await holistic.send({ image: videoEl });
              recordInferenceTime(performance.now() - inferenceStart);
            } catch (err) {
              console.warn("Holistic send failed on sample frame", err);
            } finally {
              holisticBusy = false;
            }
          }
        }
        if (currentSource === "sample") {
          sampleHandle = requestAnimationFrame(loop);
        }
      };
      sampleHandle = requestAnimationFrame(loop);
    }

    function stopCamera() {
      if (currentSource === "camera") {
        currentSource = "none";
      }
      resetSegmentationData();
      if (camera) {
        camera.stop();
        camera = null;
      }
      const stream = videoEl.srcObject;
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
        videoEl.srcObject = null;
      }
    }

    function stopSampleVideo() {
      if (currentSource === "sample") {
        currentSource = "none";
      }
      resetSegmentationData();
      if (sampleHandle) {
        cancelAnimationFrame(sampleHandle);
        sampleHandle = null;
      }
      if (!videoEl.paused) {
        videoEl.pause();
      }
      videoEl.removeAttribute("src");
      videoEl.load();
    }

    toggleSourceBtn.addEventListener("click", async () => {
      toggleSourceBtn.disabled = true;
      try {
        if (currentSource === "camera") {
          applyStatus("Loading sample video…");
          await startSampleVideo();
        } else {
          applyStatus("Requesting camera…");
          await startCamera();
        }
      } catch (err) {
        console.error("Source switch error", err);
        applyStatus("Source switch failed");
      } finally {
        toggleSourceBtn.disabled = false;
      }
    });

    resetBtn.addEventListener("click", () => {
      for (const [key, controls] of Object.entries(overlayControls)) {
        const defaults = DEFAULT_OVERLAY_STATE[key];
        if (!defaults) continue;
        if (controls.main) {
          controls.main.checked = defaults.main;
        }
        if (controls.preview) {
          controls.preview.checked = defaults.preview;
        }
      }
      if (mirrorCheckbox) {
        if (currentSource === "camera") {
          mirrorCheckbox.checked = true;
        } else {
          mirrorCheckbox.checked = DEFAULT_OVERLAY_STATE.mirror;
        }
      }
      updateOverlayState();
    });

    window.addEventListener("beforeunload", () => {
      stopSampleVideo();
      stopCamera();
    });

    let p5Instance = null;

    const DEFAULT_WIDTH = 1280;
    const DEFAULT_HEIGHT = 720;

    let canvasWidth = DEFAULT_WIDTH;
    let canvasHeight = DEFAULT_HEIGHT;

    const setCanvasDimensions = (p, width, height) => {
      canvasWidth = width || DEFAULT_WIDTH;
      canvasHeight = height || DEFAULT_HEIGHT;
      p.resizeCanvas(canvasWidth, canvasHeight);
    };

    const clampDepth = (value) => Math.max(-0.8, Math.min(0.8, value || 0));

    const hexToRgb = (hex) => {
      const normalized = hex.replace("#", "");
      const bigint = parseInt(normalized, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    };

    const interpolateColor = (fromHex, toHex, t) => {
      const from = hexToRgb(fromHex);
      const to = hexToRgb(toHex);
      const mix = (start, end) => Math.round(start + (end - start) * t);
      return `rgb(${mix(from.r, to.r)}, ${mix(from.g, to.g)}, ${mix(from.b, to.b)})`;
    };

    const depthStyle = (value) => {
      const clamped = clampDepth(value);
      const magnitude = Math.abs(clamped) / 0.8;
      const pivotProximity = 1 - magnitude;
      const pivotShrink = Math.pow(pivotProximity, 3);
      const baseSize = 2.5 + pivotShrink * 2.5;
      const size = baseSize + magnitude * 58;
      const pivotColor = "#a855f7";
      const farColor = "#ff4d4f";
      const nearColor = "#3b82f6";
      const color = clamped >= 0
        ? interpolateColor(pivotColor, farColor, magnitude)
        : interpolateColor(pivotColor, nearColor, magnitude);
      return { color, size };
    };

    const drawLandmarks = (p, results) => {
      if (!results) return;
      const { poseLandmarks, leftHandLandmarks, rightHandLandmarks, faceLandmarks } = results;

      const drawConnectorSet = (landmarks, connections, color, weight) => {
        p.stroke(color);
        p.strokeWeight(weight);
        for (let i = 0; i < connections.length; i++) {
          const [startIndex, endIndex] = connections[i];
          const start = landmarks[startIndex];
          const end = landmarks[endIndex];
          if (!start || !end) continue;
          p.line(start.x * canvasWidth, start.y * canvasHeight, end.x * canvasWidth, end.y * canvasHeight);
        }
      };

      const drawLandmarkPoints = (landmarks, color, size = 6) => {
        p.fill(color);
        p.noStroke();
        for (const lm of landmarks) {
          p.circle(lm.x * canvasWidth, lm.y * canvasHeight, size);
        }
      };

      if (overlayState.pose?.main && poseLandmarks) {
        drawConnectorSet(poseLandmarks, SAFE_POSE_CONNECTIONS, "#4cc9f0", 3);
        drawLandmarkPoints(poseLandmarks, "rgba(76, 201, 240, 0.7)", 5);
      }
      if (overlayState.leftHand?.main && leftHandLandmarks) {
        drawConnectorSet(leftHandLandmarks, SAFE_HAND_CONNECTIONS, "#ff7096", 2.5);
        drawLandmarkPoints(leftHandLandmarks, "rgba(255, 112, 150, 0.9)", 4);
      }
      if (overlayState.rightHand?.main && rightHandLandmarks) {
        drawConnectorSet(rightHandLandmarks, SAFE_HAND_CONNECTIONS, "#ff8fa3", 2.5);
        drawLandmarkPoints(rightHandLandmarks, "rgba(255, 143, 163, 0.9)", 4);
      }
      if (overlayState.face?.main && faceLandmarks) {
        p.noFill();
        p.stroke("#f9c74f");
        p.strokeWeight(1.2);
        if (SAFE_FACEMESH_TESSELATION.length) {
          for (let i = 0; i < SAFE_FACEMESH_TESSELATION.length; i++) {
            const [startIndex, endIndex] = SAFE_FACEMESH_TESSELATION[i];
            const start = faceLandmarks[startIndex];
            const end = faceLandmarks[endIndex];
            if (!start || !end) continue;
            p.line(start.x * canvasWidth, start.y * canvasHeight, end.x * canvasWidth, end.y * canvasHeight);
          }
        } else {
          drawLandmarkPoints(faceLandmarks, "rgba(249, 199, 79, 0.8)", 3);
        }
      }
      if (overlayState.depth?.main && poseLandmarks) {
        p.noStroke();
        for (const lm of poseLandmarks) {
          const { color, size } = depthStyle(lm.z ?? 0);
          p.fill(color);
          p.drawingContext.save();
          p.drawingContext.globalAlpha = 0.5;
          p.circle(lm.x * canvasWidth, lm.y * canvasHeight, size);
          p.drawingContext.restore();
        }
      }
    };

    const drawPerformanceOverlay = (p) => {
      const fpsText = Number.isFinite(performanceMetrics.fps) && performanceMetrics.fps > 0
        ? performanceMetrics.fps.toFixed(1)
        : "--";
      const frameText = Number.isFinite(performanceMetrics.frameMs) && performanceMetrics.frameMs > 0
        ? performanceMetrics.frameMs.toFixed(1)
        : "--";
      const inferenceText = Number.isFinite(performanceMetrics.inferenceMs) && performanceMetrics.inferenceMs > 0
        ? performanceMetrics.inferenceMs.toFixed(1)
        : "--";
      const lines = [
        `FPS: ${fpsText}`,
        `Frame: ${frameText} ms`,
        `Inference: ${inferenceText} ms`,
        `Source: ${performanceMetrics.source}`
      ];
      const padding = 16;
      const boxWidth = 240;
      const lineHeight = 20;
      const boxHeight = padding * 1.5 + lines.length * lineHeight;
      p.push();
      p.noStroke();
      p.fill(10, 14, 24, 220);
      p.rect(padding, padding, boxWidth, boxHeight, 12);
      p.fill(245, 247, 255);
      p.textSize(15);
      p.textAlign(p.LEFT, p.TOP);
      lines.forEach((line, index) => {
        p.text(line, padding + 12, padding + 10 + index * lineHeight);
      });
      p.pop();
    };

const drawSegmentation = (p) => {
  if (!overlayState.segmentation?.main || !segmentationMaskAvailable || !segmentationTintCanvas.width) {
    return;
  }
  const ctx = p.drawingContext;
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.drawImage(segmentationTintCanvas, 0, 0, canvasWidth, canvasHeight);
  ctx.restore();
};

    p5Instance = new p5((p) => {
      p.setup = () => {
        const canvas = p.createCanvas(DEFAULT_WIDTH, DEFAULT_HEIGHT);
        canvas.parent(sketchContainer);
        p.background(4, 7, 13);
        p.noStroke();
      };

      p.draw = () => {
        const now = performance.now();
        const delta = now - lastFrameTimestamp;
        lastFrameTimestamp = now;
        if (delta > 0 && delta < 1000) {
          const instantFps = 1000 / delta;
          smoothedFps = smoothedFps ? smoothedFps * 0.9 + instantFps * 0.1 : instantFps;
          smoothedFrameMs = smoothedFrameMs ? smoothedFrameMs * 0.9 + delta * 0.1 : delta;
          performanceMetrics.fps = smoothedFps;
          performanceMetrics.frameMs = smoothedFrameMs;
        }
        performanceMetrics.source = currentSource;

        const videoWidth = videoEl.videoWidth || DEFAULT_WIDTH;
        const videoHeight = videoEl.videoHeight || DEFAULT_HEIGHT;

        if (!videoWidth || !videoHeight) {
          drawPreviewCanvas();
          return;
        }

        if (p.width !== videoWidth || p.height !== videoHeight) {
          p.resizeCanvas(videoWidth, videoHeight);
        }
        setCanvasDimensions(p, videoWidth, videoHeight);

        p.canvas.style.width = "auto";
        p.canvas.style.height = "auto";
        p.canvas.style.maxWidth = "100%";
        p.canvas.style.maxHeight = "100%";

        p.push();
        if (overlayState.mirror && currentSource === "camera") {
          p.translate(canvasWidth, 0);
          p.scale(-1, 1);
        }

        p.background(4, 7, 13, overlayState.underlay?.main ? 180 : 255);

        if (overlayState.underlay?.main && videoEl.readyState >= 2) {
          const ctx = p.drawingContext;
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.drawImage(videoEl, 0, 0, canvasWidth, canvasHeight);
          ctx.restore();
        }

        drawSegmentation(p);
        drawLandmarks(p, latestResults);

        p.pop();

        if (overlayState.performance?.main) {
          drawPerformanceOverlay(p);
        }

        drawPreviewCanvas();
      };
    });

    (async () => {
      try {
        applyStatus("Requesting camera…");
        await startCamera();
      } catch (err) {
        console.warn("Camera unavailable, falling back to sample video.", err);
        applyStatus("Camera blocked — using sample video");
        await startSampleVideo();
      }
    })();
  </script>
</body>
</html>
