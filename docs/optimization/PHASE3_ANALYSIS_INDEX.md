# Phase 3 Analysis - Complete Documentation Index

**Date:** November 10, 2025  
**Analysis Scope:** Rendering architecture, OffscreenCanvas optimization opportunities  
**Generated by:** Claude Code Analysis

---

## Quick Start

If you're short on time, read these in order:

1. **OFFSCREENCANVAS_OPTIMIZATION_SUMMARY.txt** (5 min)
   - Concise summary of opportunities and implementation priorities
   - Ranked list of optimization candidates
   - Quick performance expectations

2. **PHASE3_OPTIMIZATION_DIAGRAM.txt** (10 min)
   - Visual flowchart of current rendering
   - Optimized rendering with OffscreenCanvas
   - Code modification checklist

3. **PHASE3_IMPLEMENTATION_GUIDE.md** (15 min)
   - Complete implementation roadmap
   - Step-by-step instructions for Phase 3a/3b/3c
   - Performance expectations by phase

---

## Full Documentation Set

### Executive Summaries

| Document | Purpose | Read Time |
|----------|---------|-----------|
| **OFFSCREENCANVAS_OPTIMIZATION_SUMMARY.txt** | Quick overview of optimization opportunities | 5 min |
| **PHASE3_IMPLEMENTATION_GUIDE.md** | Complete Phase 3 roadmap with code examples | 15 min |

### Technical Deep Dives

| Document | Purpose | Read Time |
|----------|---------|-----------|
| **RENDERING_ARCHITECTURE_ANALYSIS.md** | Detailed rendering architecture analysis | 30 min |
| **PHASE3_OPTIMIZATION_DIAGRAM.txt** | Visual diagrams and flowcharts | 10 min |
| **PERFORMANCE_ANALYSIS.md** | Original performance analysis with bottleneck breakdown | 20 min |

### Implementation References

| Document | Purpose | Read Time |
|----------|---------|-----------|
| **OPTIMIZATION_QUICK_START.md** | Quick fixes for Phase 1-2 (already partially complete) | 10 min |
| **BOTTLENECK_SUMMARY.txt** | Summary of current bottlenecks | 5 min |
| **TESTING_GUIDE.md** | How to measure performance and validate improvements | 10 min |
| **IMPLEMENTATION_COMPLETE.md** | Summary of completed work so far | 5 min |

---

## Key Findings Summary

### Architecture Overview

**Rendering Pipeline:**
```
requestAnimationFrame (60 FPS)
  → render()
    → renderTo() [lines 604-796]
      - Dirty rectangle clearing (already optimized!)
      - Per-stream landmark/data rendering
    → renderViewportOverlay() [lines 826-900]
      - Viewport bounds + selection handles
```

**File Locations:**
- Main rendering: `/scripts/drawing/index.js` (1350 lines)
- Layer system: `/scripts/layers/index.js` (970 lines)
- MediaPipe: `/scripts/mediapipe/index.js` (250+ lines)

---

## Layer Categorization

### Data-Dependent (Real-time, NOT suitable for OffscreenCanvas)

- **Pose:** 33 landmarks, updates 10-30 FPS
- **Hands:** 42 landmarks (21×2), updates 10-30 FPS
- **Face:** 468 landmarks, updates 10-30 FPS
- **Segmentation:** Mask texture, updates 10-30 FPS
- **Raw Video:** Video frames, updates up to 60 FPS

**Why not cache:** Landmarks change every frame, making pre-rendering worthless

**Better optimization:** Path2D batching (5-15% gain)

### Static/Semi-Static (CAN be cached with OffscreenCanvas)

- **Viewport Bounds:** Fallback rectangle, changes on color/viewport/state
- **Viewport Overlay:** Edit mode UI, changes on selection/camera
- **Metrics Display:** FPS + info, updates every frame

---

## OffscreenCanvas Opportunities

### Priority 1: Viewport Overlay (HIGHEST ROI)

**Current Cost:** ~0.2-0.5ms per stream per frame  
**Operations:** `setLineDash()` + `strokeRect()` per frame  
**Expected Gain:** 15-25% FPS  
**Effort:** 4-6 hours (Medium complexity)  
**Implementation:** Phase 3b (Week 2)

### Priority 2: Viewport Bounds (HIGH ROI)

**Current Cost:** Per-frame rectangle draw  
**Operations:** `fillRect()` + `setLineDash()` + `strokeRect()`  
**Expected Gain:** 10-20% FPS  
**Effort:** 2-3 hours (Low complexity)  
**Implementation:** Phase 3a (Week 1)

### Priority 3: Metrics Panel (MEDIUM ROI)

**Current Cost:** 20+ `measureText()` calls per frame  
**Operations:** Text measurement, background, 10-15 text renders  
**Expected Gain:** 5-10% FPS  
**Effort:** 6-8 hours (High complexity)  
**Implementation:** Phase 3c (Week 3, optional)

---

## Performance Impact Summary

### Baseline (Current)
- 1080p @ 60 FPS target: ~25-35 FPS
- 4K @ 60 FPS target: ~10-15 FPS

### After Phase 3 Complete
- 1080p: ~32-54 FPS (+28-54%)
- 4K: ~15-22 FPS (+45-50%)

### Incremental Gains
- Phase 3a (Bounds): +8-20%
- Phase 3b (Overlay): +23-50%
- Phase 3c (Metrics): +5-10%

---

## Current Optimizations (Already Implemented)

✅ **Dirty Rectangle Clearing** (lines 620-655)
- Clears only affected canvas regions instead of full canvas
- Reduces pixel operations by 40-80%

✅ **Frame Skipping** (lines 440-446, 803-816)
- Throttles rendering to target FPS
- Skips frames when running ahead

✅ **Output Resolution Scaling** (lines 447-453)
- Supports resolution presets (1080p, 720p, 4K)
- Allows runtime quality adjustment

---

## Implementation Roadmap

### Phase 3a (Week 1) - Viewport Bounds Pre-rendering
- Add OffscreenCanvas caching to state
- Pre-render bounds rectangles
- Composite with `drawImage()` each frame
- Cache invalidation on color/viewport/state changes
- **Expected:** 10-20% FPS gain

### Phase 3b (Week 2) - Viewport Overlay Pre-rendering
- Extract viewport rect rendering
- Create OffscreenCanvas cache per stream
- Refactor overlay rendering for composition
- Selective handle-only redraw when selected
- **Expected:** 15-25% FPS gain

### Phase 3c (Week 3) - Metrics Panel Optimization
- Separate static background to OffscreenCanvas
- Create dynamic FPS text canvas
- Cache text measurements
- **Expected:** 5-10% FPS gain
- **Note:** Optional - only if metrics > 5% overhead

---

## Code Locations Quick Reference

| Component | File | Lines | Purpose |
|-----------|------|-------|---------|
| DATA_DEPENDENT_PROCESSES | drawing/index.js | 44 | Defines real-time layers |
| renderTo() | drawing/index.js | 604-796 | Main render function |
| Dirty rectangle logic | drawing/index.js | 620-655 | Optimization (already done) |
| Frame skipping | drawing/index.js | 798-823 | Optimization (already done) |
| renderViewportOverlay() | drawing/index.js | 826-900 | Overlay rendering (optimize Phase 3b) |
| drawViewportBounds() | drawing/index.js | 181-192 | Bounds fallback (optimize Phase 3a) |
| drawMetrics() | drawing/index.js | 229-362 | Metrics display (optimize Phase 3c) |
| Event handlers | drawing/index.js | 1228-1276 | Update triggers |
| State object | drawing/index.js | 422-457 | Add caches here |

---

## When to Use OffscreenCanvas

✅ **DO use when:**
- Rendering expensive geometry (paths, complex drawing)
- Content changes infrequently (amortization benefit)
- Reused every frame (cache overhead justified)
- drawImage() is significantly faster than direct drawing

❌ **DON'T use when:**
- Content changes every frame (no amortization)
- Simple rendering (drawImage() not faster)
- Memory overhead exceeds benefit
- Complexity not justified by gain < 5%

---

## Key Insights

### Why Viewport Overlay Fits OffscreenCanvas Perfectly
1. Complex operations: `setLineDash()` + `strokeRect()` = expensive
2. Rarely changes: Only on interaction/selection
3. Used every frame: Cache amortizes perfectly
4. 3-5x faster with `drawImage()` vs paths
5. Simple invalidation: Color/viewport/enabled state changes

### Why Landmarks Don't Benefit from OffscreenCanvas
1. Update every frame: No amortization
2. Simple paths: Arc drawing isn't expensive
3. Cache overhead = benefit: Would redraw anyway
4. Better approach: Path2D batching (5-15% gain)

---

## Testing & Measurement

### FPS Tracking
```javascript
// In DevTools console:
window.state?.fpsTracker  // Access FPS tracker from state
```

### Performance Timeline
```javascript
performance.clearMarks();
performance.mark('test-start');
// ... let app run for 5 seconds ...
performance.mark('test-end');
performance.measure('test', 'test-start', 'test-end');
const measure = performance.getEntriesByName('test')[0];
console.log(`Expected FPS: ${(5000 / measure.duration * 60).toFixed(0)}`);
```

### DevTools Profiling
1. Open DevTools > Performance tab
2. Record while interacting with app
3. Look for "long tasks" > 50ms
4. Check FPS meter in top-right corner
5. Measure improvements phase-by-phase

---

## Document Dependencies

```
START HERE:
  ├─ OFFSCREENCANVAS_OPTIMIZATION_SUMMARY.txt (5 min)
  └─ Read as starting overview

THEN READ:
  ├─ PHASE3_OPTIMIZATION_DIAGRAM.txt (10 min)
  ├─ PHASE3_IMPLEMENTATION_GUIDE.md (15 min)

FOR DETAILS:
  ├─ RENDERING_ARCHITECTURE_ANALYSIS.md (30 min)
  ├─ PERFORMANCE_ANALYSIS.md (20 min)
  └─ OPTIMIZATION_QUICK_START.md (10 min)

FOR IMPLEMENTATION:
  ├─ PHASE3_IMPLEMENTATION_GUIDE.md
  ├─ TESTING_GUIDE.md
  └─ Code reference files in scripts/
```

---

## Summary of Recommendations

### Immediate (Phase 3a)
- Implement viewport bounds OffscreenCanvas caching
- Effort: 2-3 hours
- Gain: 10-20% FPS
- Risk: Low

### Short-term (Phase 3b)
- Implement viewport overlay OffscreenCanvas caching
- Effort: 4-6 hours
- Gain: 15-25% FPS
- Risk: Low-Medium

### Optional (Phase 3c)
- Optimize metrics panel (if overhead > 5%)
- Effort: 6-8 hours
- Gain: 5-10% FPS
- Risk: Medium

### Total Expected Improvement
**25-40% FPS at 1080p | 40-50% FPS at 4K**

---

## Questions to Ask When Implementing

1. **Before Phase 3a:** Are bounds falling back (no MediaPipe data)? Are they being redrawn every frame?
2. **Before Phase 3b:** Is viewport overlay visible in edit mode? How many streams in typical use case?
3. **Before Phase 3c:** What percentage of frame time is metrics taking? Worth the complexity?

---

## Related Resources

- **Previous Analysis:** PERFORMANCE_ANALYSIS.md (detailed bottleneck breakdown)
- **Quick Fixes:** OPTIMIZATION_QUICK_START.md (Phase 1-2 optimizations)
- **Testing:** TESTING_GUIDE.md (how to measure performance)

---

**End of Index**

For questions or clarifications, refer to the specific document that covers your topic, or contact the analysis author with file paths and line numbers.

