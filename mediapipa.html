<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mediapiper · Holistic Preview</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined">
  <style>
    html, body {
      height: 100%;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      display: flex;
      overflow: hidden;
      background: radial-gradient(120% 120% at 10% 10%, #0d1525 0%, #04070d 48%, #02040a 100%);
    }
    .preview-layout {
      position: relative;
      flex: 1;
      display: flex;
      width: 100vw;
      height: 100vh;
      min-width: 0;
      min-height: 0;
      align-items: stretch;
      justify-content: center;
      gap: 0;
    }
    .preview-canvas {
      position: relative;
      flex: 1 1 auto;
      width: 100%;
      height: 100%;
      min-width: 0;
      min-height: 0;
      background: #000;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #mediapiper-sketch {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .preview-canvas canvas {
      display: block;
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 100%;
    }
    .preview-canvas video {
      display: none;
    }
    .panel {
      position: absolute;
      top: 0;
      right: 0;
      flex: 0 0 auto;
      width: clamp(260px, 26vw, 340px);
      max-width: 380px;
      background: rgba(10, 14, 24, 0.95);
      border-left: 1px solid rgba(255, 255, 255, 0.12);
      padding: 1rem 1.2rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      /* backdrop-filter: blur(20px); */
      height: 100%;
      overflow-y: auto;
      transform: translateX(100%);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.32s ease, opacity 0.32s ease;
      z-index: 200;
      box-shadow: -18px 0 48px rgba(0, 0, 0, 0.45);
    }
    .panel.is-open {
      transform: translateX(0);
      opacity: 1;
      pointer-events: auto;
    }
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }
    .panel-header h2 {
      margin: 0;
      font-size: 1.05rem;
      font-weight: 600;
    }
    .panel-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    .panel-actions .panel-close {
      margin-left: 0.25rem;
    }
    .panel-actions .icon-button {
      padding: 0.4rem;
    }
    .panel-tabs {
      display: inline-flex;
      gap: 0.4rem;
      padding: 0.35rem;
      border-radius: 12px;
      background: rgba(9, 13, 22, 0.72);
      border: 1px solid rgba(255, 255, 255, 0.08);
      align-self: flex-start;
    }
    .panel-tabs button {
      appearance: none;
      border: 0;
      border-radius: 9px;
      background: transparent;
      padding: 0.35rem 0.8rem;
      color: rgba(245, 247, 255, 0.68);
      font-size: 0.82rem;
      font-weight: 500;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 0.18s ease, color 0.18s ease;
    }
    .panel-tabs button:hover {
      color: rgba(245, 247, 255, 0.9);
    }
    .panel-tabs button.is-active {
      background: rgba(255, 255, 255, 0.14);
      color: rgba(4, 6, 12, 0.92);
    }
    .panel-content {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      flex: 1;
    }
    .panel-routing {
      display: grid;
      gap: 0.6rem;
      padding: 0.75rem;
      margin: 0 0.35rem;
      border-radius: 12px;
      background: rgba(12, 18, 30, 0.74);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .panel-routing-row {
      display: grid;
      gap: 0.4rem;
    }
    .panel-routing-row label {
      font-size: 0.82rem;
      color: rgba(245, 247, 255, 0.72);
    }
    .panel-section {
      display: none;
      flex-direction: column;
      gap: 0.75rem;
    }
    .panel-section.is-active {
      display: flex;
    }
    .stream-controls {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0 0.45rem;
    }
    .stream-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2.25rem;
      height: 2.25rem;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease;
      position: relative;
    }
    .stream-toggle:hover {
      background: rgba(255, 255, 255, 0.14);
      border-color: rgba(255, 255, 255, 0.24);
    }
    .stream-toggle input[type="checkbox"] {
      opacity: 0;
      position: absolute;
      inset: 0;
      margin: 0;
      cursor: pointer;
    }
    .stream-toggle .material-icons-outlined {
      font-size: 18px;
      pointer-events: none;
      color: rgba(245, 247, 255, 0.82);
    }
    .stream-toggle input[type="checkbox"]:checked + .material-icons-outlined {
      color: #f97316;
    }
    .stream-toggle input[type="checkbox"]:focus-visible + .material-icons-outlined {
      outline: 2px solid #f97316;
      outline-offset: 2px;
    }
    .status-chip {
      background: rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      padding: 0.15rem 0.65rem;
      font-size: 0.8rem;
      color: rgba(245, 247, 255, 0.7);
    }
    .segment-preview {
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(5, 9, 18, 0.72);
      text-align: center;
      padding: 0.4rem;
    }
    .segment-preview canvas {
      width: 100%;
      height: auto;
      display: block;
    }
    .overlay-toggles {
      display: grid;
      gap: 0.55rem;
    }
    .overlay-toggles-header {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 90px 90px;
      padding: 0 0.45rem;
      font-size: 0.72rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(245, 247, 255, 0.45);
    }
    .overlay-toggle {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 90px 90px;
      align-items: center;
      gap: 0.35rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 0.55rem 0.65rem;
    }
    .overlay-name {
      color: rgba(245, 247, 255, 0.82);
      font-size: 0.9rem;
      font-weight: 500;
    }
    .overlay-switch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .overlay-switch input[type="checkbox"] {
      accent-color: #ff4081;
      width: 1.1rem;
      height: 1.1rem;
      cursor: pointer;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .tip {
      font-size: 0.83rem;
      color: rgba(245, 247, 255, 0.65);
      line-height: 1.4;
    }
    .panel-footnote {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 0 0.45rem 0.75rem;
    }
    .panel-backdrop {
      position: absolute;
      inset: 0;
      background: transparent;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.32s ease;
      z-index: 190;
    }
    .panel-backdrop.is-visible {
      opacity: 1;
    }
    .panel-toggle,
    .editor-toggle {
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      z-index: 50;
      width: 1.6rem;
      height: 1.6rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(9, 13, 22, 0.92);
      color: #f5f7ff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.28);
    }
    .panel-toggle {
      right: 1rem;
      bottom: 1rem;
    }
    .editor-toggle {
      right: 3.2rem;
      bottom: 1rem;
    }
    .panel-toggle .material-icons-outlined {
      font-size: 16px;
    }
    .panel-toggle:hover,
    .editor-toggle:hover {
      background: rgba(13, 19, 30, 0.96);
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.24);
    }
    .panel-toggle:active,
    .editor-toggle:active {
      transform: translateY(0);
    }
    .panel-toggle.panel-toggle-open {
      opacity: 0;
      pointer-events: none;
    }
    .editor-toggle .material-icons-outlined {
      font-size: 16px;
    }
    .editor-toggle.is-hidden {
      opacity: 0.75;
    }
    .gesture-editor {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      pointer-events: none;
      z-index: 100;
    }
    .gesture-editor-toolbar {
      position: absolute;
      top: auto;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.35rem;
      padding: 0.5rem 0.65rem;
      border-radius: 16px;
      background: rgba(8, 12, 22, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 18px 42px rgba(0, 0, 0, 0.4);
      pointer-events: auto;
      -webkit-user-select: none;
      user-select: none;
      z-index: 80;
    }
    .gesture-editor-toolbar button {
      border: 1px solid transparent;
      background: transparent;
      color: rgba(245, 247, 255, 0.76);
      padding: 0.35rem;
      border-radius: 10px;
      display: inline-flex;
      gap: 0;
      align-items: center;
      justify-content: center;
      width: 2.4rem;
      height: 2.4rem;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease, color 0.18s ease;
    }
    .gesture-editor-toolbar button .material-icons-outlined {
      font-size: 18px;
    }
    .gesture-editor-toolbar button:hover {
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.92);
    }
    .gesture-editor-toolbar button.is-active {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.18);
      color: #f5f7ff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
    }
    .gesture-editor-toolbar .toolbar-divider {
      width: 1px;
      height: 2.2rem;
      background: rgba(255, 255, 255, 0.12);
      margin: 0 0.4rem;
    }
    .gesture-svg-wrapper {
      flex: 1;
      position: relative;
      pointer-events: none;
    }
    .gesture-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      touch-action: none;
    }
    .gesture-svg-wrapper.is-mirrored .gesture-svg {
      transform: scaleX(-1);
      transform-origin: center;
    }
    .gesture-svg [data-shape-id] {
      cursor: pointer;
      transition: filter 0.18s ease, opacity 0.18s ease;
    }
    .gesture-svg [data-shape-id].is-selected {
      filter: drop-shadow(0 0 12px rgba(82, 213, 255, 0.45));
    }
    .gesture-svg [data-shape-id].is-active {
      filter: drop-shadow(0 0 14px rgba(82, 213, 255, 0.6));
      opacity: 0.98;
    }
    .gesture-polyline-preview {
      pointer-events: none;
      opacity: 0.65;
    }
    .gesture-svg .gesture-handle {
      fill: rgba(52, 211, 153, 0.92);
      stroke: rgba(13, 148, 136, 0.8);
      stroke-width: 1;
      cursor: nwse-resize;
    }
    .gesture-svg .gesture-handle[data-handle="n"],
    .gesture-svg .gesture-handle[data-handle="s"] {
      cursor: ns-resize;
    }
    .gesture-svg .gesture-handle[data-handle="e"],
    .gesture-svg .gesture-handle[data-handle="w"] {
      cursor: ew-resize;
    }
    .gesture-svg .gesture-handle[data-handle="ne"],
    .gesture-svg .gesture-handle[data-handle="sw"] {
      cursor: nesw-resize;
    }
    .gesture-svg .gesture-handle[data-handle="nw"],
    .gesture-svg .gesture-handle[data-handle="se"] {
      cursor: nwse-resize;
    }
    .gesture-svg .gesture-outline {
      fill: none;
      stroke: rgba(82, 213, 255, 0.75);
      stroke-width: 1.2;
      stroke-dasharray: 6 4;
    }
    .gesture-editor.is-performing .gesture-svg {
      pointer-events: none;
    }
    .gesture-editor.is-hidden {
      display: none;
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(4, 7, 13, 0.6);
      /* backdrop-filter: blur(2px); */
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 90;
    }
    .modal-backdrop.is-visible {
      opacity: 1;
      pointer-events: auto;
    }
    .assignment-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -55%);
      width: min(420px, calc(100vw - 2rem));
      max-height: calc(100vh - 4rem);
      overflow-y: auto;
      background: rgba(9, 13, 22, 0.97);
      border-radius: 16px;
      padding: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 32px 62px rgba(0, 0, 0, 0.55);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.24s ease, transform 0.24s ease;
      z-index: 95;
    }
    .assignment-modal.is-visible {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%);
    }
    .assignment-modal header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .assignment-modal header h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    .assignment-modal .form-group {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .assignment-modal label {
      font-size: 0.86rem;
      color: rgba(245, 247, 255, 0.78);
    }
    .assignment-modal select,
    .assignment-modal input[type="text"],
    .assignment-modal input[type="number"] {
      width: 100%;
      padding: 0.5rem 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(6, 10, 18, 0.92);
      color: #f5f7ff;
      font-size: 0.88rem;
    }
    .assignment-modal .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      margin-top: 1rem;
    }
    .assignment-modal .modal-actions button {
      padding: 0.5rem 0.85rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(82, 213, 255, 0.1);
      color: #f5f7ff;
      font-size: 0.88rem;
      cursor: pointer;
      transition: background 0.18s ease;
    }
    .assignment-modal .modal-actions button:hover {
      background: rgba(82, 213, 255, 0.2);
    }
    .assignment-modal .modal-actions button.secondary {
      background: rgba(255, 255, 255, 0.08);
    }
    .assignment-modal .modal-actions button.secondary:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    .no-pointer {
      pointer-events: none;
    }
    .editor-panel {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      min-height: 0;
    }
    .editor-shape-list {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(12, 18, 30, 0.74);
      border: 1px solid rgba(255, 255, 255, 0.08);
      overflow-y: auto;
      max-height: 22vh;
    }
    .editor-shape-list button {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.02);
      color: rgba(245, 247, 255, 0.8);
      padding: 0.55rem 0.7rem;
      cursor: pointer;
      font-size: 0.86rem;
      transition: background 0.18s ease, border-color 0.18s ease, color 0.18s ease;
    }
    .editor-shape-list button:hover {
      background: rgba(255, 255, 255, 0.08);
    }
    .editor-shape-list button.is-active {
      background: rgba(82, 213, 255, 0.2);
      border-color: rgba(82, 213, 255, 0.4);
      color: #f5f7ff;
      box-shadow: inset 0 0 0 1px rgba(82, 213, 255, 0.32);
    }
    .editor-shape-list button[data-active="true"]:not(.is-active) {
      border-color: rgba(82, 213, 255, 0.28);
      box-shadow: inset 0 0 0 1px rgba(82, 213, 255, 0.18);
    }
    .editor-shape-list button .shape-meta {
      font-size: 0.72rem;
      opacity: 0.7;
    }
    .editor-detail {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(12, 18, 30, 0.74);
      border: 1px solid rgba(255, 255, 255, 0.08);
      max-height: 45vh;
      overflow-y: auto;
    }
    .editor-detail-empty {
      font-size: 0.88rem;
      line-height: 1.5;
      color: rgba(245, 247, 255, 0.65);
    }
    .editor-detail-form {
      display: grid;
      gap: 0.75rem;
    }
    .editor-detail-form .form-row {
      display: grid;
      gap: 0.35rem;
    }
    .editor-detail-form label {
      font-size: 0.82rem;
      color: rgba(245, 247, 255, 0.72);
    }
    .editor-detail-form select,
    .editor-detail-form input[type="text"],
    .editor-detail-form input[type="number"] {
      width: 100%;
      padding: 0.5rem 0.65rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(6, 10, 18, 0.92);
      color: #f5f7ff;
      font-size: 0.88rem;
    }
    .editor-detail-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.5rem;
    }
    .editor-detail-actions button {
      padding: 0.5rem 0.85rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(82, 213, 255, 0.1);
      color: #f5f7ff;
      font-size: 0.86rem;
      cursor: pointer;
      transition: background 0.18s ease;
    }
    .editor-detail-actions button:hover {
      background: rgba(82, 213, 255, 0.2);
    }
    .editor-detail-actions button.secondary {
      background: rgba(255, 255, 255, 0.08);
    }
    .editor-detail-actions button.secondary:hover {
      background: rgba(255, 255, 255, 0.14);
    }
    .editor-detail-actions button.danger {
      background: rgba(244, 63, 94, 0.15);
      border-color: rgba(244, 63, 94, 0.4);
      color: rgba(255, 219, 227, 0.92);
    }
    .editor-detail-actions button.danger:hover {
      background: rgba(244, 63, 94, 0.25);
    }
    .input-with-button {
      display: flex;
      gap: 0.45rem;
      align-items: stretch;
    }
    .input-with-button select,
    .input-with-button input {
      flex: 1;
    }
    .input-with-button .icon-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.08);
      color: #f5f7ff;
      width: 2.3rem;
      transition: background 0.18s ease;
    }
    .input-with-button .icon-button:hover {
      background: rgba(255, 255, 255, 0.16);
    }
    .dual-input-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.45rem;
    }
    @media (max-width: 1200px) {
      .editor-detail,
      .editor-shape-list {
        max-height: none;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
</head>
<body>
  <main class="preview-layout">
    <section class="preview-canvas">
      <div id="mediapiper-sketch"></div>
      <div id="gesture-editor" class="gesture-editor" aria-label="Interactive score editor">
        <div id="gesture-toolbar" class="gesture-editor-toolbar" role="toolbar" aria-label="Editor tools">
          <button id="gesture-tool-select" class="is-active" type="button" data-tool="select" title="Select (V)" aria-label="Select (V)">
            <span class="material-icons-outlined" aria-hidden="true">near_me</span>
          </button>
          <button id="gesture-tool-eraser" type="button" data-tool="eraser" title="Eraser (E)" aria-label="Eraser (E)">
            <span class="material-icons-outlined" aria-hidden="true">auto_fix_off</span>
          </button>
          <button id="gesture-tool-rect" type="button" data-tool="rect" title="Rectangle (R)" aria-label="Rectangle (R)">
            <span class="material-icons-outlined" aria-hidden="true">crop_square</span>
          </button>
          <button id="gesture-tool-ellipse" type="button" data-tool="ellipse" title="Oval (O)" aria-label="Oval (O)">
            <span class="material-icons-outlined" aria-hidden="true">radio_button_unchecked</span>
          </button>
          <button id="gesture-tool-line" type="button" data-tool="line" title="Line (L)" aria-label="Line (L)">
            <span class="material-icons-outlined" aria-hidden="true">timeline</span>
          </button>
          <button id="gesture-tool-polygon" type="button" data-tool="polygon" title="Polygon (P)" aria-label="Polygon (P)">
            <span class="material-icons-outlined" aria-hidden="true">change_history</span>
          </button>
          <div class="toolbar-divider" aria-hidden="true"></div>
          <button id="gesture-mode-toggle" type="button" title="Toggle perform mode" aria-label="Toggle perform mode">
            <span class="material-icons-outlined" aria-hidden="true">play_circle</span>
          </button>
          <button id="gesture-clear" type="button" title="Clear all shapes" aria-label="Clear all shapes">
            <span class="material-icons-outlined" aria-hidden="true">delete_sweep</span>
          </button>
        </div>
        <div class="gesture-svg-wrapper">
          <svg id="gesture-svg" class="gesture-svg" tabindex="0" role="presentation" aria-label="Score canvas" viewBox="0 0 1280 720" preserveAspectRatio="xMidYMid slice"></svg>
        </div>
      </div>
      <video id="mediapiper-video" muted></video>
    </section>
    <button id="editor-toggle" class="editor-toggle icon-button" type="button" title="Hide score editor" aria-label="Hide score editor" aria-pressed="true">
      <span class="material-icons-outlined" aria-hidden="true">gesture</span>
    </button>
    <button id="panel-toggle" class="panel-toggle icon-button" type="button" title="Hide control panel" aria-label="Hide control panel" aria-expanded="true" aria-controls="mediapiper-panel">
      <span class="material-icons-outlined" aria-hidden="true">close</span>
    </button>
    <div id="panel-backdrop" class="panel-backdrop is-visible"></div>
    <aside class="panel is-open" id="mediapiper-panel" role="dialog" aria-modal="false" aria-label="Mediapiper control panel" aria-hidden="false" tabindex="-1">
      <div class="panel-header">
        <h2>Streams</h2>
        <div class="panel-actions">
          <button id="mediapiper-reset" class="icon-button" title="Reset overlays" aria-label="Reset overlays">
            <span class="material-icons-outlined" aria-hidden="true">refresh</span>
          </button>
          <button id="panel-close" class="icon-button panel-close" type="button" title="Hide control panel" aria-label="Hide control panel">
            <span class="material-icons-outlined" aria-hidden="true">close</span>
          </button>
        </div>
      </div>
      <div class="panel-tabs" role="tablist" aria-label="Panel sections">
        <button type="button" class="is-active" data-panel-tab="streams" role="tab" aria-selected="true" aria-controls="panel-streams">Streams</button>
        <button type="button" data-panel-tab="editor" role="tab" aria-selected="false" aria-controls="panel-editor">Editor</button>
      </div>
      <div class="panel-content">
        <div class="panel-section is-active" data-panel-section="streams" id="panel-streams" role="tabpanel" aria-label="Stream controls">
          <div class="stream-controls">
            <label class="stream-toggle" title="Mirror camera">
              <input type="checkbox" id="mediapiper-mirror" checked aria-label="Mirror camera">
              <span class="material-icons-outlined" aria-hidden="true">flip_camera_android</span>
            </label>
            <button id="mediapiper-toggle-source" class="icon-button" title="Toggle media source" aria-label="Toggle media source">
              <span class="material-icons-outlined" aria-hidden="true">switch_video</span>
            </button>
          </div>
          <div class="overlay-toggles">
            <div class="overlay-toggles-header">
              <span>Stream</span>
              <span>Main</span>
              <span>Preview</span>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">Source</span>
              <label class="overlay-switch" title="Source main">
                <input type="checkbox" id="overlay-underlay-main" checked aria-label="Source main">
              </label>
              <label class="overlay-switch" title="Source preview">
                <input type="checkbox" id="overlay-underlay-preview" aria-label="Source preview">
              </label>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">Pose</span>
              <label class="overlay-switch" title="Pose main">
                <input type="checkbox" id="overlay-pose-main" checked aria-label="Pose main">
              </label>
              <label class="overlay-switch" title="Pose preview">
                <input type="checkbox" id="overlay-pose-preview" aria-label="Pose preview">
              </label>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">LHand</span>
              <label class="overlay-switch" title="Left hand main">
                <input type="checkbox" id="overlay-left-hand-main" checked aria-label="Left hand main">
              </label>
              <label class="overlay-switch" title="Left hand preview">
                <input type="checkbox" id="overlay-left-hand-preview" aria-label="Left hand preview">
              </label>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">RHand</span>
              <label class="overlay-switch" title="Right hand main">
                <input type="checkbox" id="overlay-right-hand-main" checked aria-label="Right hand main">
              </label>
              <label class="overlay-switch" title="Right hand preview">
                <input type="checkbox" id="overlay-right-hand-preview" aria-label="Right hand preview">
              </label>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">Face</span>
              <label class="overlay-switch" title="Face main">
                <input type="checkbox" id="overlay-face-main" checked aria-label="Face main">
              </label>
              <label class="overlay-switch" title="Face preview">
                <input type="checkbox" id="overlay-face-preview" aria-label="Face preview">
              </label>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">Segmentation</span>
              <label class="overlay-switch" title="Segmentation main">
                <input type="checkbox" id="overlay-segmentation-main" aria-label="Segmentation main">
              </label>
              <label class="overlay-switch" title="Segmentation preview">
                <input type="checkbox" id="overlay-segmentation-preview" checked aria-label="Segmentation preview">
              </label>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">Depth</span>
              <label class="overlay-switch" title="Depth main">
                <input type="checkbox" id="overlay-depth-main" aria-label="Depth main">
              </label>
              <label class="overlay-switch" title="Depth preview">
                <input type="checkbox" id="overlay-depth-preview" checked aria-label="Depth preview">
              </label>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">Performance</span>
              <label class="overlay-switch" title="Performance main">
                <input type="checkbox" id="overlay-performance-main" aria-label="Performance main">
              </label>
              <label class="overlay-switch" title="Performance preview">
                <input type="checkbox" id="overlay-performance-preview" checked aria-label="Performance preview">
              </label>
            </div>
            <div class="overlay-toggle">
              <span class="overlay-name">Score</span>
              <label class="overlay-switch" title="Score main">
                <input type="checkbox" id="overlay-score-main" checked aria-label="Score main">
              </label>
              <label class="overlay-switch" title="Score preview">
                <input type="checkbox" id="overlay-score-preview" checked aria-label="Score preview">
              </label>
            </div>
          </div>
          <div class="segment-preview" aria-hidden="false">
            <canvas id="segmentation-preview" width="320" height="180"></canvas>
          </div>
          <div class="panel-footnote">
            <span id="mediapiper-status" class="status-chip">Initializing…</span>
            <div class="tip">
              Toggle Main overlays to affect the canvas, and use Preview toggles to stage diagnostics or capture snapshots.
            </div>
          </div>
        </div>
        <div class="panel-section" data-panel-section="editor" id="panel-editor" role="tabpanel" aria-label="Score editor">
          <div class="panel-routing" aria-label="Global routing settings">
            <div class="panel-routing-row">
              <label for="editor-midi-port">MIDI Port</label>
              <div class="input-with-button">
                <select id="editor-midi-port">
                  <option value="broadcast">All Outputs</option>
                </select>
                <button id="editor-midi-port-refresh" type="button" class="icon-button" title="Refresh MIDI ports" aria-label="Refresh MIDI ports">
                  <span class="material-icons-outlined" aria-hidden="true">refresh</span>
                </button>
              </div>
            </div>
            <div class="panel-routing-row">
              <label>OSC Destination</label>
              <div class="dual-input-row">
                <input id="editor-osc-host" type="text" placeholder="127.0.0.1">
                <input id="editor-osc-port" type="number" min="1" max="65535" placeholder="9000">
              </div>
            </div>
          </div>
          <div class="editor-panel">
            <div class="editor-shape-list" id="editor-shape-list" role="listbox" aria-label="Score elements"></div>
            <div class="editor-detail" id="editor-detail">
              <div class="editor-detail-empty" id="editor-detail-empty">
                Draw a shape to begin. Select it to edit MIDI and OSC mappings.
              </div>
              <form id="editor-detail-form" class="editor-detail-form" autocomplete="off">
                <div class="form-row">
                  <label for="editor-stream-select">Mediapipe Stream</label>
                  <select id="editor-stream-select">
                    <option value="pose">Pose Landmarks</option>
                    <option value="leftHand">Left Hand</option>
                    <option value="rightHand">Right Hand</option>
                    <option value="face">Face (centroid)</option>
                  </select>
                </div>
                <div class="form-row">
                  <label for="editor-landmark-select">Landmark</label>
                  <select id="editor-landmark-select"></select>
                </div>
                <div class="form-row">
                  <label for="editor-trigger-select">Trigger Behavior</label>
                  <select id="editor-trigger-select">
                    <option value="enter">Enter shape</option>
                    <option value="exit">Exit shape</option>
                    <option value="inside">While inside (continuous)</option>
                  </select>
                </div>
                <div class="form-row">
                  <label for="editor-midi-type">MIDI Message</label>
                  <select id="editor-midi-type">
                    <option value="none">None</option>
                    <option value="note">Note</option>
                    <option value="cc">Control Change</option>
                  </select>
                </div>
                <div class="form-row" id="editor-midi-channel-group">
                  <label for="editor-midi-channel">MIDI Channel (1-16)</label>
                  <input id="editor-midi-channel" type="number" min="1" max="16" value="1">
                </div>
                <div class="form-row" id="editor-midi-note-group">
                  <label for="editor-midi-note">Note (0-127)</label>
                  <input id="editor-midi-note" type="number" min="0" max="127" value="60">
                </div>
                <div class="form-row" id="editor-midi-velocity-group">
                  <label for="editor-midi-velocity">Velocity (0-127)</label>
                  <input id="editor-midi-velocity" type="number" min="0" max="127" value="96">
                </div>
                <div class="form-row" id="editor-midi-cc-group">
                  <label for="editor-midi-cc">CC Number</label>
                  <input id="editor-midi-cc" type="number" min="0" max="127" value="1">
                </div>
                <div class="form-row" id="editor-midi-cc-value-group">
                  <label for="editor-midi-cc-value">CC Value</label>
                  <input id="editor-midi-cc-value" type="number" min="0" max="127" value="100">
                </div>
                <div class="form-row">
                  <label for="editor-osc-address">OSC Address</label>
                  <input id="editor-osc-address" type="text" placeholder="/instrument/parameter">
                </div>
                <div class="form-row">
                  <label for="editor-osc-args">OSC Arguments</label>
                  <input id="editor-osc-args" type="text" placeholder="comma separated values">
                </div>
                <div class="editor-detail-actions">
                  <button type="button" id="editor-open-modal" class="secondary">Pop-out editor</button>
                  <button type="button" id="editor-delete-shape" class="danger">Delete shape</button>
                </div>
              </form>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </main>
  <div id="assignment-backdrop" class="modal-backdrop" aria-hidden="true"></div>
  <div id="assignment-modal" class="assignment-modal" role="dialog" aria-modal="true" aria-labelledby="assignment-modal-title" aria-hidden="true">
    <header>
      <h3 id="assignment-modal-title">Interaction Mapping</h3>
      <button id="assignment-modal-close" class="icon-button" type="button" title="Close">
        <span class="material-icons-outlined" aria-hidden="true">close</span>
      </button>
    </header>
    <section class="form-group">
      <label for="assignment-stream">Mediapipe Stream</label>
      <select id="assignment-stream">
        <option value="pose">Pose Landmarks</option>
        <option value="leftHand">Left Hand</option>
        <option value="rightHand">Right Hand</option>
        <option value="face">Face (centroid)</option>
      </select>
    </section>
    <section class="form-group">
      <label for="assignment-landmark">Landmark</label>
      <select id="assignment-landmark"></select>
    </section>
    <section class="form-group">
      <label for="assignment-trigger">Trigger Behavior</label>
      <select id="assignment-trigger">
        <option value="enter">Enter shape</option>
        <option value="exit">Exit shape</option>
        <option value="inside">While inside (continuous)</option>
      </select>
    </section>
    <section class="form-group">
      <label for="assignment-midi-type">MIDI Message</label>
      <select id="assignment-midi-type">
        <option value="none">None</option>
        <option value="note">Note</option>
        <option value="cc">Control Change</option>
      </select>
    </section>
    <section class="form-group">
      <label for="assignment-midi-port">MIDI Port</label>
      <div class="input-with-button">
        <select id="assignment-midi-port">
          <option value="broadcast">All Outputs</option>
        </select>
        <button id="assignment-midi-port-refresh" type="button" class="icon-button" title="Refresh MIDI ports" aria-label="Refresh MIDI ports">
          <span class="material-icons-outlined" aria-hidden="true">refresh</span>
        </button>
      </div>
    </section>
    <section class="form-group" id="assignment-midi-channel-group">
      <label for="assignment-midi-channel">MIDI Channel (1-16)</label>
      <input id="assignment-midi-channel" type="number" min="1" max="16" value="1">
    </section>
    <section class="form-group" id="assignment-midi-note-group">
      <label for="assignment-midi-note">Note (0-127)</label>
      <input id="assignment-midi-note" type="number" min="0" max="127" value="60">
    </section>
    <section class="form-group" id="assignment-midi-velocity-group">
      <label for="assignment-midi-velocity">Velocity (0-127)</label>
      <input id="assignment-midi-velocity" type="number" min="0" max="127" value="96">
    </section>
    <section class="form-group" id="assignment-midi-cc-group">
      <label for="assignment-midi-cc">CC Number</label>
      <input id="assignment-midi-cc" type="number" min="0" max="127" value="1">
    </section>
    <section class="form-group" id="assignment-midi-cc-value-group">
      <label for="assignment-midi-cc-value">CC Value</label>
      <input id="assignment-midi-cc-value" type="number" min="0" max="127" value="100">
    </section>
    <section class="form-group">
      <label for="assignment-osc-address">OSC Address</label>
      <input id="assignment-osc-address" type="text" placeholder="/instrument/parameter">
    </section>
    <section class="form-group">
      <label>OSC Destination</label>
      <div class="dual-input-row">
        <input id="assignment-osc-host" type="text" placeholder="127.0.0.1">
        <input id="assignment-osc-port" type="number" min="1" max="65535" placeholder="9000">
      </div>
    </section>
    <section class="form-group">
      <label for="assignment-osc-args">OSC Arguments</label>
      <input id="assignment-osc-args" type="text" placeholder="comma separated values">
    </section>
    <div class="modal-actions">
      <button id="assignment-modal-cancel" class="secondary" type="button">Cancel</button>
      <button id="assignment-modal-apply" type="button">Apply</button>
    </div>
  </div>

  <script type="module">
const SAMPLE_VIDEO_URL = "https://thefoxofsky.github.io/project_pages/RealisDance-DiT/video/mv/2.mp4";
// const SAMPLE_VIDEO_URL = "https://thefoxofsky.github.io/project_pages/RealisDance-DiT/video/v/0003.mp4";
// const SAMPLE_VIDEO_URL = "https://thefoxofsky.github.io/project_pages/RealisDance-DiT/video/mv/4.mp4";
// const SAMPLE_VIDEO_URL= "https://media.gettyimages.com/id/1432864804/video/a-man-and-a-woman-dance-outdoors-in-preparation-for-a-performance-healthy-lifestyle.mp4?s=mp4-640x640-gi&k=20&c=QenL_gqhEWh665fqtFCuOXsZCdf-EgTSK2JCf_XnPLM=";
// const SAMPLE_VIDEO_URL = "https://media.gettyimages.com/id/1481811636/video/for-us-dance-is-a-way-of-life.mp4?s=mp4-640x640-gi&k=20&c=-eEh1Svdu4dKJCEXijI7d4WOfGWVtAe9Gv_5mmqJYQA=";

    const videoEl = document.getElementById("mediapiper-video");
    const sketchContainer = document.getElementById("mediapiper-sketch");
    const statusLabel = document.getElementById("mediapiper-status");
    const toggleSourceBtn = document.getElementById("mediapiper-toggle-source");
    const resetBtn = document.getElementById("mediapiper-reset");
    const mirrorCheckbox = document.getElementById("mediapiper-mirror");
    const overlayControls = {
      underlay: {
        main: document.getElementById("overlay-underlay-main"),
        preview: document.getElementById("overlay-underlay-preview")
      },
      pose: {
        main: document.getElementById("overlay-pose-main"),
        preview: document.getElementById("overlay-pose-preview")
      },
      leftHand: {
        main: document.getElementById("overlay-left-hand-main"),
        preview: document.getElementById("overlay-left-hand-preview")
      },
      rightHand: {
        main: document.getElementById("overlay-right-hand-main"),
        preview: document.getElementById("overlay-right-hand-preview")
      },
      face: {
        main: document.getElementById("overlay-face-main"),
        preview: document.getElementById("overlay-face-preview")
      },
      segmentation: {
        main: document.getElementById("overlay-segmentation-main"),
        preview: document.getElementById("overlay-segmentation-preview")
      },
      depth: {
        main: document.getElementById("overlay-depth-main"),
        preview: document.getElementById("overlay-depth-preview")
      },
      performance: {
        main: document.getElementById("overlay-performance-main"),
        preview: document.getElementById("overlay-performance-preview")
      },
      score: {
        main: document.getElementById("overlay-score-main"),
        preview: document.getElementById("overlay-score-preview")
      }
    };
const panelEl = document.getElementById("mediapiper-panel");
const panelToggleBtn = document.getElementById("panel-toggle");
const panelCloseBtn = document.getElementById("panel-close");
const panelBackdrop = document.getElementById("panel-backdrop");
const panelToggleIcon = panelToggleBtn?.querySelector(".material-icons-outlined");
const panelTitleEl = panelEl?.querySelector(".panel-header h2");
const panelTabs = Array.from(document.querySelectorAll("[data-panel-tab]"));
const panelSections = Array.from(document.querySelectorAll("[data-panel-section]"));
const editorToggleBtn = document.getElementById("editor-toggle");
const previewCanvas = document.getElementById("segmentation-preview");
const previewCtx = previewCanvas.getContext("2d", { willReadFrequently: true }) || previewCanvas.getContext("2d");
const previewSection = document.querySelector(".segment-preview");
const gestureEditorEl = document.getElementById("gesture-editor");
const gestureToolbar = document.getElementById("gesture-toolbar");
const gestureSvg = document.getElementById("gesture-svg");
const gestureSvgWrapper = document.querySelector(".gesture-svg-wrapper");
const gestureToolButtons = {
  select: document.getElementById("gesture-tool-select"),
  eraser: document.getElementById("gesture-tool-eraser"),
  rect: document.getElementById("gesture-tool-rect"),
  ellipse: document.getElementById("gesture-tool-ellipse"),
  line: document.getElementById("gesture-tool-line"),
  polygon: document.getElementById("gesture-tool-polygon")
};
const gestureModeToggle = document.getElementById("gesture-mode-toggle");
const gestureClearBtn = document.getElementById("gesture-clear");
const assignmentModal = document.getElementById("assignment-modal");
const assignmentBackdrop = document.getElementById("assignment-backdrop");
const assignmentCloseBtn = document.getElementById("assignment-modal-close");
const assignmentCancelBtn = document.getElementById("assignment-modal-cancel");
const assignmentApplyBtn = document.getElementById("assignment-modal-apply");
const assignmentStreamSelect = document.getElementById("assignment-stream");
const assignmentLandmarkSelect = document.getElementById("assignment-landmark");
const assignmentTriggerSelect = document.getElementById("assignment-trigger");
const assignmentMidiTypeSelect = document.getElementById("assignment-midi-type");
const assignmentMidiPortSelect = document.getElementById("assignment-midi-port");
const assignmentMidiPortRefreshBtn = document.getElementById("assignment-midi-port-refresh");
const assignmentMidiChannelInput = document.getElementById("assignment-midi-channel");
const assignmentMidiNoteInput = document.getElementById("assignment-midi-note");
const assignmentMidiVelocityInput = document.getElementById("assignment-midi-velocity");
const assignmentMidiCcInput = document.getElementById("assignment-midi-cc");
const assignmentMidiCcValueInput = document.getElementById("assignment-midi-cc-value");
const assignmentOscAddressInput = document.getElementById("assignment-osc-address");
const assignmentOscHostInput = document.getElementById("assignment-osc-host");
const assignmentOscPortInput = document.getElementById("assignment-osc-port");
const assignmentOscArgsInput = document.getElementById("assignment-osc-args");
const midiNoteGroup = document.getElementById("assignment-midi-note-group");
const midiVelocityGroup = document.getElementById("assignment-midi-velocity-group");
const midiCcGroup = document.getElementById("assignment-midi-cc-group");
const midiCcValueGroup = document.getElementById("assignment-midi-cc-value-group");
const midiChannelGroup = document.getElementById("assignment-midi-channel-group");
const editorShapeList = document.getElementById("editor-shape-list");
const editorDetailEl = document.getElementById("editor-detail");
const editorDetailEmpty = document.getElementById("editor-detail-empty");
const editorDetailForm = document.getElementById("editor-detail-form");
const editorStreamSelect = document.getElementById("editor-stream-select");
const editorLandmarkSelect = document.getElementById("editor-landmark-select");
const editorTriggerSelect = document.getElementById("editor-trigger-select");
const editorMidiTypeSelect = document.getElementById("editor-midi-type");
const editorMidiPortSelect = document.getElementById("editor-midi-port");
const editorMidiPortRefreshBtn = document.getElementById("editor-midi-port-refresh");
const editorMidiChannelInput = document.getElementById("editor-midi-channel");
const editorMidiNoteInput = document.getElementById("editor-midi-note");
const editorMidiVelocityInput = document.getElementById("editor-midi-velocity");
const editorMidiCcInput = document.getElementById("editor-midi-cc");
const editorMidiCcValueInput = document.getElementById("editor-midi-cc-value");
const editorOscAddressInput = document.getElementById("editor-osc-address");
const editorOscArgsInput = document.getElementById("editor-osc-args");
const editorOscHostInput = document.getElementById("editor-osc-host");
const editorOscPortInput = document.getElementById("editor-osc-port");
const editorDeleteShapeBtn = document.getElementById("editor-delete-shape");
const editorOpenModalBtn = document.getElementById("editor-open-modal");
const editorMidiChannelGroup = document.getElementById("editor-midi-channel-group");
const editorMidiNoteGroup = document.getElementById("editor-midi-note-group");
const editorMidiVelocityGroup = document.getElementById("editor-midi-velocity-group");
const editorMidiCcGroup = document.getElementById("editor-midi-cc-group");
const editorMidiCcValueGroup = document.getElementById("editor-midi-cc-value-group");
const editorFormInputs = [
  editorStreamSelect,
  editorLandmarkSelect,
  editorTriggerSelect,
  editorMidiTypeSelect,
  editorMidiChannelInput,
  editorMidiNoteInput,
  editorMidiVelocityInput,
  editorMidiCcInput,
  editorMidiCcValueInput,
  editorOscAddressInput,
  editorOscArgsInput
].filter(Boolean);
const modalMidiContext = {
  channelGroup: midiChannelGroup,
  noteGroup: midiNoteGroup,
  velocityGroup: midiVelocityGroup,
  ccGroup: midiCcGroup,
  ccValueGroup: midiCcValueGroup
};
const editorMidiContext = {
  channelGroup: editorMidiChannelGroup,
  noteGroup: editorMidiNoteGroup,
  velocityGroup: editorMidiVelocityGroup,
  ccGroup: editorMidiCcGroup,
  ccValueGroup: editorMidiCcValueGroup
};

const SEGMENTATION_COLOR = { r: 15, g: 139, b: 168 };
const SEGMENTATION_ALPHA = 0.6;
const MIN_POLYLINE_SEGMENT = 0.01;

const segmentationTintCanvas = document.createElement("canvas");
const segmentationTintCtx = segmentationTintCanvas.getContext("2d", { willReadFrequently: true }) || segmentationTintCanvas.getContext("2d");

const waitForVideoReady = (video) => {
  if (video.readyState >= 2) {
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    const handleReady = () => {
      cleanup();
      resolve();
    };
    const handleError = (event) => {
      cleanup();
      reject(new Error(event?.message || "Video failed to load"));
    };
    const cleanup = () => {
      video.removeEventListener("loadeddata", handleReady);
      video.removeEventListener("loadedmetadata", handleReady);
      video.removeEventListener("error", handleError);
    };
    video.addEventListener("loadeddata", handleReady, { once: true });
    video.addEventListener("loadedmetadata", handleReady, { once: true });
    video.addEventListener("error", handleError, { once: true });
  });
};

const SAFE_POSE_CONNECTIONS = typeof POSE_CONNECTIONS !== "undefined"
  ? POSE_CONNECTIONS
  : [
      [11, 13], [13, 15], [12, 14], [14, 16],
      [11, 12], [23, 24], [11, 23], [12, 24],
      [23, 25], [25, 27], [24, 26], [26, 28],
      [27, 29], [28, 30]
    ];

const SAFE_HAND_CONNECTIONS = typeof HAND_CONNECTIONS !== "undefined"
  ? HAND_CONNECTIONS
  : [
      [0, 1], [1, 2], [2, 3], [3, 4],
      [0, 5], [5, 6], [6, 7], [7, 8],
      [5, 9], [9, 10], [10, 11], [11, 12],
      [9, 13], [13, 14], [14, 15], [15, 16],
      [13, 17], [17, 18], [18, 19], [19, 20],
      [0, 17]
    ];

const SAFE_FACEMESH_TESSELATION = typeof FACEMESH_TESSELATION !== "undefined"
  ? FACEMESH_TESSELATION
  : [];

    videoEl.muted = true;
    videoEl.loop = true;
    videoEl.crossOrigin = "anonymous";
    videoEl.setAttribute("playsinline", "");
    videoEl.setAttribute("webkit-playsinline", "");

    let holistic = null;

    let currentSource = "camera";
    let cameraStream = null;
    let cameraFrameHandle = null;
    let sampleHandle = null;
    let latestResults = null;
    let holisticBusy = false;
    let isPanelOpen = panelEl?.classList.contains("is-open");
let segmentationBuffer = null;
let segmentationMaskAvailable = false;

const DEFAULT_OVERLAY_STATE = {
  mirror: true,
  underlay: { main: true, preview: false },
  pose: { main: true, preview: false },
  leftHand: { main: true, preview: false },
  rightHand: { main: true, preview: false },
  face: { main: true, preview: false },
  segmentation: { main: false, preview: true },
  depth: { main: false, preview: true },
  performance: { main: false, preview: true },
  score: { main: true, preview: true }
};

const overlayState = {
  mirror: mirrorCheckbox?.checked ?? DEFAULT_OVERLAY_STATE.mirror
};
for (const [key, defaults] of Object.entries(DEFAULT_OVERLAY_STATE)) {
  if (key === "mirror") continue;
  overlayState[key] = { main: defaults.main, preview: defaults.preview };
}

const isScoreMainEnabled = () => overlayState.score?.main !== false;
const isScorePreviewEnabled = () => overlayState.score?.preview ?? false;

const CONFIG_STORAGE_KEY = "mediapipa:config";
const DEFAULT_EDITOR_CONFIG = {
  midiPort: "broadcast",
  oscHost: "127.0.0.1",
  oscPort: 9000
};
const editorConfig = { ...DEFAULT_EDITOR_CONFIG };
let isSyncingConfig = false;

const ACTIVE_STROKE_COLOR = "#f97316";
const ACTIVE_FILL_COLOR = "rgba(249, 115, 22, 0.32)";
const ACTIVE_PREVIEW_STROKE_COLOR = "rgba(249, 115, 22, 0.88)";
const ACTIVE_PREVIEW_FILL_COLOR = "rgba(249, 115, 22, 0.24)";

const loadEditorConfig = () => {
  if (typeof localStorage === "undefined") {
    return;
  }
  try {
    const raw = localStorage.getItem(CONFIG_STORAGE_KEY);
    if (!raw) return;
    const stored = JSON.parse(raw);
    if (!stored || typeof stored !== "object") return;
    if (stored.midiPort) editorConfig.midiPort = String(stored.midiPort);
    if (stored.oscHost) editorConfig.oscHost = String(stored.oscHost);
    if (stored.oscPort) {
      const parsed = clampRange(parseInt(stored.oscPort, 10) || DEFAULT_EDITOR_CONFIG.oscPort, 1, 65535);
      editorConfig.oscPort = parsed;
    }
  } catch (err) {
    console.warn("Failed to load editor config", err);
  }
};

const saveEditorConfig = () => {
  if (typeof localStorage === "undefined") {
    return;
  }
  try {
    localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(editorConfig));
  } catch (err) {
    console.warn("Failed to save editor config", err);
  }
};

const updateEditorConfig = (changes = {}) => {
  Object.assign(editorConfig, changes);
  saveEditorConfig();
  applyGlobalConnectionConfig();
};

const applyScoreVisibility = () => {
  const visible = isScoreMainEnabled();
  if (gestureSvg) {
    gestureSvg.style.visibility = visible ? "visible" : "hidden";
    gestureSvg.style.pointerEvents = visible ? "auto" : "none";
  }
};

const performanceMetrics = {
  fps: 0,
  frameMs: 0,
  inferenceMs: 0,
  source: "camera"
};

let lastFrameTimestamp = performance.now();
let smoothedFps = 0;
let smoothedFrameMs = 0;
let smoothedInferenceMs = 0;

const resetPerformanceMetrics = () => {
  performanceMetrics.fps = 0;
  performanceMetrics.frameMs = 0;
  performanceMetrics.inferenceMs = 0;
  performanceMetrics.source = currentSource;
  smoothedFps = 0;
  smoothedFrameMs = 0;
  smoothedInferenceMs = 0;
  lastFrameTimestamp = performance.now();
  drawPreviewCanvas();
};

const recordInferenceTime = (ms) => {
  if (!Number.isFinite(ms) || ms <= 0) return;
  smoothedInferenceMs = smoothedInferenceMs ? (smoothedInferenceMs * 0.8 + ms * 0.2) : ms;
  performanceMetrics.inferenceMs = smoothedInferenceMs;
};

const updateOverlayState = () => {
  for (const [key, controls] of Object.entries(overlayControls)) {
    if (!overlayState[key]) {
      overlayState[key] = { main: false, preview: false };
    }
    overlayState[key].main = controls.main?.checked ?? false;
    overlayState[key].preview = controls.preview?.checked ?? false;
  }
  overlayState.mirror = mirrorCheckbox?.checked ?? DEFAULT_OVERLAY_STATE.mirror;
  if (previewSection) {
    const previewVisible = Object.keys(overlayControls).some((key) => overlayState[key]?.preview);
    previewSection.style.display = previewVisible ? "" : "none";
    previewSection.setAttribute("aria-hidden", previewVisible ? "false" : "true");
  }
  setEditorMirrorActive(overlayState.mirror && currentSource === "camera");
  applyScoreVisibility();
  renderEditor();
  drawPreviewCanvas();
};

const setPanelState = (open, { skipFocus = false } = {}) => {
  if (!panelEl || !panelToggleBtn || !panelBackdrop) {
    return;
  }
  isPanelOpen = open;
  panelEl.classList.toggle("is-open", open);
  panelBackdrop.classList.toggle("is-visible", open);
  panelEl.setAttribute("aria-hidden", open ? "false" : "true");
  panelToggleBtn.setAttribute("aria-expanded", open ? "true" : "false");
  panelToggleBtn.setAttribute("title", open ? "Hide control panel" : "Show control panel");
  panelToggleBtn.setAttribute("aria-label", open ? "Hide control panel" : "Show control panel");
  panelToggleBtn.classList.toggle("panel-toggle-open", open);
  if (panelToggleIcon) {
    panelToggleIcon.textContent = open ? "close" : "tune";
  }
  if (panelCloseBtn) {
    panelCloseBtn.setAttribute("title", "Hide control panel");
    panelCloseBtn.setAttribute("aria-label", "Hide control panel");
  }
  if (open) {
    try {
      panelEl.focus({ preventScroll: true });
    } catch (err) {
      panelEl.focus();
    }
  } else if (!skipFocus) {
    try {
      panelToggleBtn.focus({ preventScroll: true });
    } catch (err) {
      panelToggleBtn.focus();
    }
  }
};

const openPanel = (options) => setPanelState(true, options);
const closePanel = (options) => setPanelState(false, options);
const togglePanel = () => setPanelState(!isPanelOpen);

const waitForHolisticIdle = async () => {
  while (holisticBusy) {
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
};

const resetHolistic = async () => {
  await waitForHolisticIdle();
  if (holistic && typeof holistic.close === "function") {
    try {
      await holistic.close();
    } catch (err) {
      console.warn("Holistic close failed", err);
    }
  }
  holisticBusy = false;
  holistic = createHolistic();
};
    setPanelState(Boolean(isPanelOpen), { skipFocus: true });

    const overlayInputs = Object.values(overlayControls)
      .flatMap((controls) => [controls.main, controls.preview])
      .filter(Boolean);

    overlayInputs.forEach((input) => {
      input.addEventListener("change", updateOverlayState);
    });

    if (mirrorCheckbox) {
      mirrorCheckbox.addEventListener("change", updateOverlayState);
    }

    if (panelToggleBtn) {
      panelToggleBtn.addEventListener("click", () => {
        togglePanel();
      });
    }
    if (panelCloseBtn) {
      panelCloseBtn.addEventListener("click", () => {
        closePanel();
      });
    }
    // Backdrop is visual only; closing is manual via toggle or close button.
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && !event.defaultPrevented && isPanelOpen) {
        closePanel({ skipFocus: true });
      }
    });

    const applyStatus = (text) => {
      statusLabel.textContent = text;
    };

    const segmentationOffscreen = document.createElement("canvas");
    const segmentationOffCtx = segmentationOffscreen.getContext("2d", { willReadFrequently: true }) || segmentationOffscreen.getContext("2d");

function clearPreviewCanvas() {
  if (!previewCtx) return;
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
}

function drawPreviewCanvas() {
  if (!previewCtx || !previewCanvas) {
    return;
  }
  const previewActive = Object.keys(overlayControls).some((key) => overlayState[key]?.preview);
  if (!previewActive) {
    clearPreviewCanvas();
    return;
  }
  clearPreviewCanvas();

  const ctx = previewCtx;
  const width = previewCanvas.width;
  const height = previewCanvas.height;

  ctx.save();
  ctx.fillStyle = "#050912";
  ctx.fillRect(0, 0, width, height);

  const shouldMirror = overlayState.mirror && currentSource === "camera";
  if (shouldMirror) {
    ctx.translate(width, 0);
    ctx.scale(-1, 1);
  }

  if (overlayState.underlay?.preview && videoEl.readyState >= 2) {
    ctx.globalAlpha = 1;
    ctx.drawImage(videoEl, 0, 0, width, height);
  }

  if (overlayState.segmentation?.preview && segmentationMaskAvailable && segmentationTintCanvas.width) {
    ctx.globalAlpha = 1;
    ctx.drawImage(segmentationTintCanvas, 0, 0, width, height);
  }

  if (latestResults) {
    const { poseLandmarks, leftHandLandmarks, rightHandLandmarks, faceLandmarks } = latestResults;

    const drawConnectorSet = (landmarks, connections, color, lineWidth) => {
      if (!landmarks) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.globalAlpha = 0.9;
      for (let i = 0; i < connections.length; i++) {
        const [startIndex, endIndex] = connections[i];
        const start = landmarks[startIndex];
        const end = landmarks[endIndex];
        if (!start || !end) continue;
        ctx.beginPath();
        ctx.moveTo(start.x * width, start.y * height);
        ctx.lineTo(end.x * width, end.y * height);
        ctx.stroke();
      }
      ctx.restore();
    };

    const drawLandmarkDots = (landmarks, color, size) => {
      if (!landmarks) return;
      ctx.save();
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.9;
      for (const lm of landmarks) {
        ctx.beginPath();
        ctx.arc(lm.x * width, lm.y * height, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    };

    if (overlayState.pose?.preview && poseLandmarks) {
      drawConnectorSet(poseLandmarks, SAFE_POSE_CONNECTIONS, "rgba(76, 201, 240, 0.9)", Math.max(1.4, width * 0.0035));
      drawLandmarkDots(poseLandmarks, "rgba(76, 201, 240, 0.7)", Math.max(2.4, width * 0.01));
    }
    if (overlayState.leftHand?.preview && leftHandLandmarks) {
      drawConnectorSet(leftHandLandmarks, SAFE_HAND_CONNECTIONS, "rgba(255, 112, 150, 0.95)", Math.max(1.2, width * 0.003));
      drawLandmarkDots(leftHandLandmarks, "rgba(255, 112, 150, 0.9)", Math.max(2.2, width * 0.009));
    }
    if (overlayState.rightHand?.preview && rightHandLandmarks) {
      drawConnectorSet(rightHandLandmarks, SAFE_HAND_CONNECTIONS, "rgba(255, 143, 163, 0.95)", Math.max(1.2, width * 0.003));
      drawLandmarkDots(rightHandLandmarks, "rgba(255, 143, 163, 0.9)", Math.max(2.2, width * 0.009));
    }
    if (overlayState.face?.preview && faceLandmarks) {
      ctx.save();
      ctx.strokeStyle = "rgba(249, 199, 79, 0.85)";
      ctx.lineWidth = Math.max(0.8, width * 0.0025);
      ctx.globalAlpha = 0.85;
      if (SAFE_FACEMESH_TESSELATION.length) {
        ctx.beginPath();
        for (let i = 0; i < SAFE_FACEMESH_TESSELATION.length; i++) {
          const [startIndex, endIndex] = SAFE_FACEMESH_TESSELATION[i];
          const start = faceLandmarks[startIndex];
          const end = faceLandmarks[endIndex];
          if (!start || !end) continue;
          ctx.moveTo(start.x * width, start.y * height);
          ctx.lineTo(end.x * width, end.y * height);
        }
        ctx.stroke();
      } else {
        ctx.fillStyle = "rgba(249, 199, 79, 0.75)";
        for (const lm of faceLandmarks) {
          ctx.beginPath();
          ctx.arc(lm.x * width, lm.y * height, Math.max(1.5, width * 0.004), 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.restore();
    }
    if (overlayState.depth?.preview && poseLandmarks) {
      ctx.save();
      ctx.globalAlpha = 0.6;
      for (const lm of poseLandmarks) {
        const { color, size } = depthStyle(lm.z ?? 0);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(lm.x * width, lm.y * height, Math.max(size * 0.08, 2.4), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  drawScorePreview(ctx, width, height);

  ctx.restore();

  if (overlayState.performance?.preview) {
    const fpsText = Number.isFinite(performanceMetrics.fps) && performanceMetrics.fps > 0
      ? performanceMetrics.fps.toFixed(1)
      : "--";
    const frameText = Number.isFinite(performanceMetrics.frameMs) && performanceMetrics.frameMs > 0
      ? performanceMetrics.frameMs.toFixed(1)
      : "--";
    const inferenceText = Number.isFinite(performanceMetrics.inferenceMs) && performanceMetrics.inferenceMs > 0
      ? performanceMetrics.inferenceMs.toFixed(1)
      : "--";
    const lines = [
      `FPS: ${fpsText}`,
      `Frame: ${frameText} ms`,
      `Inference: ${inferenceText} ms`,
      `Source: ${performanceMetrics.source}`
    ];
    const padding = 8;
    const lineHeight = 16;
    const boxWidth = width - padding * 2;
    const boxHeight = padding * 2 + lines.length * lineHeight;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(9, 13, 22, 0.86)";
    ctx.fillRect(padding, padding, boxWidth, boxHeight);
    ctx.fillStyle = "rgba(245, 247, 255, 0.92)";
    ctx.font = "12px 'Inter', 'Helvetica Neue', Arial, sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
    lines.forEach((line, index) => {
      ctx.fillText(line, padding + 10, padding + 6 + index * lineHeight);
    });
    ctx.restore();
  }
}

const resetSegmentationData = () => {
  segmentationBuffer = null;
  segmentationMaskAvailable = false;
  segmentationTintCanvas.width = 0;
  segmentationTintCanvas.height = 0;
  latestResults = null;
  clearPreviewCanvas();
  drawPreviewCanvas();
};

const CAMERA_CONSTRAINTS = {
  video: {
    width: { ideal: 1280 },
    height: { ideal: 720 },
    aspectRatio: { ideal: 16 / 9 },
    facingMode: "user"
  },
  audio: false
};

const cancelCameraLoop = () => {
  if (cameraFrameHandle) {
    cancelAnimationFrame(cameraFrameHandle);
    cameraFrameHandle = null;
  }
};

const ensureCameraStream = async () => {
  if (cameraStream) {
    const liveTrack = cameraStream.getVideoTracks().find((track) => track.readyState === "live");
    if (liveTrack) {
      return cameraStream;
    }
  }
  cameraStream = await navigator.mediaDevices.getUserMedia(CAMERA_CONSTRAINTS);
  return cameraStream;
};

const startCameraLoop = () => {
  cancelCameraLoop();
  const loop = async () => {
    if (currentSource !== "camera") {
      cameraFrameHandle = requestAnimationFrame(loop);
      return;
    }
    if (!videoEl.videoWidth || !videoEl.videoHeight) {
      cameraFrameHandle = requestAnimationFrame(loop);
      return;
    }
    if (!holisticBusy) {
      holisticBusy = true;
      try {
        const inferenceStart = performance.now();
        await holistic.send({ image: videoEl });
        recordInferenceTime(performance.now() - inferenceStart);
      } catch (err) {
        console.warn("Holistic send failed on camera frame", err);
      } finally {
        holisticBusy = false;
      }
    }
    cameraFrameHandle = requestAnimationFrame(loop);
  };
  cameraFrameHandle = requestAnimationFrame(loop);
};

const pauseCameraStream = () => {
  cancelCameraLoop();
  if (cameraStream) {
    cameraStream.getVideoTracks().forEach((track) => {
      track.enabled = false;
    });
  }
  if (videoEl.srcObject === cameraStream) {
    videoEl.pause();
    videoEl.srcObject = null;
  }
};

function refreshSegmentationTint() {
  if (!segmentationBuffer) {
    segmentationTintCanvas.width = 0;
    segmentationTintCanvas.height = 0;
    segmentationMaskAvailable = false;
    clearPreviewCanvas();
    return;
  }
  const width = segmentationBuffer.width || segmentationOffscreen.width;
  const height = segmentationBuffer.height || segmentationOffscreen.height;
  segmentationTintCanvas.width = width;
  segmentationTintCanvas.height = height;
  const tinted = segmentationTintCtx.createImageData(width, height);
  const src = segmentationBuffer.data;
  const dst = tinted.data;
  const len = width * height;
  for (let i = 0; i < len; i++) {
    const alpha = src[i * 4] / 255;
    dst[i * 4] = SEGMENTATION_COLOR.r;
    dst[i * 4 + 1] = SEGMENTATION_COLOR.g;
    dst[i * 4 + 2] = SEGMENTATION_COLOR.b;
    dst[i * 4 + 3] = Math.round(alpha * SEGMENTATION_ALPHA * 255);
  }
  segmentationTintCtx.putImageData(tinted, 0, 0);
  segmentationMaskAvailable = true;
  drawPreviewCanvas();
}

const handleHolisticResults = (results) => {
  latestResults = results;
  if (results.segmentationMask) {
    segmentationOffscreen.width = results.segmentationMask.width || videoEl.videoWidth || 640;
    segmentationOffscreen.height = results.segmentationMask.height || videoEl.videoHeight || 480;
    segmentationOffCtx.globalCompositeOperation = "copy";
    segmentationOffCtx.drawImage(results.segmentationMask, 0, 0, segmentationOffscreen.width, segmentationOffscreen.height);
    segmentationBuffer = segmentationOffCtx.getImageData(0, 0, segmentationOffscreen.width, segmentationOffscreen.height);
    refreshSegmentationTint();
  } else {
    segmentationBuffer = null;
    refreshSegmentationTint();
  }
  evaluateShapeInteractions(results);
};

const createHolistic = () => {
  const instance = new Holistic({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
  });
  instance.setOptions({
    modelComplexity: 1,
    smoothLandmarks: true,
    enableSegmentation: true,
    refineFaceLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  instance.onResults(handleHolisticResults);
  return instance;
};

holistic = createHolistic();

    async function startCamera() {
      stopSampleVideo();
      const stream = await ensureCameraStream();
      stream.getVideoTracks().forEach((track) => {
        track.enabled = true;
      });
      if (videoEl.srcObject !== stream) {
        videoEl.pause();
        videoEl.srcObject = stream;
        videoEl.removeAttribute("src");
      }
      if (videoEl.readyState < 2) {
        await new Promise((resolve) => {
          const handleLoaded = () => {
            videoEl.removeEventListener("loadedmetadata", handleLoaded);
            resolve();
          };
          videoEl.addEventListener("loadedmetadata", handleLoaded, { once: true });
        });
      }
      await videoEl.play();
      await resetHolistic();
      resetSegmentationData();
      currentSource = "camera";
      resetPerformanceMetrics();
      startCameraLoop();
      applyStatus("Live camera ready");
      updateOverlayState();
    }

    async function startSampleVideo() {
      pauseCameraStream();
      if (sampleHandle) {
        cancelAnimationFrame(sampleHandle);
        sampleHandle = null;
      }
      await resetHolistic();
      resetSegmentationData();
      videoEl.srcObject = null;
      videoEl.src = SAMPLE_VIDEO_URL;
      try {
        await waitForVideoReady(videoEl);
      } catch (err) {
        console.error("Sample video failed to load", err);
        applyStatus("Sample video load failed");
        return;
      }
      await videoEl.play();
      applyStatus("Using sample video");
      currentSource = "sample";
      resetPerformanceMetrics();

      const loop = async () => {
        if (currentSource !== "sample") {
          return;
        }
        if (videoEl.ended) {
          videoEl.currentTime = 0;
          await videoEl.play();
        }
        if (currentSource === "sample" && !videoEl.paused && videoEl.readyState >= 2) {
          if (!holisticBusy) {
            holisticBusy = true;
            try {
              const inferenceStart = performance.now();
              await holistic.send({ image: videoEl });
              recordInferenceTime(performance.now() - inferenceStart);
            } catch (err) {
              console.warn("Holistic send failed on sample frame", err);
            } finally {
              holisticBusy = false;
            }
          }
        }
        if (currentSource === "sample") {
          sampleHandle = requestAnimationFrame(loop);
        }
      };
      sampleHandle = requestAnimationFrame(loop);
      updateOverlayState();
    }

    function stopCamera() {
      cancelCameraLoop();
      if (cameraStream) {
        cameraStream.getTracks().forEach((track) => track.stop());
        cameraStream = null;
      }
      if (videoEl.srcObject) {
        videoEl.pause();
        videoEl.srcObject = null;
      }
      if (currentSource === "camera") {
        currentSource = "none";
      }
      resetSegmentationData();
      updateOverlayState();
    }

    function stopSampleVideo() {
      if (currentSource === "sample") {
        currentSource = "none";
      }
      resetSegmentationData();
      if (sampleHandle) {
        cancelAnimationFrame(sampleHandle);
        sampleHandle = null;
      }
      if (!videoEl.paused && !videoEl.srcObject) {
        videoEl.pause();
      }
      if (!videoEl.srcObject && videoEl.src) {
        videoEl.removeAttribute("src");
        videoEl.load();
      }
      updateOverlayState();
    }

    toggleSourceBtn.addEventListener("click", async () => {
      toggleSourceBtn.disabled = true;
      try {
        if (currentSource === "camera") {
          applyStatus("Loading sample video…");
          await startSampleVideo();
        } else {
          applyStatus("Requesting camera…");
          await startCamera();
        }
      } catch (err) {
        console.error("Source switch error", err);
        applyStatus("Source switch failed");
      } finally {
        toggleSourceBtn.disabled = false;
      }
    });

    resetBtn.addEventListener("click", () => {
      for (const [key, controls] of Object.entries(overlayControls)) {
        const defaults = DEFAULT_OVERLAY_STATE[key];
        if (!defaults) continue;
        if (controls.main) {
          controls.main.checked = defaults.main;
        }
        if (controls.preview) {
          controls.preview.checked = defaults.preview;
        }
      }
      if (mirrorCheckbox) {
        if (currentSource === "camera") {
          mirrorCheckbox.checked = true;
        } else {
          mirrorCheckbox.checked = DEFAULT_OVERLAY_STATE.mirror;
        }
      }
      updateOverlayState();
    });

    window.addEventListener("beforeunload", () => {
      stopSampleVideo();
      stopCamera();
    });

    let p5Instance = null;

    const DEFAULT_WIDTH = 1280;
    const DEFAULT_HEIGHT = 720;

    let canvasWidth = DEFAULT_WIDTH;
    let canvasHeight = DEFAULT_HEIGHT;
    const editorState = {
      mode: "edit",
      tool: "select",
      shapes: [],
      selectedId: null,
      drawingShapeId: null,
      dragHandle: null,
      pointerId: null,
      pointerOrigin: null,
      initialRect: null,
      initialVertices: null,
      viewport: { width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT },
      mirror: false,
      isVisible: true,
      didMutate: false,
      activePolylineId: null,
      polylineHoverPoint: null,
      eraserActive: false,
      eraserPointerId: null,
      erasedShapeIds: new Set()
    };
    const isPolylineTool = (tool) => tool === "line" || tool === "polygon";
    const STORAGE_KEY = "mediapipa:gesture-shapes";
    let persistTimer = null;
    let activePanelTab = panelTabs.find((button) => button.classList.contains("is-active"))?.dataset?.panelTab || "streams";
    let activeAssignmentShapeId = null;
    const CONTINUOUS_TRIGGER_INTERVAL_MS = 220;
    let editorSidebarDirty = true;
    let isSyncingEditorForm = false;

    const SHAPE_MIN_SIZE = 0.015;
    const DEFAULT_SHAPE_STYLE = {
      stroke: "rgba(82, 213, 255, 0.88)",
      fill: "rgba(82, 213, 255, 0.14)",
      strokeWidth: 2
    };
    const POSE_LANDMARKS_LIST = [
      { key: "nose", label: "Nose", index: 0 },
      { key: "left_eye_inner", label: "Left eye (inner)", index: 1 },
      { key: "left_eye", label: "Left eye", index: 2 },
      { key: "left_eye_outer", label: "Left eye (outer)", index: 3 },
      { key: "right_eye_inner", label: "Right eye (inner)", index: 4 },
      { key: "right_eye", label: "Right eye", index: 5 },
      { key: "right_eye_outer", label: "Right eye (outer)", index: 6 },
      { key: "left_ear", label: "Left ear", index: 7 },
      { key: "right_ear", label: "Right ear", index: 8 },
      { key: "mouth_left", label: "Mouth left", index: 9 },
      { key: "mouth_right", label: "Mouth right", index: 10 },
      { key: "left_shoulder", label: "Left shoulder", index: 11 },
      { key: "right_shoulder", label: "Right shoulder", index: 12 },
      { key: "left_elbow", label: "Left elbow", index: 13 },
      { key: "right_elbow", label: "Right elbow", index: 14 },
      { key: "left_wrist", label: "Left wrist", index: 15 },
      { key: "right_wrist", label: "Right wrist", index: 16 },
      { key: "left_pinky", label: "Left pinky", index: 17 },
      { key: "right_pinky", label: "Right pinky", index: 18 },
      { key: "left_index", label: "Left index", index: 19 },
      { key: "right_index", label: "Right index", index: 20 },
      { key: "left_thumb", label: "Left thumb", index: 21 },
      { key: "right_thumb", label: "Right thumb", index: 22 },
      { key: "left_hip", label: "Left hip", index: 23 },
      { key: "right_hip", label: "Right hip", index: 24 },
      { key: "left_knee", label: "Left knee", index: 25 },
      { key: "right_knee", label: "Right knee", index: 26 },
      { key: "left_ankle", label: "Left ankle", index: 27 },
      { key: "right_ankle", label: "Right ankle", index: 28 },
      { key: "left_heel", label: "Left heel", index: 29 },
      { key: "right_heel", label: "Right heel", index: 30 },
      { key: "left_foot_index", label: "Left foot index", index: 31 },
      { key: "right_foot_index", label: "Right foot index", index: 32 }
    ];
    const HAND_LANDMARKS_LIST = [
      { key: "wrist", label: "Wrist", index: 0 },
      { key: "thumb_cmc", label: "Thumb CMC", index: 1 },
      { key: "thumb_mcp", label: "Thumb MCP", index: 2 },
      { key: "thumb_ip", label: "Thumb IP", index: 3 },
      { key: "thumb_tip", label: "Thumb tip", index: 4 },
      { key: "index_mcp", label: "Index MCP", index: 5 },
      { key: "index_pip", label: "Index PIP", index: 6 },
      { key: "index_dip", label: "Index DIP", index: 7 },
      { key: "index_tip", label: "Index tip", index: 8 },
      { key: "middle_mcp", label: "Middle MCP", index: 9 },
      { key: "middle_pip", label: "Middle PIP", index: 10 },
      { key: "middle_dip", label: "Middle DIP", index: 11 },
      { key: "middle_tip", label: "Middle tip", index: 12 },
      { key: "ring_mcp", label: "Ring MCP", index: 13 },
      { key: "ring_pip", label: "Ring PIP", index: 14 },
      { key: "ring_dip", label: "Ring DIP", index: 15 },
      { key: "ring_tip", label: "Ring tip", index: 16 },
      { key: "pinky_mcp", label: "Pinky MCP", index: 17 },
      { key: "pinky_pip", label: "Pinky PIP", index: 18 },
      { key: "pinky_dip", label: "Pinky DIP", index: 19 },
      { key: "pinky_tip", label: "Pinky tip", index: 20 }
    ];
    const FACE_REFERENCE_POINTS = [
      { key: "centroid", label: "Face centroid" },
      { key: "nose_tip", label: "Nose tip", index: 1 }
    ];
    const STREAM_DEFINITIONS = {
      pose: {
        id: "pose",
        label: "Pose Landmarks",
        options: POSE_LANDMARKS_LIST
      },
      leftHand: {
        id: "leftHand",
        label: "Left Hand",
        options: HAND_LANDMARKS_LIST
      },
      rightHand: {
        id: "rightHand",
        label: "Right Hand",
        options: HAND_LANDMARKS_LIST
      },
      face: {
        id: "face",
        label: "Face",
        options: FACE_REFERENCE_POINTS
      }
    };
    const resetShapeRuntime = (shape) => {
      if (!shape) return;
      shape.runtime = { inside: false, lastTriggerAt: 0, noteOn: false, lastContinuousAt: 0 };
    };
    const getStreamDefinition = (streamId) => STREAM_DEFINITIONS[streamId] ?? STREAM_DEFINITIONS.pose;
    const setElementVisibility = (element, visible) => {
      if (!element) return;
      element.style.display = visible ? "" : "none";
    };
    const populateLandmarkOptions = (streamId, selectedKey, selectEl = assignmentLandmarkSelect) => {
      const targetSelect = selectEl || assignmentLandmarkSelect;
      if (!targetSelect) return;
      const definition = getStreamDefinition(streamId);
      targetSelect.innerHTML = "";
      definition.options.forEach((option, index) => {
        const optionEl = document.createElement("option");
        optionEl.value = option.key;
        optionEl.textContent = option.label;
        if (option.key === selectedKey || (!selectedKey && index === 0)) {
          optionEl.selected = true;
        }
        targetSelect.appendChild(optionEl);
      });
      if (!targetSelect.value && definition.options.length) {
        targetSelect.value = definition.options[0].key;
      }
      return targetSelect.value;
    };
    const updateMidiControlsVisibility = (type, context = modalMidiContext) => {
      const {
        channelGroup,
        noteGroup,
        velocityGroup,
        ccGroup,
        ccValueGroup
      } = context || {};
      const showChannel = type === "note" || type === "cc";
      setElementVisibility(channelGroup, showChannel);
      setElementVisibility(noteGroup, type === "note");
      setElementVisibility(velocityGroup, type === "note");
      setElementVisibility(ccGroup, type === "cc");
      setElementVisibility(ccValueGroup, type === "cc");
    };
    const markEditorSidebarDirty = () => {
      editorSidebarDirty = true;
    };
    const setEditorVisibility = (visible) => {
      editorState.isVisible = Boolean(visible);
      if (gestureToolbar) {
        gestureToolbar.style.display = editorState.isVisible ? "" : "none";
        gestureToolbar.style.pointerEvents = editorState.isVisible ? "auto" : "none";
      }
      if (editorToggleBtn) {
        editorToggleBtn.classList.toggle("is-hidden", false);
        editorToggleBtn.setAttribute("aria-pressed", editorState.isVisible ? "true" : "false");
        editorToggleBtn.setAttribute("title", editorState.isVisible ? "Hide tool palette" : "Show tool palette");
        editorToggleBtn.setAttribute("aria-label", editorState.isVisible ? "Hide tool palette" : "Show tool palette");
        const icon = editorToggleBtn.querySelector(".material-icons-outlined");
        if (icon) {
          icon.textContent = editorState.isVisible ? "gesture" : "visibility_off";
        }
      }
    };
    const toggleEditorVisibility = () => {
      setEditorVisibility(!editorState.isVisible);
    };
    const updateEditorShapeList = () => {
      if (!editorShapeList) {
        return;
      }
      if (!editorState.shapes.length) {
        editorShapeList.innerHTML = `<div class="editor-detail-empty">No shapes yet. Draw on the canvas to add one.</div>`;
        editorShapeList.removeAttribute("aria-activedescendant");
        return;
      }
      const activeId = editorState.selectedId;
      const shapeMarkup = editorState.shapes.map((shape, index) => {
        const isActive = shape.id === activeId;
        let typeLabel = "Rect";
        if (shape.type === "ellipse") {
          typeLabel = "Ellipse";
        } else if (shape.type === "polyline") {
          typeLabel = shape.closed ? "Polygon" : "Polyline";
        }
        const streamDefinition = getStreamDefinition(shape.interaction?.stream || "pose");
        const streamLabel = streamDefinition?.label || "Stream";
        const triggerLabel = (shape.interaction?.trigger || "enter").replace(/^\w/, (char) => char.toUpperCase());
        const meta = `${typeLabel} · ${streamLabel} · ${triggerLabel}`;
        const classes = ["editor-shape-item"];
        if (isActive) {
          classes.push("is-active");
        }
        const highlight = shape.runtime?.inside ? " data-active=\"true\"" : "";
        return `<button type="button" id="editor-shape-${shape.id}" class="${classes.join(" ")}"${highlight} data-shape-id="${shape.id}" role="option" aria-selected="${isActive ? "true" : "false"}">
            <span class="shape-label">Shape ${index + 1}</span>
            <span class="shape-meta">${meta}</span>
          </button>`;
      }).join("");
      editorShapeList.innerHTML = shapeMarkup;
      if (activeId) {
        editorShapeList.setAttribute("aria-activedescendant", `editor-shape-${activeId}`);
      } else {
        editorShapeList.removeAttribute("aria-activedescendant");
      }
    };
    const syncEditorDetailForm = () => {
      if (!editorDetailForm) {
        return;
      }
      const shape = findShapeById(editorState.selectedId);
      const hasShape = Boolean(shape);
      setElementVisibility(editorDetailForm, hasShape);
      setElementVisibility(editorDetailEmpty, !hasShape);
      editorFormInputs.forEach((input) => {
        if (input) {
          input.disabled = !hasShape;
        }
      });
      if (editorDeleteShapeBtn) {
        editorDeleteShapeBtn.disabled = !hasShape;
      }
      if (editorOpenModalBtn) {
        editorOpenModalBtn.disabled = !hasShape;
      }
      if (!hasShape) {
        updateMidiControlsVisibility(editorMidiTypeSelect?.value || "none", editorMidiContext);
        populateMidiPortSelect(editorMidiPortSelect, editorConfig.midiPort);
        if (editorOscHostInput) editorOscHostInput.value = editorConfig.oscHost;
        if (editorOscPortInput) editorOscPortInput.value = editorConfig.oscPort;
        return;
      }
      const interaction = mergeInteraction(shape.interaction);
      isSyncingEditorForm = true;
      if (editorStreamSelect) {
        editorStreamSelect.value = interaction.stream;
      }
      const resolvedLandmark = populateLandmarkOptions(interaction.stream, interaction.landmark, editorLandmarkSelect);
      if (editorLandmarkSelect && resolvedLandmark) {
        editorLandmarkSelect.value = resolvedLandmark;
      }
      if (editorTriggerSelect) {
        editorTriggerSelect.value = interaction.trigger;
      }
      if (editorMidiTypeSelect) {
        editorMidiTypeSelect.value = interaction.midi.type;
      }
      populateMidiPortSelect(editorMidiPortSelect, editorConfig.midiPort);
      if (editorMidiPortSelect) editorMidiPortSelect.dataset.selectedPort = editorConfig.midiPort;
      if (editorMidiChannelInput) {
        editorMidiChannelInput.value = interaction.midi.channel;
      }
      if (editorMidiNoteInput) {
        editorMidiNoteInput.value = interaction.midi.note;
      }
      if (editorMidiVelocityInput) {
        editorMidiVelocityInput.value = interaction.midi.velocity;
      }
      if (editorMidiCcInput) {
        editorMidiCcInput.value = interaction.midi.cc;
      }
      if (editorMidiCcValueInput) {
        editorMidiCcValueInput.value = interaction.midi.value;
      }
      if (editorOscAddressInput) {
        editorOscAddressInput.value = interaction.osc.address || "";
      }
      if (editorOscHostInput) {
        editorOscHostInput.value = editorConfig.oscHost;
      }
      if (editorOscPortInput) {
        editorOscPortInput.value = editorConfig.oscPort;
      }
      if (editorOscArgsInput) {
        editorOscArgsInput.value = interaction.osc.args || "";
      }
      updateMidiControlsVisibility(interaction.midi.type, editorMidiContext);
      isSyncingEditorForm = false;
    };
    const updateEditorSidebar = () => {
      if (activePanelTab !== "editor") {
        return;
      }
      updateEditorShapeList();
      syncEditorDetailForm();
      editorSidebarDirty = false;
    };
    const setActivePanelTab = (tabId) => {
      if (!tabId) {
        return;
      }
      activePanelTab = tabId;
      panelTabs.forEach((button) => {
        const matches = button.dataset.panelTab === tabId;
        button.classList.toggle("is-active", matches);
        if (button.getAttribute("role") === "tab") {
          button.setAttribute("aria-selected", matches ? "true" : "false");
          button.setAttribute("tabindex", matches ? "0" : "-1");
        }
      });
      panelSections.forEach((section) => {
        const matches = section.dataset.panelSection === tabId;
        section.classList.toggle("is-active", matches);
        section.setAttribute("aria-hidden", matches ? "false" : "true");
      });
      if (panelTitleEl) {
        panelTitleEl.textContent = tabId === "editor" ? "Editor" : "Streams";
      }
      if (tabId === "editor") {
        markEditorSidebarDirty();
        updateEditorSidebar();
      }
    };
    const mutateSelectedShape = (mutator, { skipRender = false } = {}) => {
      const shape = findShapeById(editorState.selectedId);
      if (!shape) {
        return;
      }
      const previousInteraction = shape.interaction ? { ...shape.interaction } : null;
      mutator(shape);
      if (shape.type === "polyline") {
        shape.vertices = normalizeVertices(shape.vertices);
        updatePolylineBounds(shape);
        ensurePolylineStyle(shape);
      }
      if (previousInteraction !== shape.interaction) {
        shape.interaction = mergeInteraction(shape.interaction);
        if (shape.interaction?.midi) {
          delete shape.interaction.midi.port;
        }
        if (shape.interaction?.osc) {
          delete shape.interaction.osc.host;
          delete shape.interaction.osc.port;
        }
      }
      resetShapeRuntime(shape);
      markEditorSidebarDirty();
      queuePersist();
      if (skipRender) {
        if (activePanelTab === "editor") {
          updateEditorSidebar();
        }
      } else {
        renderEditor();
      }
    };
    const deleteSelectedShape = () => {
      if (!editorState.selectedId) return;
      const index = editorState.shapes.findIndex((shape) => shape.id === editorState.selectedId);
      if (index >= 0) {
        if (editorState.activePolylineId === editorState.selectedId) {
          clearActivePolylineState();
        }
        editorState.shapes.splice(index, 1);
        setSelectedShape(null, { suppressRender: true });
        renderEditor();
        queuePersist();
      }
    };
    const createDefaultInteraction = () => ({
      stream: "pose",
      landmark: "left_wrist",
      trigger: "enter",
      midi: {
        type: "none",
        channel: 1,
        note: 60,
        velocity: 96,
        cc: 1,
        value: 100
      },
      osc: {
        address: "",
        args: ""
      }
    });
    const mergeInteraction = (input) => {
      const defaults = createDefaultInteraction();
      const source = input || {};
      return {
        ...defaults,
        ...source,
        midi: { ...defaults.midi, ...(source.midi || {}) },
        osc: { ...defaults.osc, ...(source.osc || {}) }
      };
    };
    const escapeHtml = (value) => String(value ?? "").replace(/[&<>"']/g, (match) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[match]));
    const normalizeVertices = (vertices) => {
      if (!Array.isArray(vertices)) return [];
      return vertices.map((vertex) => ({
        x: clampUnit(vertex?.x ?? 0),
        y: clampUnit(vertex?.y ?? 0)
      }));
    };
    const computePolylineBounds = (vertices) => {
      const normalized = normalizeVertices(vertices);
      if (!normalized.length) {
        return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
      }
      let minX = 1;
      let minY = 1;
      let maxX = 0;
      let maxY = 0;
      for (const vertex of normalized) {
        minX = Math.min(minX, vertex.x);
        minY = Math.min(minY, vertex.y);
        maxX = Math.max(maxX, vertex.x);
        maxY = Math.max(maxY, vertex.y);
      }
      return { minX, minY, maxX, maxY };
    };
    const updatePolylineBounds = (shape) => {
      if (!shape || shape.type !== "polyline") return;
      const { minX, minY, maxX, maxY } = computePolylineBounds(shape.vertices);
      shape.x = clampUnit(minX);
      shape.y = clampUnit(minY);
      shape.width = clampRange(maxX - minX, 0, 1);
      shape.height = clampRange(maxY - minY, 0, 1);
    };
    const ensurePolylineStyle = (shape) => {
      if (!shape || shape.type !== "polyline") return;
      shape.style = { ...DEFAULT_SHAPE_STYLE, ...(shape.style || {}) };
      if (shape.closed) {
        shape.style.fill = DEFAULT_SHAPE_STYLE.fill;
      } else {
        shape.style.fill = "none";
      }
    };
    const distanceBetween = (a, b) => {
      if (!a || !b) return 0;
      const dx = (a.x ?? 0) - (b.x ?? 0);
      const dy = (a.y ?? 0) - (b.y ?? 0);
      return Math.hypot(dx, dy);
    };
    const distancePointToSegment = (px, py, ax, ay, bx, by) => {
      const abx = bx - ax;
      const aby = by - ay;
      const apx = px - ax;
      const apy = py - ay;
      const abLenSq = abx * abx + aby * aby;
      let t = abLenSq > 0 ? (apx * abx + apy * aby) / abLenSq : 0;
      t = clampRange(t, 0, 1);
      const closestX = ax + abx * t;
      const closestY = ay + aby * t;
      return Math.hypot(px - closestX, py - closestY);
    };
    const pointInPolygon = (vertices, x, y) => {
      let inside = false;
      for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x;
        const yi = vertices[i].y;
        const xj = vertices[j].x;
        const yj = vertices[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * (y - yi)) / ((yj - yi) || 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    };
    const distanceToPolyline = (vertices, x, y, closed = false) => {
      if (vertices.length === 1) {
        return Math.hypot(vertices[0].x - x, vertices[0].y - y);
      }
      let minDistance = Infinity;
      const segmentCount = closed ? vertices.length : vertices.length - 1;
      for (let i = 0; i < segmentCount; i++) {
        const a = vertices[i];
        const b = vertices[(i + 1) % vertices.length];
        const distance = distancePointToSegment(x, y, a.x, a.y, b.x, b.y);
        if (distance < minDistance) {
          minDistance = distance;
        }
      }
      return minDistance;
    };
    const removeShapeById = (shapeId) => {
      if (!shapeId) return;
      const index = editorState.shapes.findIndex((shape) => shape.id === shapeId);
      if (index >= 0) {
        editorState.shapes.splice(index, 1);
        if (editorState.activePolylineId === shapeId) {
          editorState.activePolylineId = null;
          editorState.polylineHoverPoint = null;
          editorState.initialVertices = null;
          editorState.pointerOrigin = null;
          editorState.pointerId = null;
        }
        if (editorState.selectedId === shapeId) {
          editorState.selectedId = null;
        }
        markEditorSidebarDirty();
        editorState.didMutate = true;
      }
    };
    const clearActivePolylineState = ({ pruneIncomplete = false } = {}) => {
      const activeId = editorState.activePolylineId;
      if (pruneIncomplete && activeId) {
        const shape = findShapeById(activeId);
        if (shape && shape.type === "polyline") {
          const vertexCount = Array.isArray(shape.vertices) ? shape.vertices.length : 0;
          if (vertexCount < 2 || (shape.closed && vertexCount < 3)) {
            removeShapeById(activeId);
          }
        }
      }
      editorState.activePolylineId = null;
      editorState.polylineHoverPoint = null;
      editorState.initialVertices = null;
      editorState.pointerOrigin = null;
      editorState.pointerId = null;
    };
    const finalizeActivePolyline = ({ commit = true } = {}) => {
      const activeId = editorState.activePolylineId;
      if (!activeId) return;
      const shape = findShapeById(activeId);
      clearActivePolylineState();
      if (!shape) {
        renderEditor();
        return;
      }
      const vertexCount = Array.isArray(shape.vertices) ? shape.vertices.length : 0;
      if (!commit || vertexCount < 2 || (shape.closed && vertexCount < 3)) {
        removeShapeById(shape.id);
        renderEditor();
        queuePersist();
        return;
      }
      shape.vertices = normalizeVertices(shape.vertices);
      shape.closed = Boolean(shape.closed);
      ensurePolylineStyle(shape);
      updatePolylineBounds(shape);
      markEditorSidebarDirty();
      renderEditor();
      queuePersist();
    };
    const cancelActivePolyline = () => finalizeActivePolyline({ commit: false });
    const startPolylineAt = (point) => {
      const shape = {
        id: ensureUuid(),
        type: "polyline",
        vertices: [{ ...point }],
        closed: editorState.tool === "polygon",
        style: { ...DEFAULT_SHAPE_STYLE },
        interaction: createDefaultInteraction(),
        runtime: { inside: false, lastTriggerAt: 0, noteOn: false, lastContinuousAt: 0 }
      };
      ensurePolylineStyle(shape);
      updatePolylineBounds(shape);
      editorState.shapes.push(shape);
      editorState.activePolylineId = shape.id;
      editorState.polylineHoverPoint = null;
      editorState.didMutate = true;
      setSelectedShape(shape.id, { suppressRender: true });
      markEditorSidebarDirty();
      renderEditor();
    };
    const addPolylinePoint = (shape, point) => {
      if (!shape || shape.type !== "polyline" || !point) return;
      const vertices = Array.isArray(shape.vertices) ? shape.vertices : (shape.vertices = []);
      const lastVertex = vertices[vertices.length - 1];
      if (lastVertex && distanceBetween(lastVertex, point) < MIN_POLYLINE_SEGMENT) {
        return;
      }
      vertices.push({ ...point });
      updatePolylineBounds(shape);
      ensurePolylineStyle(shape);
      editorState.didMutate = true;
      markEditorSidebarDirty();
      renderEditor();
    };
    const sanitizeInteractionForStorage = (interaction) => {
      const merged = mergeInteraction(interaction);
      if (merged?.midi) {
        delete merged.midi.port;
      }
      if (merged?.osc) {
        delete merged.osc.host;
        delete merged.osc.port;
      }
      return merged;
    };
    const serializeShapes = () => editorState.shapes.map((shape) => ({
      id: shape.id,
      type: shape.type,
      x: shape.x,
      y: shape.y,
      width: shape.width,
      height: shape.height,
      style: shape.style,
      interaction: sanitizeInteractionForStorage(shape.interaction),
      vertices: shape.vertices,
      closed: shape.closed ?? false
    }));
    const queuePersist = () => {
      if (typeof localStorage === "undefined") return;
      if (persistTimer) {
        clearTimeout(persistTimer);
      }
      persistTimer = window.setTimeout(() => {
        try {
          const payload = serializeShapes();
          localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch (err) {
          console.warn("Failed to persist editor state", err);
        } finally {
          persistTimer = null;
        }
      }, 220);
    };
    const loadPersistedShapes = () => {
      if (typeof localStorage === "undefined") return;
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!Array.isArray(data)) return;
        editorState.shapes = data.map((shape) => {
          const type = shape.type === "ellipse" ? "ellipse" : (shape.type === "polyline" ? "polyline" : "rect");
          const mergedInteraction = mergeInteraction(shape.interaction);
          if (mergedInteraction?.midi) {
            delete mergedInteraction.midi.port;
          }
          if (mergedInteraction?.osc) {
            delete mergedInteraction.osc.host;
            delete mergedInteraction.osc.port;
          }
          const normalized = {
            id: shape.id || ensureUuid(),
            type,
            x: clampUnit(shape.x ?? 0),
            y: clampUnit(shape.y ?? 0),
            width: clampRange(shape.width ?? SHAPE_MIN_SIZE, SHAPE_MIN_SIZE, 1),
            height: clampRange(shape.height ?? SHAPE_MIN_SIZE, SHAPE_MIN_SIZE, 1),
            style: { ...DEFAULT_SHAPE_STYLE, ...(shape.style || {}) },
            interaction: mergedInteraction,
            runtime: { inside: false, lastTriggerAt: 0, noteOn: false, lastContinuousAt: 0 }
          };
          if (type === "polyline") {
            normalized.vertices = normalizeVertices(shape.vertices);
            normalized.closed = Boolean(shape.closed);
            ensurePolylineStyle(normalized);
            updatePolylineBounds(normalized);
          }
          return normalized;
        });
        markEditorSidebarDirty();
      } catch (err) {
        console.warn("Failed to restore editor state", err);
      }
    };

    const ensureUuid = () => (typeof crypto !== "undefined" && crypto?.randomUUID
      ? crypto.randomUUID()
      : `shape-${Math.random().toString(36).slice(2, 10)}`);

    const clampRange = (value, min, max) => Math.min(max, Math.max(min, value));
    const clampUnit = (value) => clampRange(value, 0, 1);

    const setEditorViewport = (width, height) => {
      editorState.viewport.width = width || DEFAULT_WIDTH;
      editorState.viewport.height = height || DEFAULT_HEIGHT;
      if (gestureSvg) {
        gestureSvg.setAttribute("viewBox", `0 0 ${editorState.viewport.width} ${editorState.viewport.height}`);
      }
    };

    const setEditorMirrorActive = (enabled) => {
      editorState.mirror = Boolean(enabled);
      if (gestureSvgWrapper) {
        gestureSvgWrapper.classList.toggle("is-mirrored", editorState.mirror);
      }
    };

    const toSvgPoint = (event) => {
      if (!gestureSvg) return null;
      const rect = gestureSvg.getBoundingClientRect();
      if (!rect.width || !rect.height) return null;
      const relativeX = (event.clientX - rect.left) / rect.width;
      const relativeY = (event.clientY - rect.top) / rect.height;
      if (!Number.isFinite(relativeX) || !Number.isFinite(relativeY)) return null;
      const unmirroredX = clampRange(relativeX, 0, 1) * editorState.viewport.width;
      const x = editorState.mirror
        ? editorState.viewport.width - unmirroredX
        : unmirroredX;
      const y = clampRange(relativeY, 0, 1) * editorState.viewport.height;
      return { x, y };
    };

    const toNormalizedPoint = (svgPoint) => ({
      x: clampUnit(svgPoint.x / editorState.viewport.width),
      y: clampUnit(svgPoint.y / editorState.viewport.height)
    });

    const findShapeById = (id) => editorState.shapes.find((shape) => shape.id === id);

    const updateToolButtons = () => {
      for (const [tool, button] of Object.entries(gestureToolButtons)) {
        if (!button) continue;
        button.classList.toggle("is-active", editorState.tool === tool);
        button.disabled = editorState.mode === "perform";
      }
    };

    const updateModeToggleLabel = () => {
      if (!gestureModeToggle) return;
      const icon = gestureModeToggle.querySelector(".material-icons-outlined");
      if (icon) {
        icon.textContent = editorState.mode === "perform" ? "draw" : "play_circle";
      }
      gestureModeToggle.setAttribute("aria-pressed", editorState.mode === "perform" ? "true" : "false");
    };

    const renderEditor = () => {
      if (!gestureSvg) return;
      const scoreVisible = isScoreMainEnabled();
      if (!scoreVisible) {
        clearActivePolylineState({ pruneIncomplete: true });
        gestureSvg.innerHTML = "";
        return;
      }
      const { width, height } = editorState.viewport;
      let previewMarkup = "";
      const shapesMarkup = editorState.shapes.map((shape) => {
        const classes = ["gesture-shape"];
        if (shape.id === editorState.selectedId) {
          classes.push("is-selected");
        }
        if (shape.runtime?.inside) {
          classes.push("is-active");
        }
        const className = classes.join(" ");
        const baseFill = shape.style?.fill ?? DEFAULT_SHAPE_STYLE.fill;
        const baseStroke = shape.style?.stroke ?? DEFAULT_SHAPE_STYLE.stroke;
        const strokeWidth = shape.style?.strokeWidth ?? DEFAULT_SHAPE_STYLE.strokeWidth;
        const isActive = Boolean(shape.runtime?.inside);
        const strokeColor = isActive ? ACTIVE_STROKE_COLOR : baseStroke;
        const fillColor = isActive && baseFill !== "none" ? ACTIVE_FILL_COLOR : baseFill;
        if (shape.type === "polyline") {
          const vertices = normalizeVertices(shape.vertices);
          const pointsAttribute = vertices.map((vertex) => `${vertex.x * width} ${vertex.y * height}`).join(" ");
          const isActivePolyline = editorState.activePolylineId === shape.id;
          const hoverPoint = isActivePolyline ? editorState.polylineHoverPoint : null;
          if (isActivePolyline && hoverPoint && vertices.length) {
            const lastVertex = vertices[vertices.length - 1];
            const hoverX = hoverPoint.x * width;
            const hoverY = hoverPoint.y * height;
            previewMarkup += `<line class="gesture-polyline-preview" x1="${lastVertex.x * width}" y1="${lastVertex.y * height}" x2="${hoverX}" y2="${hoverY}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="4 4"></line>`;
            if (shape.closed && vertices.length >= 2) {
              const firstVertex = vertices[0];
              previewMarkup += `<line class="gesture-polyline-preview" x1="${hoverX}" y1="${hoverY}" x2="${firstVertex.x * width}" y2="${firstVertex.y * height}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="4 4"></line>`;
            }
          }
          const commonAttrs = `data-shape-id="${shape.id}" data-shape-type="polyline" class="${className}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round"`;
          if (shape.closed && vertices.length >= 3) {
            const polygonFill = fillColor === "none" ? "none" : fillColor;
            return `<polygon ${commonAttrs} points="${pointsAttribute}" fill="${polygonFill}"></polygon>`;
          }
          return `<polyline ${commonAttrs} points="${pointsAttribute}" fill="none"></polyline>`;
        }
        const x = shape.x * width;
        const y = shape.y * height;
        const w = Math.max(shape.width * width, 0);
        const h = Math.max(shape.height * height, 0);
        if (shape.type === "ellipse") {
          const cx = x + w / 2;
          const cy = y + h / 2;
          const ellipseFill = fillColor === "none" ? "none" : fillColor;
          return `<ellipse data-shape-id="${shape.id}" data-shape-type="ellipse" class="${className}" cx="${cx}" cy="${cy}" rx="${Math.max(w / 2, 1)}" ry="${Math.max(h / 2, 1)}" fill="${ellipseFill}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></ellipse>`;
        }
        const rectFill = fillColor === "none" ? "none" : fillColor;
        return `<rect data-shape-id="${shape.id}" data-shape-type="rect" class="${className}" x="${x}" y="${y}" width="${Math.max(w, 1)}" height="${Math.max(h, 1)}" fill="${rectFill}" stroke="${strokeColor}" stroke-width="${strokeWidth}"></rect>`;
      }).join("");
      let handlesMarkup = "";
      const selectedShape = findShapeById(editorState.selectedId);
      if (selectedShape) {
        const x = selectedShape.x * width;
        const y = selectedShape.y * height;
        const w = Math.max(selectedShape.width * width, 2);
        const h = Math.max(selectedShape.height * height, 2);
        const right = x + w;
        const bottom = y + h;
        const cx = x + w / 2;
        const cy = y + h / 2;
        handlesMarkup = `
          <g data-selected-controls="${selectedShape.id}">
            <rect class="gesture-outline" x="${x}" y="${y}" width="${w}" height="${h}"></rect>
            <circle class="gesture-handle" data-handle="nw" cx="${x}" cy="${y}" r="6"></circle>
            <circle class="gesture-handle" data-handle="n" cx="${cx}" cy="${y}" r="6"></circle>
            <circle class="gesture-handle" data-handle="ne" cx="${right}" cy="${y}" r="6"></circle>
            <circle class="gesture-handle" data-handle="e" cx="${right}" cy="${cy}" r="6"></circle>
            <circle class="gesture-handle" data-handle="se" cx="${right}" cy="${bottom}" r="6"></circle>
            <circle class="gesture-handle" data-handle="s" cx="${cx}" cy="${bottom}" r="6"></circle>
            <circle class="gesture-handle" data-handle="sw" cx="${x}" cy="${bottom}" r="6"></circle>
            <circle class="gesture-handle" data-handle="w" cx="${x}" cy="${cy}" r="6"></circle>
          </g>
        `;
      }
      gestureSvg.innerHTML = `<g class="gesture-shapes">${shapesMarkup}${previewMarkup}</g>${handlesMarkup}`;
      if (editorSidebarDirty && activePanelTab === "editor") {
        updateEditorSidebar();
      }
    };

    const drawScorePreview = (ctx, canvasWidth, canvasHeight) => {
      if (!isScorePreviewEnabled() || !editorState.shapes.length) return;
      ctx.save();
      for (const shape of editorState.shapes) {
        const baseFill = shape.style?.fill ?? DEFAULT_SHAPE_STYLE.fill;
        const baseStroke = shape.style?.stroke ?? DEFAULT_SHAPE_STYLE.stroke;
        const strokeWidth = shape.style?.strokeWidth ?? DEFAULT_SHAPE_STYLE.strokeWidth;
        const isActive = Boolean(shape.runtime?.inside);
        const strokeColor = isActive ? ACTIVE_PREVIEW_STROKE_COLOR : baseStroke;
        const fillColor = isActive && baseFill !== "none" ? ACTIVE_PREVIEW_FILL_COLOR : baseFill;
        ctx.globalAlpha = 1;
        if (shape.type === "polyline") {
          const vertices = normalizeVertices(shape.vertices);
          if (!vertices.length) continue;
          ctx.save();
          ctx.beginPath();
          const first = vertices[0];
          ctx.moveTo(first.x * canvasWidth, first.y * canvasHeight);
          for (let i = 1; i < vertices.length; i++) {
            const vertex = vertices[i];
            ctx.lineTo(vertex.x * canvasWidth, vertex.y * canvasHeight);
          }
          if (shape.closed && vertices.length >= 3) {
            ctx.closePath();
            if (fillColor && fillColor !== "none") {
              ctx.fillStyle = fillColor;
              ctx.globalAlpha = 0.7;
              ctx.fill();
              ctx.globalAlpha = 1;
            }
          }
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.stroke();
          ctx.restore();
          continue;
        }
        const x = shape.x * canvasWidth;
        const y = shape.y * canvasHeight;
        const w = Math.max(shape.width * canvasWidth, 0);
        const h = Math.max(shape.height * canvasHeight, 0);
        if (shape.type === "ellipse") {
          ctx.save();
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h / 2, Math.max(w / 2, 1), Math.max(h / 2, 1), 0, 0, Math.PI * 2);
          if (fillColor && fillColor !== "none") {
            ctx.fillStyle = fillColor;
            ctx.globalAlpha = 0.7;
            ctx.fill();
          }
          ctx.globalAlpha = 1;
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
          ctx.restore();
        } else {
          if (fillColor && fillColor !== "none") {
            ctx.fillStyle = fillColor;
            ctx.globalAlpha = 0.7;
            ctx.fillRect(x, y, w, h);
          }
          ctx.globalAlpha = 1;
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.strokeRect(x, y, w, h);
        }
      }
      ctx.restore();
    };

    const setSelectedShape = (shapeId, { suppressRender = false } = {}) => {
      if (editorState.selectedId === shapeId) {
        if (activePanelTab === "editor") {
          syncEditorDetailForm();
        }
        return;
      }
      editorState.selectedId = shapeId || null;
      if (!shapeId) {
        editorState.activePolylineId = null;
        editorState.polylineHoverPoint = null;
      }
      markEditorSidebarDirty();
      if (suppressRender) {
        if (activePanelTab === "editor") {
          updateEditorSidebar();
        }
      } else {
        renderEditor();
      }
    };

    const setEditorTool = (tool) => {
      if (!tool) return;
      const previousTool = editorState.tool;
      editorState.tool = tool;
      if (isPolylineTool(previousTool) && previousTool !== tool) {
        finalizeActivePolyline({ commit: true });
      }
      if (tool !== "eraser") {
        editorState.eraserActive = false;
        editorState.erasedShapeIds.clear();
        editorState.eraserPointerId = null;
      }
      if (tool === "eraser") {
        clearActivePolylineState();
        setSelectedShape(null, { suppressRender: true });
      }
      if (isPolylineTool(tool)) {
        editorState.polylineHoverPoint = null;
      }
      updateToolButtons();
      renderEditor();
    };

    const setEditorMode = (mode) => {
      editorState.mode = mode;
      if (mode === "perform") {
        finalizeActivePolyline({ commit: true });
      }
      if (gestureEditorEl) {
        gestureEditorEl.classList.toggle("is-performing", mode === "perform");
      }
      if (gestureSvg) {
        gestureSvg.style.pointerEvents = mode === "perform" ? "none" : "auto";
      }
      gestureModeToggle?.classList.toggle("is-active", mode === "perform");
      updateModeToggleLabel();
      updateToolButtons();
    };

    const beginDrawing = (tool, event) => {
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      const normalized = toNormalizedPoint(svgPoint);
      const shapeType = isPolylineTool(tool) ? "polyline" : tool;
      const shape = {
        id: ensureUuid(),
        type: shapeType,
        x: normalized.x,
        y: normalized.y,
        width: 0,
        height: 0,
        style: { ...DEFAULT_SHAPE_STYLE },
        interaction: createDefaultInteraction(),
        runtime: { inside: false, lastTriggerAt: 0, noteOn: false, lastContinuousAt: 0 }
      };
      editorState.shapes.push(shape);
      setSelectedShape(shape.id, { suppressRender: true });
      editorState.drawingShapeId = shape.id;
      editorState.pointerId = event.pointerId;
      editorState.pointerOrigin = { svg: svgPoint, normalized };
      editorState.didMutate = true;
      if (gestureSvg?.setPointerCapture) {
        gestureSvg.setPointerCapture(event.pointerId);
      }
      renderEditor();
    };

    const handlePolylinePointerDown = (event) => {
      if (event.button && event.button !== 0) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      event.preventDefault();
      const normalized = toNormalizedPoint(svgPoint);
      if (!editorState.activePolylineId) {
        startPolylineAt(normalized);
        return;
      }
      const shape = findShapeById(editorState.activePolylineId);
      if (!shape) {
        startPolylineAt(normalized);
        return;
      }
      addPolylinePoint(shape, normalized);
    };

    const handlePolylinePointerMove = (event) => {
      if (!editorState.activePolylineId) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      editorState.polylineHoverPoint = toNormalizedPoint(svgPoint);
      renderEditor();
    };

    const eraseAtEvent = (event) => {
      const localTarget = event.target?.closest?.("[data-shape-id]");
      const fallbackTarget = document.elementFromPoint?.(event.clientX ?? 0, event.clientY ?? 0)?.closest?.("[data-shape-id]");
      const shapeTarget = localTarget || fallbackTarget;
      const shapeId = shapeTarget?.getAttribute?.("data-shape-id");
      if (!shapeId || editorState.erasedShapeIds.has(shapeId)) {
        return;
      }
      editorState.erasedShapeIds.add(shapeId);
      removeShapeById(shapeId);
      renderEditor();
      queuePersist();
    };

    const beginErasing = (event) => {
      editorState.eraserActive = true;
      editorState.eraserPointerId = event.pointerId;
      editorState.erasedShapeIds = new Set();
      eraseAtEvent(event);
      gestureSvg?.setPointerCapture?.(event.pointerId);
    };

    const handleEraserMove = (event) => {
      if (!editorState.eraserActive) return;
      eraseAtEvent(event);
    };

    const beginShapeDrag = (shapeId, handle, event) => {
      const shape = findShapeById(shapeId);
      if (!shape) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      setSelectedShape(shapeId, { suppressRender: true });
      editorState.dragHandle = handle || "move";
      editorState.pointerId = event.pointerId;
      editorState.pointerOrigin = { svg: svgPoint, normalized: toNormalizedPoint(svgPoint) };
      editorState.initialRect = {
        x: shape.x,
        y: shape.y,
        width: shape.width,
        height: shape.height
      };
      editorState.initialVertices = shape.type === "polyline"
        ? normalizeVertices(shape.vertices).map((vertex) => ({ ...vertex }))
        : null;
      if (gestureSvg?.setPointerCapture) {
        gestureSvg.setPointerCapture(event.pointerId);
      }
      renderEditor();
    };

    const applyDragToShape = (shape, normalized) => {
      if (!shape || !editorState.pointerOrigin || !editorState.initialRect) return;
      const dx = normalized.x - editorState.pointerOrigin.normalized.x;
      const dy = normalized.y - editorState.pointerOrigin.normalized.y;
      const handle = editorState.dragHandle || "move";
      const initial = editorState.initialRect;
      const initialRight = initial.x + initial.width;
      const initialBottom = initial.y + initial.height;
      let left = initial.x;
      let top = initial.y;
      let right = initialRight;
      let bottom = initialBottom;
      if (shape.type === "polyline") {
        const initialVertices = editorState.initialVertices || normalizeVertices(shape.vertices);
        if (!initialVertices.length) return;
        if (handle === "move") {
          const newLeft = clampRange(initial.x + dx, 0, 1 - initial.width);
          const newTop = clampRange(initial.y + dy, 0, 1 - initial.height);
          const moveX = newLeft - initial.x;
          const moveY = newTop - initial.y;
          shape.vertices = initialVertices.map((vertex) => ({
            x: clampUnit(vertex.x + moveX),
            y: clampUnit(vertex.y + moveY)
          }));
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
          editorState.didMutate = true;
          return;
        }
        if (handle.includes("w")) {
          left = clampRange(initial.x + dx, 0, initialRight - SHAPE_MIN_SIZE);
        }
        if (handle.includes("e")) {
          right = clampRange(initialRight + dx, left + SHAPE_MIN_SIZE, 1);
        }
        if (handle.includes("n")) {
          top = clampRange(initial.y + dy, 0, initialBottom - SHAPE_MIN_SIZE);
        }
        if (handle.includes("s")) {
          bottom = clampRange(initialBottom + dy, top + SHAPE_MIN_SIZE, 1);
        }
        const width = clampRange(right - left, SHAPE_MIN_SIZE, 1);
        const height = clampRange(bottom - top, SHAPE_MIN_SIZE, 1);
        const initialWidth = initial.width || 1;
        const initialHeight = initial.height || 1;
        shape.vertices = initialVertices.map((vertex) => {
          const relX = initial.width ? (vertex.x - initial.x) / initialWidth : 0;
          const relY = initial.height ? (vertex.y - initial.y) / initialHeight : 0;
          return {
            x: clampUnit(left + relX * width),
            y: clampUnit(top + relY * height)
          };
        });
        updatePolylineBounds(shape);
        ensurePolylineStyle(shape);
        editorState.didMutate = true;
        return;
      }
      if (handle === "move") {
        const newX = clampRange(initial.x + dx, 0, 1 - initial.width);
        const newY = clampRange(initial.y + dy, 0, 1 - initial.height);
        shape.x = Number.isFinite(newX) ? newX : initial.x;
        shape.y = Number.isFinite(newY) ? newY : initial.y;
        editorState.didMutate = true;
        return;
      }
      if (handle.includes("w")) {
        left = clampRange(initial.x + dx, 0, initialRight - SHAPE_MIN_SIZE);
      }
      if (handle.includes("e")) {
        right = clampRange(initialRight + dx, left + SHAPE_MIN_SIZE, 1);
      }
      if (handle.includes("n")) {
        top = clampRange(initial.y + dy, 0, initialBottom - SHAPE_MIN_SIZE);
      }
      if (handle.includes("s")) {
        bottom = clampRange(initialBottom + dy, top + SHAPE_MIN_SIZE, 1);
      }
      const width = clampRange(right - left, SHAPE_MIN_SIZE, 1);
      const height = clampRange(bottom - top, SHAPE_MIN_SIZE, 1);
      shape.x = clampUnit(left);
      shape.y = clampUnit(top);
      shape.width = clampRange(width, SHAPE_MIN_SIZE, 1);
      shape.height = clampRange(height, SHAPE_MIN_SIZE, 1);
      editorState.didMutate = true;
    };

    const updateDrawingShape = (shape, normalized) => {
      if (!shape || !editorState.pointerOrigin) return;
      const origin = editorState.pointerOrigin.normalized;
      const x1 = clampUnit(origin.x);
      const y1 = clampUnit(origin.y);
      const x2 = clampUnit(normalized.x);
      const y2 = clampUnit(normalized.y);
      const left = Math.min(x1, x2);
      const top = Math.min(y1, y2);
      const width = Math.abs(x2 - x1);
      const height = Math.abs(y2 - y1);
      shape.x = clampUnit(left);
      shape.y = clampUnit(top);
      shape.width = clampRange(width, 0, 1);
      shape.height = clampRange(height, 0, 1);
      editorState.didMutate = true;
    };

    const finishPointerInteraction = (event) => {
      if (event.pointerId !== editorState.pointerId) {
        return;
      }
      if (gestureSvg?.hasPointerCapture?.(event.pointerId)) {
        gestureSvg.releasePointerCapture(event.pointerId);
      }
      if (editorState.drawingShapeId) {
        const shape = findShapeById(editorState.drawingShapeId);
        if (shape) {
          if (shape.width < SHAPE_MIN_SIZE && shape.height < SHAPE_MIN_SIZE) {
            editorState.shapes = editorState.shapes.filter((item) => item.id !== shape.id);
            if (editorState.selectedId === shape.id) {
              setSelectedShape(null, { suppressRender: true });
            } else {
              markEditorSidebarDirty();
            }
          }
        }
      }
      const wasMutated = editorState.didMutate;
      editorState.drawingShapeId = null;
      editorState.dragHandle = null;
      editorState.pointerId = null;
      editorState.pointerOrigin = null;
      editorState.initialRect = null;
      editorState.initialVertices = null;
      editorState.didMutate = false;
      if (wasMutated) {
        queuePersist();
      }
      renderEditor();
    };

    const handleEditorPointerDown = (event) => {
      if (editorState.mode === "perform") return;
      if (!gestureSvg) return;
      if (typeof gestureSvg.focus === "function") {
        try {
          gestureSvg.focus({ preventScroll: true });
        } catch (err) {
          gestureSvg.focus();
        }
      }
      if (editorState.tool === "eraser") {
        beginErasing(event);
        return;
      }
      if (isPolylineTool(editorState.tool)) {
        handlePolylinePointerDown(event);
        return;
      }
      const handle = event.target?.dataset?.handle;
      if (handle) {
        const controlGroup = event.target.closest("[data-selected-controls]");
        const shapeId = controlGroup?.getAttribute("data-selected-controls");
        if (shapeId) {
          beginShapeDrag(shapeId, handle, event);
        }
        return;
      }
      const shapeTarget = event.target?.closest?.("[data-shape-id]");
      const shapeId = shapeTarget?.getAttribute?.("data-shape-id");
      if (shapeId) {
        beginShapeDrag(shapeId, "move", event);
        return;
      }
      if (editorState.tool === "select") {
        setSelectedShape(null);
        return;
      }
      beginDrawing(editorState.tool, event);
    };

    const handleEditorPointerMove = (event) => {
      if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
        handlePolylinePointerMove(event);
        return;
      }
      if (editorState.tool === "eraser" && editorState.eraserActive) {
        handleEraserMove(event);
        return;
      }
      if (event.pointerId !== editorState.pointerId) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      const normalized = toNormalizedPoint(svgPoint);
      if (editorState.drawingShapeId) {
        const shape = findShapeById(editorState.drawingShapeId);
        if (shape) {
          updateDrawingShape(shape, normalized);
          renderEditor();
        }
        return;
      }
      if (editorState.dragHandle && editorState.selectedId) {
        const shape = findShapeById(editorState.selectedId);
        if (shape) {
          applyDragToShape(shape, normalized);
          renderEditor();
        }
      }
    };

    const handleEditorPointerUp = (event) => {
      if (editorState.eraserActive && event.pointerId === editorState.eraserPointerId) {
        editorState.eraserActive = false;
        editorState.eraserPointerId = null;
        editorState.erasedShapeIds.clear();
        gestureSvg?.releasePointerCapture?.(event.pointerId);
      }
      finishPointerInteraction(event);
    };

    const handleEditorPointerLeave = (event) => {
      finishPointerInteraction(event);
      if (editorState.activePolylineId && editorState.polylineHoverPoint) {
        editorState.polylineHoverPoint = null;
        renderEditor();
      }
      if (editorState.eraserActive && event.pointerId === editorState.eraserPointerId) {
        editorState.eraserActive = false;
        editorState.eraserPointerId = null;
        editorState.erasedShapeIds.clear();
        gestureSvg?.releasePointerCapture?.(event.pointerId);
      }
    };
    const handleGlobalShortcut = (event) => {
      if (!(event.metaKey || event.ctrlKey)) return;
      if (event.altKey) return;
      if (event.repeat) return;
      const key = event.key?.toLowerCase();
      if (key === ",") {
        event.preventDefault();
        togglePanel();
        return;
      }
      if (key === "e") {
        event.preventDefault();
        toggleEditorVisibility();
      }
    };
    const handleEditorKeyDown = (event) => {
      if (event.defaultPrevented) return;
      if (assignmentModal?.classList.contains("is-visible")) return;
      if (event.ctrlKey || event.metaKey || event.altKey) return;
      if (editorState.mode !== "edit") return;
      const activeTag = document.activeElement?.tagName?.toLowerCase() || "";
      if (["input", "textarea", "select"].includes(activeTag)) return;
      const key = event.key?.toLowerCase();
      switch (key) {
        case "v":
          setEditorTool("select");
          event.preventDefault();
          break;
        case "r":
          setEditorTool("rect");
          event.preventDefault();
          break;
        case "e":
          setEditorTool("eraser");
          event.preventDefault();
          break;
        case "o":
          setEditorTool("ellipse");
          event.preventDefault();
          break;
        case "l":
          setEditorTool("line");
          event.preventDefault();
          break;
        case "p":
          setEditorTool("polygon");
          event.preventDefault();
          break;
        case "delete":
        case "backspace":
          if (editorState.activePolylineId) {
            cancelActivePolyline();
            event.preventDefault();
          } else {
            deleteSelectedShape();
            event.preventDefault();
          }
          break;
        case "enter":
          if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
            finalizeActivePolyline({ commit: true });
            event.preventDefault();
          } else if (editorState.selectedId) {
            openAssignmentModal(editorState.selectedId);
            event.preventDefault();
          }
          break;
        case "escape":
          if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
            cancelActivePolyline();
            event.preventDefault();
          } else if (editorState.selectedId) {
            setSelectedShape(null);
            event.preventDefault();
          }
          break;
        default:
          break;
      }
    };

    const openAssignmentModal = (shapeId) => {
      if (!assignmentModal || !assignmentBackdrop) return;
      const shape = findShapeById(shapeId);
      if (!shape) return;
      refreshMidiPortOptions();
      activeAssignmentShapeId = shapeId;
      const interaction = mergeInteraction(shape.interaction);
      const stream = interaction.stream || "pose";
      const landmark = interaction.landmark || getStreamDefinition(stream)?.options?.[0]?.key || "";
      if (assignmentStreamSelect) {
        assignmentStreamSelect.value = stream;
      }
      const resolvedLandmark = populateLandmarkOptions(stream, landmark, assignmentLandmarkSelect) || landmark;
      if (assignmentLandmarkSelect) {
        assignmentLandmarkSelect.value = resolvedLandmark;
      }
      if (assignmentTriggerSelect) {
        assignmentTriggerSelect.value = interaction.trigger || "enter";
      }
      const midi = interaction.midi || createDefaultInteraction().midi;
      if (assignmentMidiTypeSelect) assignmentMidiTypeSelect.value = midi.type || "none";
      populateMidiPortSelect(assignmentMidiPortSelect, editorConfig.midiPort);
      if (assignmentMidiPortSelect) {
        assignmentMidiPortSelect.dataset.selectedPort = editorConfig.midiPort;
      }
      if (assignmentMidiChannelInput) assignmentMidiChannelInput.value = midi.channel ?? 1;
      if (assignmentMidiNoteInput) assignmentMidiNoteInput.value = midi.note ?? 60;
      if (assignmentMidiVelocityInput) assignmentMidiVelocityInput.value = midi.velocity ?? 96;
      if (assignmentMidiCcInput) assignmentMidiCcInput.value = midi.cc ?? 1;
      if (assignmentMidiCcValueInput) assignmentMidiCcValueInput.value = midi.value ?? 100;
      if (assignmentOscAddressInput) assignmentOscAddressInput.value = interaction.osc?.address ?? "";
      if (assignmentOscHostInput) assignmentOscHostInput.value = editorConfig.oscHost;
      if (assignmentOscPortInput) assignmentOscPortInput.value = editorConfig.oscPort;
      if (assignmentOscArgsInput) assignmentOscArgsInput.value = interaction.osc?.args ?? "";
      updateMidiControlsVisibility(assignmentMidiTypeSelect?.value || "none", modalMidiContext);
      assignmentBackdrop.classList.add("is-visible");
      assignmentModal.classList.add("is-visible");
      assignmentBackdrop.setAttribute("aria-hidden", "false");
      assignmentModal.setAttribute("aria-hidden", "false");
      setTimeout(() => {
        assignmentStreamSelect?.focus();
      }, 20);
    };

    const closeAssignmentModal = () => {
      if (!assignmentModal || !assignmentBackdrop) return;
      assignmentBackdrop.classList.remove("is-visible");
      assignmentModal.classList.remove("is-visible");
      assignmentBackdrop.setAttribute("aria-hidden", "true");
      assignmentModal.setAttribute("aria-hidden", "true");
      activeAssignmentShapeId = null;
    };

    const applyAssignmentModal = () => {
      if (!activeAssignmentShapeId) {
        closeAssignmentModal();
        return;
      }
      const shape = findShapeById(activeAssignmentShapeId);
      if (!shape) {
        closeAssignmentModal();
        return;
      }
      const stream = assignmentStreamSelect?.value || "pose";
      const landmark = assignmentLandmarkSelect?.value || getStreamDefinition(stream)?.options?.[0]?.key || "";
      const trigger = assignmentTriggerSelect?.value || "enter";
      const midiType = assignmentMidiTypeSelect?.value || "none";
      const midiPort = assignmentMidiPortSelect?.value || "broadcast";
      const midiChannel = clampRange(parseInt(assignmentMidiChannelInput?.value ?? "1", 10) || 1, 1, 16);
      const midiNote = clampRange(parseInt(assignmentMidiNoteInput?.value ?? "60", 10) || 60, 0, 127);
      const midiVelocity = clampRange(parseInt(assignmentMidiVelocityInput?.value ?? "96", 10) || 96, 0, 127);
      const midiCcNumber = clampRange(parseInt(assignmentMidiCcInput?.value ?? "1", 10) || 1, 0, 127);
      const midiCcValue = clampRange(parseInt(assignmentMidiCcValueInput?.value ?? "100", 10) || 100, 0, 127);
      const oscAddress = assignmentOscAddressInput?.value?.trim() || "";
      const oscHost = assignmentOscHostInput?.value?.trim() || "127.0.0.1";
      const oscPort = clampRange(parseInt(assignmentOscPortInput?.value ?? "9000", 10) || 9000, 1, 65535);
      const oscArgs = assignmentOscArgsInput?.value?.trim() || "";
      if (!isSyncingConfig) {
        updateEditorConfig({ midiPort, oscHost, oscPort });
      }
      shape.interaction = {
        stream,
        landmark,
        trigger,
        midi: {
          type: midiType,
          channel: midiChannel,
          note: midiNote,
          velocity: midiVelocity,
          cc: midiCcNumber,
          value: midiCcValue
        },
        osc: {
          address: oscAddress,
          args: oscArgs
        }
      };
      resetShapeRuntime(shape);
      markEditorSidebarDirty();
      closeAssignmentModal();
      renderEditor();
      queuePersist();
    };
    const midiManager = {
      supported: typeof navigator !== "undefined" && typeof navigator.requestMIDIAccess === "function",
      ready: false,
      pending: null,
      access: null,
      outputs: []
    };
    const getMidiOutputs = () => Array.isArray(midiManager.outputs) ? midiManager.outputs : [];
    const midiOptionLabel = (output, index) => {
      const baseName = output?.name && output.name.trim() ? output.name.trim() : `Port ${index + 1}`;
      const manufacturer = output?.manufacturer && output.manufacturer.trim() ? output.manufacturer.trim() : "";
      return manufacturer ? `${baseName} (${manufacturer})` : baseName;
    };
    const populateMidiPortSelect = (selectEl, selectedId = editorConfig.midiPort) => {
      if (!selectEl) return;
      const outputs = getMidiOutputs();
      const options = [
        { id: "broadcast", label: "All Outputs" },
        ...outputs.map((output, index) => ({ id: output.id || `port-${index}`, label: midiOptionLabel(output, index) }))
      ];
      selectEl.innerHTML = options.map((option) => `<option value="${escapeHtml(option.id)}">${escapeHtml(option.label)}</option>`).join("");
      const normalized = options.some((option) => option.id === selectedId) ? selectedId : "broadcast";
      selectEl.value = normalized;
      selectEl.dataset.selectedPort = normalized;
    };
    function applyGlobalConnectionConfig() {
      isSyncingConfig = true;
      populateMidiPortSelect(assignmentMidiPortSelect, editorConfig.midiPort);
      populateMidiPortSelect(editorMidiPortSelect, editorConfig.midiPort);
      if (assignmentMidiPortSelect) assignmentMidiPortSelect.dataset.selectedPort = editorConfig.midiPort;
      if (editorMidiPortSelect) editorMidiPortSelect.dataset.selectedPort = editorConfig.midiPort;
      if (assignmentOscHostInput) assignmentOscHostInput.value = editorConfig.oscHost;
      if (editorOscHostInput) editorOscHostInput.value = editorConfig.oscHost;
      if (assignmentOscPortInput) assignmentOscPortInput.value = editorConfig.oscPort;
      if (editorOscPortInput) editorOscPortInput.value = editorConfig.oscPort;
      isSyncingConfig = false;
    }
    const refreshMidiPortOptions = async () => {
      await ensureMidiAccess();
      applyGlobalConnectionConfig();
    };
    const ensureMidiAccess = () => {
      if (!midiManager.supported) {
        return Promise.resolve(null);
      }
      if (midiManager.ready) {
        return Promise.resolve(midiManager.outputs);
      }
      if (!midiManager.pending) {
        midiManager.pending = navigator.requestMIDIAccess({ sysex: false }).then((access) => {
          midiManager.access = access;
          midiManager.outputs = Array.from(access.outputs.values());
          midiManager.ready = true;
          access.addEventListener("statechange", () => {
            midiManager.outputs = Array.from(access.outputs.values());
            applyGlobalConnectionConfig();
          });
          applyGlobalConnectionConfig();
          return midiManager.outputs;
        }).catch((err) => {
          console.warn("MIDI access unavailable", err);
          midiManager.supported = false;
          return null;
        });
      }
      return midiManager.pending;
    };
    const sendMidiMessage = (status, data1, data2, portId = "broadcast") => {
      if (!midiManager.supported) {
        console.info("[MIDI]", { status, data1, data2, port: portId });
        return;
      }
      ensureMidiAccess().then((outputs) => {
        if (!outputs || !outputs.length) {
          console.info("[MIDI pending output]", { status, data1, data2, port: portId });
          return;
        }
        const targets = portId && portId !== "broadcast"
          ? outputs.filter((output) => output.id === portId)
          : outputs;
        if (!targets.length) {
          console.info("[MIDI no matching port]", { port: portId, status, data1, data2 });
          return;
        }
        targets.forEach((output) => {
          try {
            output.send([status, data1, data2]);
          } catch (err) {
            console.warn("MIDI send failed", err);
          }
        });
      });
    };
    const sendMidiNote = (channel, note, velocity, type = "on", portId = editorConfig.midiPort) => {
      const normalizedChannel = clampRange(Math.floor(channel) || 1, 1, 16);
      const normalizedNote = clampRange(Math.floor(note) || 0, 0, 127);
      const normalizedVelocity = clampRange(Math.floor(velocity) || 0, 0, 127);
      const status = (type === "off" ? 0x80 : 0x90) | ((normalizedChannel - 1) & 0x0f);
      sendMidiMessage(status, normalizedNote, normalizedVelocity, portId);
    };
    const sendMidiCc = (channel, cc, value, portId = editorConfig.midiPort) => {
      const normalizedChannel = clampRange(Math.floor(channel) || 1, 1, 16);
      const normalizedCc = clampRange(Math.floor(cc) || 0, 0, 127);
      const normalizedValue = clampRange(Math.floor(value) || 0, 0, 127);
      const status = 0xb0 | ((normalizedChannel - 1) & 0x0f);
      sendMidiMessage(status, normalizedCc, normalizedValue, portId);
    };
    const parseOscArgs = (input, context = {}) => {
      if (!input) return [];
      return input.split(",").map((chunk) => {
        const value = chunk.trim();
        if (!value) return "";
        if (value === ":value") return context.value ?? 0;
        if (value === ":phase") return context.phase ?? "";
        if (value === ":inside") return context.inside ? 1 : 0;
        if (value === ":timestamp") return context.timestamp ?? Date.now();
        if (value === "true") return true;
        if (value === "false") return false;
        const numeric = Number(value);
        if (!Number.isNaN(numeric)) return numeric;
        return value;
      });
    };
    const sendOscMessage = (address, args, meta = {}) => {
      if (!address) return;
      const payload = { address, args, meta };
      try {
        window.dispatchEvent(new CustomEvent("mediapipa:osc", { detail: payload }));
      } catch (err) {
        console.warn("OSC dispatch failed", err);
      }
      console.info("[OSC]", payload);
    };
    const findLandmarkIndex = (list, key) => {
      const match = list.find((item) => item.key === key);
      if (match && typeof match.index === "number") {
        return match.index;
      }
      return typeof list[0]?.index === "number" ? list[0].index : 0;
    };
    const shapeContainsPoint = (shape, point) => {
      if (!shape || !point) return false;
      const px = clampUnit(point.x ?? 0);
      const py = clampUnit(point.y ?? 0);
      if (shape.type === "polyline") {
        const vertices = normalizeVertices(shape.vertices);
        if (!vertices.length) return false;
        if (shape.closed && vertices.length >= 3) {
          return pointInPolygon(vertices, px, py);
        }
        const distance = distanceToPolyline(vertices, px, py, Boolean(shape.closed));
        return distance <= 0.02;
      }
      if (shape.type === "ellipse") {
        const cx = shape.x + shape.width / 2;
        const cy = shape.y + shape.height / 2;
        const rx = shape.width / 2;
        const ry = shape.height / 2;
        if (rx <= 0 || ry <= 0) return false;
        const nx = (px - cx) / rx;
        const ny = (py - cy) / ry;
        return (nx * nx + ny * ny) <= 1;
      }
      return px >= shape.x && px <= shape.x + shape.width && py >= shape.y && py <= shape.y + shape.height;
    };
    const getLandmarkPoint = (landmarks, index) => {
      if (!landmarks || typeof index !== "number") return null;
      const landmark = landmarks[index];
      if (!landmark) return null;
      return {
        x: clampUnit(landmark.x ?? 0),
        y: clampUnit(landmark.y ?? 0),
        z: landmark.z ?? 0
      };
    };
    const resolveFacePoint = (key, landmarks) => {
      if (!landmarks || !landmarks.length) return null;
      if (key === "centroid") {
        let sumX = 0;
        let sumY = 0;
        for (let i = 0; i < landmarks.length; i++) {
          sumX += clampUnit(landmarks[i].x ?? 0);
          sumY += clampUnit(landmarks[i].y ?? 0);
        }
        const count = landmarks.length || 1;
        return { x: clampUnit(sumX / count), y: clampUnit(sumY / count) };
      }
      if (key === "nose_tip") {
        const index = findLandmarkIndex(FACE_REFERENCE_POINTS, key);
        return getLandmarkPoint(landmarks, index);
      }
      return null;
    };
    const resolveStreamPoint = (streamId, landmarkKey, results) => {
      if (!results) return null;
      switch (streamId) {
        case "pose": {
          const index = findLandmarkIndex(POSE_LANDMARKS_LIST, landmarkKey);
          return getLandmarkPoint(results.poseLandmarks, index);
        }
        case "leftHand": {
          const index = findLandmarkIndex(HAND_LANDMARKS_LIST, landmarkKey);
          return getLandmarkPoint(results.leftHandLandmarks, index);
        }
        case "rightHand": {
          const index = findLandmarkIndex(HAND_LANDMARKS_LIST, landmarkKey);
          return getLandmarkPoint(results.rightHandLandmarks, index);
        }
        case "face": {
          return resolveFacePoint(landmarkKey, results.faceLandmarks);
        }
        default:
          return null;
      }
    };
    const adjustPointForMirror = (point) => {
      if (!point) return null;
      // Shapes persist in the camera's native coordinate system even when the UI is mirrored,
      // so incoming landmark points can be compared as-is without flipping them again.
      return point;
    };
    const evaluateShapeInteractions = (results) => {
      if (!results || !editorState.shapes.length || !isScoreMainEnabled()) return;
      const now = typeof performance !== "undefined" && performance?.now ? performance.now() : Date.now();
      const pointCache = new Map();
      for (const shape of editorState.shapes) {
        if (!shape.interaction) continue;
        const interaction = shape.interaction;
        const cacheKey = `${interaction.stream}:${interaction.landmark}`;
        if (!pointCache.has(cacheKey)) {
          const point = resolveStreamPoint(interaction.stream, interaction.landmark, results);
          pointCache.set(cacheKey, adjustPointForMirror(point));
        }
        const targetPoint = pointCache.get(cacheKey);
        const inside = targetPoint ? shapeContainsPoint(shape, targetPoint) : false;
        const runtime = shape.runtime || (shape.runtime = { inside: false, lastTriggerAt: 0, noteOn: false, lastContinuousAt: 0 });
        const justEntered = inside && !runtime.inside;
        const justExited = !inside && runtime.inside;
        const continuousReady = inside && (now - (runtime.lastContinuousAt || 0) >= CONTINUOUS_TRIGGER_INTERVAL_MS);
        let phase = null;
        if (justEntered) {
          phase = "enter";
        } else if (justExited) {
          phase = "exit";
        } else if (continuousReady) {
          phase = "inside";
        }
        if (phase === "inside" && inside) {
          runtime.lastContinuousAt = now;
        }
        const matchesTrigger = phase && (interaction.trigger === phase || (interaction.trigger === "inside" && phase === "inside"));
        if (interaction.midi?.type === "note") {
          if (justEntered) {
            sendMidiNote(interaction.midi.channel, interaction.midi.note, interaction.midi.velocity, "on", editorConfig.midiPort);
            runtime.noteOn = true;
          } else if (justExited && runtime.noteOn) {
            sendMidiNote(interaction.midi.channel, interaction.midi.note, 0, "off", editorConfig.midiPort);
            runtime.noteOn = false;
          } else if (matchesTrigger && interaction.trigger === "inside" && inside) {
            sendMidiNote(interaction.midi.channel, interaction.midi.note, interaction.midi.velocity, "on", editorConfig.midiPort);
            runtime.noteOn = true;
          }
        } else if (interaction.midi?.type === "cc" && matchesTrigger) {
          const value = phase === "exit" ? 0 : interaction.midi.value;
          sendMidiCc(interaction.midi.channel, interaction.midi.cc, value, editorConfig.midiPort);
        }
        if (interaction.osc?.address && matchesTrigger) {
          const oscValue = phase === "exit" ? 0 : (inside ? 1 : 0);
          const args = parseOscArgs(interaction.osc.args, {
            value: oscValue,
            phase,
            inside,
            timestamp: now
          });
          if (!args.length) {
            args.push(oscValue);
          }
          sendOscMessage(interaction.osc.address, args, {
            shapeId: shape.id,
            phase,
            stream: interaction.stream,
            landmark: interaction.landmark,
            host: editorConfig.oscHost,
            port: editorConfig.oscPort,
            value: oscValue,
            inside
          });
        }
        runtime.inside = inside;
        runtime.lastTriggerAt = now;
        if (activePanelTab === "editor") {
          const item = document.getElementById(`editor-shape-${shape.id}`);
          if (item) {
            if (inside) {
              item.setAttribute("data-active", "true");
            } else {
              item.removeAttribute("data-active");
            }
          }
        }
      }
      renderEditor();
    };

    const handleEditorDoubleClick = (event) => {
      if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
        finalizeActivePolyline({ commit: true });
        return;
      }
      const shapeTarget = event.target?.closest?.("[data-shape-id]");
      if (!shapeTarget) return;
      const shapeId = shapeTarget.getAttribute("data-shape-id");
      if (!shapeId) return;
      setSelectedShape(shapeId);
      openAssignmentModal(shapeId);
    };

    if (gestureSvg) {
      gestureSvg.addEventListener("pointerdown", handleEditorPointerDown);
      gestureSvg.addEventListener("pointermove", handleEditorPointerMove);
      gestureSvg.addEventListener("pointerup", handleEditorPointerUp);
      gestureSvg.addEventListener("pointerleave", handleEditorPointerLeave);
      gestureSvg.addEventListener("lostpointercapture", handleEditorPointerUp);
      gestureSvg.addEventListener("dblclick", handleEditorDoubleClick);
    }
    window.addEventListener("keydown", handleGlobalShortcut);
    window.addEventListener("keydown", handleEditorKeyDown);

    for (const [tool, button] of Object.entries(gestureToolButtons)) {
      button?.addEventListener("click", () => {
        if (editorState.mode === "perform") {
          setEditorMode("edit");
        }
        setEditorTool(tool);
      });
    }

    gestureModeToggle?.addEventListener("click", () => {
      const nextMode = editorState.mode === "perform" ? "edit" : "perform";
      setEditorMode(nextMode);
    });

    gestureClearBtn?.addEventListener("click", () => {
      editorState.shapes = [];
      clearActivePolylineState();
      setSelectedShape(null, { suppressRender: true });
      renderEditor();
      queuePersist();
    });
    assignmentStreamSelect?.addEventListener("change", () => {
      const streamId = assignmentStreamSelect.value || "pose";
      const currentLandmark = assignmentLandmarkSelect?.value || null;
      populateLandmarkOptions(streamId, currentLandmark, assignmentLandmarkSelect);
    });
    assignmentMidiTypeSelect?.addEventListener("change", () => {
      updateMidiControlsVisibility(assignmentMidiTypeSelect.value, modalMidiContext);
    });
    assignmentMidiPortSelect?.addEventListener("change", () => {
      if (isSyncingConfig) return;
      const value = assignmentMidiPortSelect.value || "broadcast";
      updateEditorConfig({ midiPort: value });
    });
    assignmentMidiPortRefreshBtn?.addEventListener("click", () => {
      refreshMidiPortOptions();
    });
    assignmentCloseBtn?.addEventListener("click", closeAssignmentModal);
    assignmentCancelBtn?.addEventListener("click", closeAssignmentModal);
    assignmentBackdrop?.addEventListener("click", closeAssignmentModal);
    assignmentApplyBtn?.addEventListener("click", applyAssignmentModal);
    assignmentModal?.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        event.preventDefault();
        closeAssignmentModal();
      }
    });
    editorToggleBtn?.addEventListener("click", toggleEditorVisibility);
    panelTabs.forEach((button) => {
      button.addEventListener("click", () => {
        const tabId = button.dataset.panelTab || "streams";
        setActivePanelTab(tabId);
      });
    });
    editorShapeList?.addEventListener("click", (event) => {
      const target = event.target?.closest("button[data-shape-id]");
      if (!target) return;
      const shapeId = target.getAttribute("data-shape-id");
      if (!shapeId) return;
      setSelectedShape(shapeId);
    });
    editorShapeList?.addEventListener("keydown", (event) => {
      const key = event.key?.toLowerCase();
      if (key !== "enter" && key !== " ") return;
      const target = event.target?.closest("button[data-shape-id]");
      if (!target) return;
      event.preventDefault();
      const shapeId = target.getAttribute("data-shape-id");
      if (!shapeId) return;
      setSelectedShape(shapeId);
    });
    editorStreamSelect?.addEventListener("change", () => {
      if (isSyncingEditorForm) return;
      const shape = findShapeById(editorState.selectedId);
      if (!shape) return;
      const stream = editorStreamSelect.value || "pose";
      const interaction = mergeInteraction(shape.interaction);
      const nextLandmark = populateLandmarkOptions(stream, interaction.landmark, editorLandmarkSelect) || interaction.landmark;
      mutateSelectedShape((target) => {
        target.interaction = {
          ...interaction,
          stream,
          landmark: nextLandmark
        };
      }, { skipRender: true });
    });
    editorLandmarkSelect?.addEventListener("change", () => {
      if (isSyncingEditorForm) return;
      const landmark = editorLandmarkSelect.value || "";
      mutateSelectedShape((target) => {
        const interaction = mergeInteraction(target.interaction);
        interaction.landmark = landmark;
        target.interaction = interaction;
      }, { skipRender: true });
    });
    editorTriggerSelect?.addEventListener("change", () => {
      if (isSyncingEditorForm) return;
      const trigger = editorTriggerSelect.value || "enter";
      mutateSelectedShape((target) => {
        const interaction = mergeInteraction(target.interaction);
        interaction.trigger = trigger;
        target.interaction = interaction;
      }, { skipRender: true });
    });
    editorMidiTypeSelect?.addEventListener("change", () => {
      if (isSyncingEditorForm) return;
      const midiType = editorMidiTypeSelect.value || "none";
      updateMidiControlsVisibility(midiType, editorMidiContext);
      mutateSelectedShape((target) => {
        const interaction = mergeInteraction(target.interaction);
        interaction.midi.type = midiType;
        target.interaction = interaction;
      }, { skipRender: true });
    });
    editorMidiPortSelect?.addEventListener("change", () => {
      if (isSyncingConfig) return;
      const value = editorMidiPortSelect.value || "broadcast";
      updateEditorConfig({ midiPort: value });
    });
    editorMidiPortRefreshBtn?.addEventListener("click", () => {
      refreshMidiPortOptions();
    });
    const bindMidiNumberInput = (input, min, max, property) => {
      if (!input) return;
      input.addEventListener("input", () => {
        if (isSyncingEditorForm) return;
        const parsed = parseInt(input.value ?? "", 10);
        const clamped = clampRange(Number.isFinite(parsed) ? parsed : min, min, max);
        if (!Number.isFinite(parsed) || parsed !== clamped) {
          input.value = clamped;
        }
        mutateSelectedShape((target) => {
          const interaction = mergeInteraction(target.interaction);
          interaction.midi[property] = clamped;
          target.interaction = interaction;
        }, { skipRender: true });
      });
    };
    bindMidiNumberInput(editorMidiChannelInput, 1, 16, "channel");
    bindMidiNumberInput(editorMidiNoteInput, 0, 127, "note");
    bindMidiNumberInput(editorMidiVelocityInput, 0, 127, "velocity");
    bindMidiNumberInput(editorMidiCcInput, 0, 127, "cc");
    bindMidiNumberInput(editorMidiCcValueInput, 0, 127, "value");
    const bindOscInput = (input, property) => {
      if (!input) return;
      input.addEventListener("input", () => {
        if (isSyncingEditorForm) return;
        let nextValue = input.value ?? "";
        if (property === "address" || property === "host") {
          nextValue = nextValue.trim();
          if (property === "host" && !nextValue) {
            nextValue = "127.0.0.1";
            input.value = nextValue;
          }
        } else if (property === "port") {
          const parsed = clampRange(parseInt(nextValue, 10) || 9000, 1, 65535);
          if (String(parsed) !== nextValue) {
            input.value = parsed;
          }
          nextValue = parsed;
        }
        mutateSelectedShape((target) => {
          const interaction = mergeInteraction(target.interaction);
          interaction.osc[property] = nextValue;
          target.interaction = interaction;
        }, { skipRender: true });
      });
    };
    bindOscInput(editorOscAddressInput, "address");
    bindOscInput(editorOscArgsInput, "args");
    const bindGlobalOscConfigInput = (input, key) => {
      if (!input) return;
      input.addEventListener("input", () => {
        if (isSyncingConfig) return;
        let value = input.value ?? "";
        if (key === "oscHost") {
          value = value.trim() || DEFAULT_EDITOR_CONFIG.oscHost;
          input.value = value;
        } else if (key === "oscPort") {
          const parsed = clampRange(parseInt(value, 10) || DEFAULT_EDITOR_CONFIG.oscPort, 1, 65535);
          value = parsed;
          if (String(parsed) !== input.value) {
            input.value = parsed;
          }
        }
        updateEditorConfig({ [key]: value });
      });
    };
    bindGlobalOscConfigInput(assignmentOscHostInput, "oscHost");
    bindGlobalOscConfigInput(editorOscHostInput, "oscHost");
    bindGlobalOscConfigInput(assignmentOscPortInput, "oscPort");
    bindGlobalOscConfigInput(editorOscPortInput, "oscPort");
    editorDeleteShapeBtn?.addEventListener("click", () => {
      deleteSelectedShape();
    });
    editorOpenModalBtn?.addEventListener("click", () => {
      if (editorState.selectedId) {
        openAssignmentModal(editorState.selectedId);
      }
    });

    loadEditorConfig();
    setEditorViewport(DEFAULT_WIDTH, DEFAULT_HEIGHT);
    setEditorVisibility(editorState.isVisible);
    applyGlobalConnectionConfig();
    refreshMidiPortOptions();
    loadPersistedShapes();
    setEditorMode(editorState.mode);
    setEditorTool(editorState.tool);
    setActivePanelTab(activePanelTab);
    populateLandmarkOptions("pose", "left_wrist", assignmentLandmarkSelect);
    populateLandmarkOptions("pose", "left_wrist", editorLandmarkSelect);
    updateMidiControlsVisibility(assignmentMidiTypeSelect?.value || "none", modalMidiContext);
    updateMidiControlsVisibility(editorMidiTypeSelect?.value || "none", editorMidiContext);
    syncEditorDetailForm();
    renderEditor();
    updateOverlayState();

    const setCanvasDimensions = (p, width, height) => {
      const nextWidth = width || DEFAULT_WIDTH;
      const nextHeight = height || DEFAULT_HEIGHT;
      if (canvasWidth !== nextWidth || canvasHeight !== nextHeight) {
        canvasWidth = nextWidth;
        canvasHeight = nextHeight;
        p.resizeCanvas(canvasWidth, canvasHeight);
        setEditorViewport(canvasWidth, canvasHeight);
        renderEditor();
      }
    };

    const clampDepth = (value) => Math.max(-0.8, Math.min(0.8, value || 0));

    const hexToRgb = (hex) => {
      const normalized = hex.replace("#", "");
      const bigint = parseInt(normalized, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    };

    const interpolateColor = (fromHex, toHex, t) => {
      const from = hexToRgb(fromHex);
      const to = hexToRgb(toHex);
      const mix = (start, end) => Math.round(start + (end - start) * t);
      return `rgb(${mix(from.r, to.r)}, ${mix(from.g, to.g)}, ${mix(from.b, to.b)})`;
    };

    const depthStyle = (value) => {
      const clamped = clampDepth(value);
      const magnitude = Math.abs(clamped) / 0.8;
      const pivotProximity = 1 - magnitude;
      const pivotShrink = Math.pow(pivotProximity, 3);
      const baseSize = 2.5 + pivotShrink * 2.5;
      const size = baseSize + magnitude * 58;
      const pivotColor = "#a855f7";
      const farColor = "#ff4d4f";
      const nearColor = "#3b82f6";
      const color = clamped >= 0
        ? interpolateColor(pivotColor, farColor, magnitude)
        : interpolateColor(pivotColor, nearColor, magnitude);
      return { color, size };
    };

    const drawLandmarks = (p, results) => {
      if (!results) return;
      const { poseLandmarks, leftHandLandmarks, rightHandLandmarks, faceLandmarks } = results;

      const drawConnectorSet = (landmarks, connections, color, weight) => {
        p.stroke(color);
        p.strokeWeight(weight);
        for (let i = 0; i < connections.length; i++) {
          const [startIndex, endIndex] = connections[i];
          const start = landmarks[startIndex];
          const end = landmarks[endIndex];
          if (!start || !end) continue;
          p.line(start.x * canvasWidth, start.y * canvasHeight, end.x * canvasWidth, end.y * canvasHeight);
        }
      };

      const drawLandmarkPoints = (landmarks, color, size = 6) => {
        p.fill(color);
        p.noStroke();
        for (const lm of landmarks) {
          p.circle(lm.x * canvasWidth, lm.y * canvasHeight, size);
        }
      };

      if (overlayState.pose?.main && poseLandmarks) {
        drawConnectorSet(poseLandmarks, SAFE_POSE_CONNECTIONS, "#4cc9f0", 3);
        drawLandmarkPoints(poseLandmarks, "rgba(76, 201, 240, 0.7)", 5);
      }
      if (overlayState.leftHand?.main && leftHandLandmarks) {
        drawConnectorSet(leftHandLandmarks, SAFE_HAND_CONNECTIONS, "#ff7096", 2.5);
        drawLandmarkPoints(leftHandLandmarks, "rgba(255, 112, 150, 0.9)", 4);
      }
      if (overlayState.rightHand?.main && rightHandLandmarks) {
        drawConnectorSet(rightHandLandmarks, SAFE_HAND_CONNECTIONS, "#ff8fa3", 2.5);
        drawLandmarkPoints(rightHandLandmarks, "rgba(255, 143, 163, 0.9)", 4);
      }
      if (overlayState.face?.main && faceLandmarks) {
        p.noFill();
        p.stroke("#f9c74f");
        p.strokeWeight(1.2);
        if (SAFE_FACEMESH_TESSELATION.length) {
          for (let i = 0; i < SAFE_FACEMESH_TESSELATION.length; i++) {
            const [startIndex, endIndex] = SAFE_FACEMESH_TESSELATION[i];
            const start = faceLandmarks[startIndex];
            const end = faceLandmarks[endIndex];
            if (!start || !end) continue;
            p.line(start.x * canvasWidth, start.y * canvasHeight, end.x * canvasWidth, end.y * canvasHeight);
          }
        } else {
          drawLandmarkPoints(faceLandmarks, "rgba(249, 199, 79, 0.8)", 3);
        }
      }
      if (overlayState.depth?.main && poseLandmarks) {
        p.noStroke();
        for (const lm of poseLandmarks) {
          const { color, size } = depthStyle(lm.z ?? 0);
          p.fill(color);
          p.drawingContext.save();
          p.drawingContext.globalAlpha = 0.5;
          p.circle(lm.x * canvasWidth, lm.y * canvasHeight, size);
          p.drawingContext.restore();
        }
      }
    };

    const drawPerformanceOverlay = (p) => {
      const fpsText = Number.isFinite(performanceMetrics.fps) && performanceMetrics.fps > 0
        ? performanceMetrics.fps.toFixed(1)
        : "--";
      const frameText = Number.isFinite(performanceMetrics.frameMs) && performanceMetrics.frameMs > 0
        ? performanceMetrics.frameMs.toFixed(1)
        : "--";
      const inferenceText = Number.isFinite(performanceMetrics.inferenceMs) && performanceMetrics.inferenceMs > 0
        ? performanceMetrics.inferenceMs.toFixed(1)
        : "--";
      const lines = [
        `FPS: ${fpsText}`,
        `Frame: ${frameText} ms`,
        `Inference: ${inferenceText} ms`,
        `Source: ${performanceMetrics.source}`
      ];
      const padding = 16;
      const boxWidth = 240;
      const lineHeight = 20;
      const boxHeight = padding * 1.5 + lines.length * lineHeight;
      p.push();
      p.noStroke();
      p.fill(10, 14, 24, 220);
      p.rect(padding, padding, boxWidth, boxHeight, 12);
      p.fill(245, 247, 255);
      p.textSize(15);
      p.textAlign(p.LEFT, p.TOP);
      lines.forEach((line, index) => {
        p.text(line, padding + 12, padding + 10 + index * lineHeight);
      });
      p.pop();
    };

const drawSegmentation = (p) => {
  if (!overlayState.segmentation?.main || !segmentationMaskAvailable || !segmentationTintCanvas.width) {
    return;
  }
  const ctx = p.drawingContext;
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.drawImage(segmentationTintCanvas, 0, 0, canvasWidth, canvasHeight);
  ctx.restore();
};

    p5Instance = new p5((p) => {
      p.setup = () => {
        const canvas = p.createCanvas(DEFAULT_WIDTH, DEFAULT_HEIGHT);
        canvas.parent(sketchContainer);
        p.background(4, 7, 13);
        p.noStroke();
      };

      p.draw = () => {
        const now = performance.now();
        const delta = now - lastFrameTimestamp;
        lastFrameTimestamp = now;
        if (delta > 0 && delta < 1000) {
          const instantFps = 1000 / delta;
          smoothedFps = smoothedFps ? smoothedFps * 0.9 + instantFps * 0.1 : instantFps;
          smoothedFrameMs = smoothedFrameMs ? smoothedFrameMs * 0.9 + delta * 0.1 : delta;
          performanceMetrics.fps = smoothedFps;
          performanceMetrics.frameMs = smoothedFrameMs;
        }
        performanceMetrics.source = currentSource;

        const videoWidth = videoEl.videoWidth || DEFAULT_WIDTH;
        const videoHeight = videoEl.videoHeight || DEFAULT_HEIGHT;

        if (!videoWidth || !videoHeight) {
          drawPreviewCanvas();
          return;
        }

        if (p.width !== videoWidth || p.height !== videoHeight) {
          p.resizeCanvas(videoWidth, videoHeight);
        }
        setCanvasDimensions(p, videoWidth, videoHeight);

        p.canvas.style.width = "auto";
        p.canvas.style.height = "auto";
        p.canvas.style.maxWidth = "100%";
        p.canvas.style.maxHeight = "100%";

        p.push();
        if (overlayState.mirror && currentSource === "camera") {
          p.translate(canvasWidth, 0);
          p.scale(-1, 1);
        }

        p.background(4, 7, 13, overlayState.underlay?.main ? 180 : 255);

        if (overlayState.underlay?.main && videoEl.readyState >= 2) {
          const ctx = p.drawingContext;
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.drawImage(videoEl, 0, 0, canvasWidth, canvasHeight);
          ctx.restore();
        }

        drawSegmentation(p);
        drawLandmarks(p, latestResults);

        p.pop();

        if (overlayState.performance?.main) {
          drawPerformanceOverlay(p);
        }

        drawPreviewCanvas();
      };
    });

    (async () => {
      try {
        applyStatus("Requesting camera…");
        await startCamera();
      } catch (err) {
        console.warn("Camera unavailable, falling back to sample video.", err);
        applyStatus("Camera blocked — using sample video");
        await startSampleVideo();
      }
    })();
  </script>
</body>
</html>
