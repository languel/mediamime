<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mediamime · Holistic Preview</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
</head>
<body>
  <main class="preview-layout">
    <section class="preview-canvas">
      <div id="mediamime-sketch"></div>
      <div id="gesture-editor" class="gesture-editor" aria-label="Interactive score editor">
        <div id="gesture-toolbar" class="gesture-editor-toolbar" role="toolbar" aria-label="Editor tools">
          <button id="gesture-tool-select" class="is-active" type="button" data-tool="select" title="Select (V)" aria-label="Select (V)">
            <span class="material-icons-outlined" aria-hidden="true">near_me</span>
          </button>
          <button id="gesture-tool-hand" type="button" data-tool="hand" title="Pan (H)" aria-label="Pan (H)">
            <span class="material-icons-outlined" aria-hidden="true">pan_tool_alt</span>
          </button>
          <button id="gesture-tool-freehand" type="button" data-tool="freehand" title="Freehand (D)" aria-label="Freehand (D)">
            <span class="material-icons-outlined" aria-hidden="true">gesture</span>
          </button>
          <button id="gesture-tool-line" type="button" data-tool="line" title="Line (L)" aria-label="Line (L)">
            <span class="material-icons-outlined" aria-hidden="true">timeline</span>
          </button>
          <button id="gesture-tool-rect" type="button" data-tool="rect" title="Rectangle (R)" aria-label="Rectangle (R)">
            <span class="material-icons-outlined" aria-hidden="true">crop_square</span>
          </button>
          <button id="gesture-tool-ellipse" type="button" data-tool="ellipse" title="Oval (O)" aria-label="Oval (O)">
            <span class="material-icons-outlined" aria-hidden="true">radio_button_unchecked</span>
          </button>
          <button id="gesture-tool-eraser" type="button" data-tool="eraser" title="Eraser (E)" aria-label="Eraser (E)">
            <span class="material-symbols-outlined" aria-hidden="true">ink_eraser</span>
          </button>
          <div class="toolbar-divider" aria-hidden="true"></div>
          <button id="gesture-mode-toggle" type="button" title="Toggle perform mode" aria-label="Toggle perform mode">
            <span class="material-icons-outlined" aria-hidden="true">play_circle</span>
          </button>
          <button id="gesture-clear" type="button" title="Clear all shapes" aria-label="Clear all shapes">
            <span class="material-icons-outlined" aria-hidden="true">delete_sweep</span>
          </button>
        </div>
        <div class="gesture-svg-wrapper">
          <svg id="gesture-svg" class="gesture-svg" tabindex="0" role="presentation" aria-label="Score canvas" viewBox="0 0 1280 720" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
      </div>
      <video id="mediamime-video" muted></video>
    </section>
        <div id="modal-layer" class="floating-modal-layer">
      <section id="modal-input" class="panel floating-modal is-open" role="dialog" aria-modal="false" aria-label="Input panel" data-modal="input" data-resizable="true" tabindex="-1">
        <div class="modal-chrome">
          <div class="modal-handle" data-modal-handle aria-label="Move Input panel" tabindex="0">
            <span class="material-icons-outlined" aria-hidden="true">drag_indicator</span>
          </div>
          <div class="panel-actions">
            <button type="button" class="icon-button panel-close" data-modal-close="input" title="Hide Input panel" aria-label="Hide Input panel">
              <span class="material-icons-outlined" aria-hidden="true">close</span>
            </button>
          </div>
        </div>
        <div class="floating-modal-body">
          <div class="stream-controls">
            <label class="stream-toggle" title="Mirror camera">
              <input type="checkbox" id="mediamime-mirror" checked aria-label="Mirror camera">
              <span class="material-icons-outlined" aria-hidden="true">flip_camera_android</span>
            </label>
            <button id="mediamime-toggle-source" class="icon-button" title="Toggle media source" aria-label="Toggle media source">
              <span class="material-icons-outlined" aria-hidden="true">switch_video</span>
            </button>
          </div>
        </div>
      </section>
      <section id="modal-layers" class="panel floating-modal is-open" role="dialog" aria-modal="false" aria-label="Layers panel" data-modal="layers" tabindex="-1">
        <div class="modal-chrome">
          <div class="modal-handle" data-modal-handle aria-label="Move Layers panel" tabindex="0">
            <span class="material-icons-outlined" aria-hidden="true">drag_indicator</span>
          </div>
          <div class="panel-actions">
            <button id="mediamime-reset" class="icon-button" title="Reset overlays" aria-label="Reset overlays">
              <span class="material-icons-outlined" aria-hidden="true">refresh</span>
            </button>
            <button type="button" class="icon-button panel-close" data-modal-close="layers" title="Hide Layers panel" aria-label="Hide Layers panel">
              <span class="material-icons-outlined" aria-hidden="true">close</span>
            </button>
          </div>
        </div>
        <div class="panel-content">
          <div class="panel-section is-active" data-panel-section="streams" id="panel-streams" role="tabpanel" aria-label="Stream controls">
            <div class="background-opacity-control">
              <label for="background-opacity">Background opacity</label>
              <div class="background-opacity-input">
                <input type="range" id="background-opacity" min="0" max="1" step="0.05" value="1">
                <span id="background-opacity-value">100%</span>
              </div>
            </div>
            <div class="stream-option-row">
              <label for="toggle-trails">
                <input type="checkbox" id="toggle-trails">
                <span>Persistent trails</span>
              </label>
            </div>
            <div class="overlay-table-wrapper">
              <table class="overlay-table">
                <thead>
                  <tr>
                    <th scope="col">Stream</th>
                    <th scope="col">Main</th>
                    <th scope="col">Preview</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th scope="row">Source</th>
                    <td>
                      <label class="overlay-switch" title="Source main">
                        <input type="checkbox" id="overlay-underlay-main" checked aria-label="Source main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Source preview">
                        <input type="checkbox" id="overlay-underlay-preview" aria-label="Source preview">
                      </label>
                    </td>
                  </tr>
                  <tr>
                    <th scope="row">Pose</th>
                    <td>
                      <label class="overlay-switch" title="Pose main">
                        <input type="checkbox" id="overlay-pose-main" checked aria-label="Pose main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Pose preview">
                        <input type="checkbox" id="overlay-pose-preview" aria-label="Pose preview">
                      </label>
                    </td>
                  </tr>
                  <tr>
                    <th scope="row">Left hand</th>
                    <td>
                      <label class="overlay-switch" title="Left hand main">
                        <input type="checkbox" id="overlay-left-hand-main" checked aria-label="Left hand main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Left hand preview">
                        <input type="checkbox" id="overlay-left-hand-preview" aria-label="Left hand preview">
                      </label>
                    </td>
                  </tr>
                  <tr>
                    <th scope="row">Right hand</th>
                    <td>
                      <label class="overlay-switch" title="Right hand main">
                        <input type="checkbox" id="overlay-right-hand-main" checked aria-label="Right hand main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Right hand preview">
                        <input type="checkbox" id="overlay-right-hand-preview" aria-label="Right hand preview">
                      </label>
                    </td>
                  </tr>
                  <tr>
                    <th scope="row">Face</th>
                    <td>
                      <label class="overlay-switch" title="Face main">
                        <input type="checkbox" id="overlay-face-main" checked aria-label="Face main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Face preview">
                        <input type="checkbox" id="overlay-face-preview" aria-label="Face preview">
                      </label>
                    </td>
                  </tr>
                  <tr>
                    <th scope="row">Segmentation</th>
                    <td>
                      <label class="overlay-switch" title="Segmentation main">
                        <input type="checkbox" id="overlay-segmentation-main" aria-label="Segmentation main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Segmentation preview">
                        <input type="checkbox" id="overlay-segmentation-preview" checked aria-label="Segmentation preview">
                      </label>
                    </td>
                  </tr>
                  <tr>
                    <th scope="row">Depth</th>
                    <td>
                      <label class="overlay-switch" title="Depth main">
                        <input type="checkbox" id="overlay-depth-main" aria-label="Depth main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Depth preview">
                        <input type="checkbox" id="overlay-depth-preview" checked aria-label="Depth preview">
                      </label>
                    </td>
                  </tr>
                  <tr>
                    <th scope="row">Performance</th>
                    <td>
                      <label class="overlay-switch" title="Performance main">
                        <input type="checkbox" id="overlay-performance-main" aria-label="Performance main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Performance preview">
                        <input type="checkbox" id="overlay-performance-preview" checked aria-label="Performance preview">
                      </label>
                    </td>
                  </tr>
                  <tr>
                    <th scope="row">Score</th>
                    <td>
                      <label class="overlay-switch" title="Score main">
                        <input type="checkbox" id="overlay-score-main" checked aria-label="Score main">
                      </label>
                    </td>
                    <td>
                      <label class="overlay-switch" title="Score preview">
                        <input type="checkbox" id="overlay-score-preview" checked aria-label="Score preview">
                      </label>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="panel-footnote">
              <span id="mediamime-status" class="status-chip">Initializing…</span>
              <div class="tip">
                Toggle Main overlays to affect the canvas, and use Preview toggles to stage diagnostics or capture snapshots.
              </div>
            </div>
            </div>
          </div>
      </section>
      <section id="modal-map" class="panel floating-modal is-open" role="dialog" aria-modal="false" aria-label="Map panel" data-modal="map" tabindex="-1">
        <div class="modal-chrome">
          <div class="modal-handle" data-modal-handle aria-label="Move Map panel" tabindex="0">
            <span class="material-icons-outlined" aria-hidden="true">drag_indicator</span>
          </div>
          <div class="panel-actions">
            <button type="button" class="icon-button panel-close" data-modal-close="map" title="Hide Map panel" aria-label="Hide Map panel">
              <span class="material-icons-outlined" aria-hidden="true">close</span>
            </button>
          </div>
        </div>
        <div class="panel-content">
            <div class="panel-section is-active" data-panel-section="editor" id="panel-editor" role="tabpanel" aria-label="Score editor">
              <div class="panel-routing" aria-label="Global routing settings">
                <div class="panel-routing-row">
                  <label for="editor-midi-port">MIDI Port</label>
                  <div class="input-with-button">
                    <select id="editor-midi-port">
                      <option value="broadcast">All Outputs</option>
                    </select>
                    <button id="editor-midi-port-refresh" type="button" class="icon-button" title="Refresh MIDI ports" aria-label="Refresh MIDI ports">
                      <span class="material-icons-outlined" aria-hidden="true">refresh</span>
                    </button>
                  </div>
                </div>
                <div class="panel-routing-actions">
                  <button id="snapshot-export" type="button" class="icon-button" title="Export snapshot" aria-label="Export snapshot">
                    <span class="material-icons-outlined" aria-hidden="true">download</span>
                  </button>
                  <button id="snapshot-import" type="button" class="icon-button" title="Import snapshot" aria-label="Import snapshot">
                    <span class="material-icons-outlined" aria-hidden="true">upload</span>
                  </button>
                </div>
              </div>
              <input id="snapshot-import-input" type="file" accept="application/json" hidden>
              <div class="editor-panel">
                <div class="editor-shape-list" id="editor-shape-list" role="listbox" aria-label="Score elements"></div>
                <div class="editor-detail" id="editor-detail">
                  <div class="editor-detail-empty" id="editor-detail-empty">
                    Draw a shape to begin. Select it to edit MIDI mappings.
                  </div>
                  <form id="editor-detail-form" class="editor-detail-form" autocomplete="off">
                    <div class="form-row">
                      <label for="editor-stream-select">Input Stream</label>
                      <select id="editor-stream-select">
                        <option value="pose">Pose Landmarks</option>
                        <option value="leftHand">Left Hand</option>
                        <option value="rightHand">Right Hand</option>
                        <option value="face">Face (centroid)</option>
                        <option value="pointer">Pointer Input</option>
                        <option value="keyboard">Keyboard</option>
                      </select>
                    </div>
                    <div class="form-row">
                      <label for="editor-landmark-select">Landmark</label>
                      <select id="editor-landmark-select"></select>
                    </div>
                    <div class="event-list-header">
                      <span>Events</span>
                      <button type="button" id="editor-add-event" class="icon-button" title="Add event" aria-label="Add event">
                        <span class="material-icons-outlined" aria-hidden="true">add</span>
                      </button>
                    </div>
                    <div id="editor-event-list" class="event-list" role="list"></div>
                    <p class="event-hint">
                      Velocity and CC values can follow constant or normalised sources (X, Y, distance).
                    </p>
                    <div class="editor-detail-actions">
                      <button type="button" id="editor-open-modal" class="secondary">Pop-out editor</button>
                      <button type="button" id="editor-delete-shape" class="danger">Delete shape</button>
                    </div>
                  </form>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section id="modal-preview" class="panel floating-modal is-open" role="dialog" aria-modal="false" aria-label="Preview panel" data-modal="preview" data-resizable="true" tabindex="-1">
        <div class="modal-chrome">
          <div class="modal-handle" data-modal-handle aria-label="Move Preview panel" tabindex="0">
            <span class="material-icons-outlined" aria-hidden="true">drag_indicator</span>
          </div>
          <div class="panel-actions">
            <button type="button" class="icon-button panel-close" data-modal-close="preview" title="Hide Preview panel" aria-label="Hide Preview panel">
              <span class="material-icons-outlined" aria-hidden="true">close</span>
            </button>
          </div>
        </div>
        <div class="floating-modal-body">
          <div class="segment-preview" aria-hidden="false">
            <canvas id="segmentation-preview" width="320" height="180"></canvas>
          </div>
        </div>
      </section>
    </div>
  </main>
  <div id="assignment-backdrop" class="modal-backdrop" aria-hidden="true"></div>
  <div id="assignment-modal" class="assignment-modal" role="dialog" aria-modal="true" aria-labelledby="assignment-modal-title" aria-hidden="true">
    <header>
      <h3 id="assignment-modal-title">Interaction Mapping</h3>
      <button id="assignment-modal-close" class="icon-button" type="button" title="Close">
        <span class="material-icons-outlined" aria-hidden="true">close</span>
      </button>
    </header>
    <section class="form-group">
      <label for="assignment-stream">Input Stream</label>
      <select id="assignment-stream">
        <option value="pose">Pose Landmarks</option>
        <option value="leftHand">Left Hand</option>
        <option value="rightHand">Right Hand</option>
        <option value="face">Face (centroid)</option>
        <option value="pointer">Pointer Input</option>
        <option value="keyboard">Keyboard</option>
      </select>
    </section>
    <section class="form-group">
      <label for="assignment-landmark">Landmark</label>
      <select id="assignment-landmark"></select>
    </section>
    <section class="form-group">
      <label>MIDI Port</label>
      <div class="input-with-button">
        <select id="assignment-midi-port">
          <option value="broadcast">All Outputs</option>
        </select>
        <button id="assignment-midi-port-refresh" type="button" class="icon-button" title="Refresh MIDI ports" aria-label="Refresh MIDI ports">
          <span class="material-icons-outlined" aria-hidden="true">refresh</span>
        </button>
      </div>
    </section>
    <section class="form-group event-list-modal">
      <div class="event-list-header">
        <span>Events</span>
        <button type="button" id="assignment-add-event" class="icon-button" title="Add event" aria-label="Add event">
          <span class="material-icons-outlined" aria-hidden="true">add</span>
        </button>
      </div>
      <div id="assignment-event-list" class="event-list" role="list"></div>
    </section>
    <p class="event-hint">
      Use the stream point to trigger multiple MIDI actions. Value sources can be constant or normalised (X, Y, distance).
    </p>
    <div class="modal-actions">
      <button id="assignment-modal-cancel" class="secondary" type="button">Cancel</button>
      <button id="assignment-modal-apply" type="button">Apply</button>
    </div>
  </div>

  <script type="module">
const SAMPLE_VIDEO_URL = "https://thefoxofsky.github.io/project_pages/RealisDance-DiT/video/mv/2.mp4";
// const SAMPLE_VIDEO_URL = "https://thefoxofsky.github.io/project_pages/RealisDance-DiT/video/v/0003.mp4";
// const SAMPLE_VIDEO_URL = "https://thefoxofsky.github.io/project_pages/RealisDance-DiT/video/mv/4.mp4";
// const SAMPLE_VIDEO_URL= "https://media.gettyimages.com/id/1432864804/video/a-man-and-a-woman-dance-outdoors-in-preparation-for-a-performance-healthy-lifestyle.mp4?s=mp4-640x640-gi&k=20&c=QenL_gqhEWh665fqtFCuOXsZCdf-EgTSK2JCf_XnPLM=";
// const SAMPLE_VIDEO_URL = "https://media.gettyimages.com/id/1481811636/video/for-us-dance-is-a-way-of-life.mp4?s=mp4-640x640-gi&k=20&c=-eEh1Svdu4dKJCEXijI7d4WOfGWVtAe9Gv_5mmqJYQA=";

    const videoEl = document.getElementById("mediamime-video");
    const sketchContainer = document.getElementById("mediamime-sketch");
    const statusLabel = document.getElementById("mediamime-status");
    const toggleSourceBtn = document.getElementById("mediamime-toggle-source");
    const resetBtn = document.getElementById("mediamime-reset");
    const mirrorCheckbox = document.getElementById("mediamime-mirror");
    const overlayControls = {
      underlay: {
        main: document.getElementById("overlay-underlay-main"),
        preview: document.getElementById("overlay-underlay-preview")
      },
      pose: {
        main: document.getElementById("overlay-pose-main"),
        preview: document.getElementById("overlay-pose-preview")
      },
      leftHand: {
        main: document.getElementById("overlay-left-hand-main"),
        preview: document.getElementById("overlay-left-hand-preview")
      },
      rightHand: {
        main: document.getElementById("overlay-right-hand-main"),
        preview: document.getElementById("overlay-right-hand-preview")
      },
      face: {
        main: document.getElementById("overlay-face-main"),
        preview: document.getElementById("overlay-face-preview")
      },
      segmentation: {
        main: document.getElementById("overlay-segmentation-main"),
        preview: document.getElementById("overlay-segmentation-preview")
      },
      depth: {
        main: document.getElementById("overlay-depth-main"),
        preview: document.getElementById("overlay-depth-preview")
      },
      performance: {
        main: document.getElementById("overlay-performance-main"),
        preview: document.getElementById("overlay-performance-preview")
      },
      score: {
        main: document.getElementById("overlay-score-main"),
        preview: document.getElementById("overlay-score-preview")
      }
    };
    const modalElements = Array.from(document.querySelectorAll(".floating-modal[data-modal]"));
    const modalState = new Map();
    const modalStateListeners = [];
    const modalShortcutMap = new Map([
      ["i", "input"],
      ["p", "preview"],
      ["l", "layers"],
      ["m", "map"]
    ]);
    const DEFAULT_MODAL_POSITIONS = {
      input: { top: 16, align: "right" },
      layers: { top: 176, align: "right" },
      preview: { top: 336, align: "right" },
      map: { top: 496, align: "right" }
    };
    const MODAL_MARGIN = 0;
    const MODAL_LAYOUT_KEY = "mediamime:modal-layout";
    const loadModalLayout = () => {
      if (typeof localStorage === "undefined") return {};
      try {
        const raw = localStorage.getItem(MODAL_LAYOUT_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : {};
      } catch (err) {
        console.warn("Failed to load modal layout", err);
        return {};
      }
    };
    const modalLayout = loadModalLayout();
    const persistModalLayout = () => {
      if (typeof localStorage === "undefined") return;
      try {
        localStorage.setItem(MODAL_LAYOUT_KEY, JSON.stringify(modalLayout));
      } catch (err) {
        console.warn("Failed to persist modal layout", err);
      }
    };
    const updateModalLayout = (id, changes = {}) => {
      if (!id) return;
      const current = modalLayout[id] || {};
      modalLayout[id] = { ...current, ...changes };
      persistModalLayout();
    };
    const onModalStateChange = (listener) => {
      if (typeof listener === "function") {
        modalStateListeners.push(listener);
      }
    };
const getModalById = (id) => modalElements.find((modal) => modal.dataset.modal === id);
const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
let modalZIndexSeed = 500;
let lastActiveModalId = null;

const ensureModalInViewport = (modal) => {
  if (!modal) return;
  let rect = modal.getBoundingClientRect();
  if (modal.dataset.resizable === "true") {
    const maxWidth = Math.max(240, window.innerWidth - 32);
    const maxHeight = Math.max(200, window.innerHeight - 32);
    if (rect.width > maxWidth) {
      modal.style.width = `${maxWidth}px`;
      rect = modal.getBoundingClientRect();
    }
    if (rect.height > maxHeight) {
      modal.style.height = `${maxHeight}px`;
      rect = modal.getBoundingClientRect();
    }
  }
  const maxLeft = Math.max(MODAL_MARGIN, window.innerWidth - rect.width - MODAL_MARGIN);
  const maxTop = Math.max(MODAL_MARGIN, window.innerHeight - rect.height - MODAL_MARGIN);
  modal.style.left = `${clamp(rect.left, MODAL_MARGIN, maxLeft)}px`;
  modal.style.top = `${clamp(rect.top, MODAL_MARGIN, maxTop)}px`;
  modal.style.right = "auto";
  modal.style.bottom = "auto";
};

const initializeModalPosition = (modal) => {
  if (!modal) return;
  const id = modal.dataset.modal;
  modal.style.right = "auto";
  modal.style.bottom = "auto";
  const saved = modalLayout[id] || {};
  if (modal.dataset.resizable === "true") {
    if (Number.isFinite(saved.width)) {
      modal.style.width = `${saved.width}px`;
    }
    if (Number.isFinite(saved.height)) {
      modal.style.height = `${saved.height}px`;
    }
  }
  if (Number.isFinite(saved.left)) {
    modal.style.left = `${saved.left}px`;
  }
  if (Number.isFinite(saved.top)) {
    modal.style.top = `${saved.top}px`;
  }

  const rect = modal.getBoundingClientRect();
  const defaults = DEFAULT_MODAL_POSITIONS[id];
  if (!Number.isFinite(saved.top) && defaults && typeof defaults.top === "number") {
    modal.style.top = `${defaults.top}px`;
  }
  if (!Number.isFinite(saved.left) && defaults) {
    if (defaults.align === "right") {
      const alignedLeft = Math.max(MODAL_MARGIN, window.innerWidth - rect.width - MODAL_MARGIN);
      modal.style.left = `${alignedLeft}px`;
    } else if (typeof defaults.left === "number") {
      modal.style.left = `${defaults.left}px`;
    }
  }

  ensureModalInViewport(modal);

  const appliedLeft = Number.parseFloat(modal.style.left);
  const appliedTop = Number.parseFloat(modal.style.top);
  if (!Number.isFinite(saved.left) || !Number.isFinite(saved.top)) {
    updateModalLayout(id, {
      left: Number.isFinite(appliedLeft) ? appliedLeft : MODAL_MARGIN,
      top: Number.isFinite(appliedTop) ? appliedTop : MODAL_MARGIN
    });
  } else {
    const updates = {};
    if (Number.isFinite(appliedLeft) && Math.abs(appliedLeft - saved.left) > 0.5) {
      updates.left = appliedLeft;
    }
    if (Number.isFinite(appliedTop) && Math.abs(appliedTop - saved.top) > 0.5) {
      updates.top = appliedTop;
    }
    if (Object.keys(updates).length) {
      updateModalLayout(id, updates);
    }
  }
  if (modal.dataset.resizable === "true") {
    const appliedWidth = Number.parseFloat(modal.style.width);
    const appliedHeight = Number.parseFloat(modal.style.height);
    if (!Number.isFinite(saved.width) && Number.isFinite(appliedWidth)) {
      updateModalLayout(id, { width: appliedWidth });
    }
    if (!Number.isFinite(saved.height) && Number.isFinite(appliedHeight)) {
      updateModalLayout(id, { height: appliedHeight });
    } else {
      const resizeUpdates = {};
      if (Number.isFinite(appliedWidth) && Number.isFinite(saved.width) && Math.abs(appliedWidth - saved.width) > 0.5) {
        resizeUpdates.width = appliedWidth;
      }
      if (Number.isFinite(appliedHeight) && Number.isFinite(saved.height) && Math.abs(appliedHeight - saved.height) > 0.5) {
        resizeUpdates.height = appliedHeight;
      }
      if (Object.keys(resizeUpdates).length) {
        updateModalLayout(id, resizeUpdates);
      }
    }
  }
};

const bringModalToFront = (modal) => {
  if (!modal) return;
  modalZIndexSeed += 1;
  modal.style.zIndex = modalZIndexSeed;
  const id = modal.dataset.modal;
  if (id) {
    lastActiveModalId = id;
  }
};

const isModalVisible = (id) => modalState.get(id) !== false;

const setModalVisibility = (id, open, { skipFocus } = {}) => {
  const modal = getModalById(id);
  if (!modal) return;
  const nextState = Boolean(open);
  modalState.set(id, nextState);
  modal.classList.toggle("is-hidden", !nextState);
  modal.setAttribute("aria-hidden", nextState ? "false" : "true");
  if (nextState) {
    initializeModalPosition(modal);
    bringModalToFront(modal);
    if (!skipFocus) {
      requestAnimationFrame(() => {
        try {
          modal.focus({ preventScroll: true });
        } catch (err) {
          modal.focus();
        }
      });
    }
  } else if (lastActiveModalId === id) {
    lastActiveModalId = null;
  }
  const layoutUpdates = { open: nextState };
  const leftValue = Number.parseFloat(modal.style.left);
  const topValue = Number.parseFloat(modal.style.top);
  const widthValue = Number.parseFloat(modal.style.width);
  const heightValue = Number.parseFloat(modal.style.height);
  if (Number.isFinite(leftValue)) layoutUpdates.left = leftValue;
  if (Number.isFinite(topValue)) layoutUpdates.top = topValue;
  if (modal.dataset.resizable === "true") {
    if (Number.isFinite(widthValue)) layoutUpdates.width = widthValue;
    if (Number.isFinite(heightValue)) layoutUpdates.height = heightValue;
  }
  updateModalLayout(id, layoutUpdates);
  modalStateListeners.forEach((listener) => {
    try {
      listener({ id, open: nextState, modal });
    } catch (err) {
      console.warn("Modal listener error", err);
    }
  });
};

const openModal = (id, options) => setModalVisibility(id, true, options);
const closeModal = (id, options) => setModalVisibility(id, false, options);
const toggleModal = (id, options) => setModalVisibility(id, !isModalVisible(id), options);
const isMapModalOpen = () => isModalVisible("map");

const attachModalDrag = (modal) => {
  const handle = modal?.querySelector("[data-modal-handle]");
  if (!modal || !handle) return;
  handle.addEventListener("pointerdown", (event) => {
    if (event.button !== 0) return;
    event.preventDefault();
    bringModalToFront(modal);
    handle.setPointerCapture(event.pointerId);
    const rect = modal.getBoundingClientRect();
    const offsetX = event.clientX - rect.left;
    const offsetY = event.clientY - rect.top;
    modal.style.right = "auto";
    modal.style.bottom = "auto";
    const handlePointerMove = (moveEvent) => {
      const maxLeft = Math.max(MODAL_MARGIN, window.innerWidth - rect.width - MODAL_MARGIN);
      const maxTop = Math.max(MODAL_MARGIN, window.innerHeight - rect.height - MODAL_MARGIN);
      modal.style.left = `${clamp(moveEvent.clientX - offsetX, MODAL_MARGIN, maxLeft)}px`;
      modal.style.top = `${clamp(moveEvent.clientY - offsetY, MODAL_MARGIN, maxTop)}px`;
    };
    const stopDrag = () => {
      handle.releasePointerCapture(event.pointerId);
      window.removeEventListener("pointermove", handlePointerMove);
      window.removeEventListener("pointerup", stopDrag);
      handle.removeEventListener("lostpointercapture", stopDrag);
      ensureModalInViewport(modal);
      const leftValue = Number.parseFloat(modal.style.left);
      const topValue = Number.parseFloat(modal.style.top);
      const updates = {};
      if (Number.isFinite(leftValue)) updates.left = leftValue;
      if (Number.isFinite(topValue)) updates.top = topValue;
      if (Object.keys(updates).length) {
        updateModalLayout(modal.dataset.modal, updates);
      }
    };
    window.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("pointerup", stopDrag, { once: true });
    handle.addEventListener("lostpointercapture", stopDrag);
  });
};

const detectResizeDirection = (x, y, rect, margin) => {
  const directions = [];
  if (x - rect.left <= margin) directions.push("w");
  else if (rect.right - x <= margin) directions.push("e");
  if (y - rect.top <= margin) directions.push("n");
  else if (rect.bottom - y <= margin) directions.push("s");
  return directions.length ? directions.join("") : null;
};

const cursorForDirection = (dir) => {
  switch (dir) {
    case "n":
    case "s":
      return "ns-resize";
    case "e":
    case "w":
      return "ew-resize";
    case "ne":
    case "en":
    case "sw":
    case "ws":
      return "nesw-resize";
    case "nw":
    case "wn":
    case "se":
    case "es":
      return "nwse-resize";
    default:
      return "";
  }
};

const attachModalResize = (modal) => {
  if (!modal || modal.dataset.resizable !== "true") return;
  const RESIZE_MARGIN = 14;
  let activeDirection = null;
  let resizeContext = null;

  const updateCursor = (event) => {
    if (resizeContext) return;
    if (event.target.closest("[data-modal-handle]") || event.target.closest(".panel-actions")) {
      modal.style.cursor = "";
      return;
    }
    const rect = modal.getBoundingClientRect();
    const direction = detectResizeDirection(event.clientX, event.clientY, rect, RESIZE_MARGIN);
    modal.style.cursor = cursorForDirection(direction) || "";
  };

  const finalizeResize = (event) => {
    if (!resizeContext) return;
    modal.releasePointerCapture(event.pointerId);
    modal.removeEventListener("pointermove", handlePointerMove);
    modal.removeEventListener("pointerup", finalizeResize);
    modal.removeEventListener("lostpointercapture", finalizeResize);
    ensureModalInViewport(modal);
    const updates = {};
    const leftValue = Number.parseFloat(modal.style.left);
    const topValue = Number.parseFloat(modal.style.top);
    const widthValue = Number.parseFloat(modal.style.width);
    const heightValue = Number.parseFloat(modal.style.height);
    if (Number.isFinite(leftValue)) updates.left = leftValue;
    if (Number.isFinite(topValue)) updates.top = topValue;
    if (Number.isFinite(widthValue)) updates.width = widthValue;
    if (Number.isFinite(heightValue)) updates.height = heightValue;
    updateModalLayout(modal.dataset.modal, updates);
    resizeContext = null;
    activeDirection = null;
    modal.style.cursor = "";
  };

  const handlePointerMove = (event) => {
    if (!resizeContext) return;
    const { startX, startY, startWidth, startHeight, startLeft, startTop, minWidth, minHeight } = resizeContext;
    const deltaX = event.clientX - startX;
    const deltaY = event.clientY - startY;
    if (activeDirection) {
      modal.style.cursor = cursorForDirection(activeDirection) || modal.style.cursor;
    }
    let nextWidth = startWidth;
    let nextHeight = startHeight;
    let nextLeft = startLeft;
    let nextTop = startTop;
    const maxWidth = Math.max(minWidth, window.innerWidth - 32);
    const maxHeight = Math.max(minHeight, window.innerHeight - 32);

    if (activeDirection.includes("e")) {
      nextWidth = clamp(startWidth + deltaX, minWidth, maxWidth);
    }
    if (activeDirection.includes("s")) {
      nextHeight = clamp(startHeight + deltaY, minHeight, maxHeight);
    }
    if (activeDirection.includes("w")) {
      const proposed = clamp(startWidth - deltaX, minWidth, maxWidth);
      const deltaWidth = startWidth - proposed;
      nextWidth = proposed;
      nextLeft = clamp(startLeft + deltaWidth, MODAL_MARGIN, window.innerWidth - nextWidth - MODAL_MARGIN);
    }
    if (activeDirection.includes("n")) {
      const proposed = clamp(startHeight - deltaY, minHeight, maxHeight);
      const deltaHeight = startHeight - proposed;
      nextHeight = proposed;
      nextTop = clamp(startTop + deltaHeight, MODAL_MARGIN, window.innerHeight - nextHeight - MODAL_MARGIN);
    }

    modal.style.width = `${nextWidth}px`;
    modal.style.height = `${nextHeight}px`;
    modal.style.left = `${nextLeft}px`;
    modal.style.top = `${nextTop}px`;
  };

  modal.addEventListener("pointerdown", (event) => {
    if (event.button !== 0) return;
    if (event.target.closest("[data-modal-handle]")) return;
    if (event.target.closest(".panel-actions")) return;
    const rect = modal.getBoundingClientRect();
    const direction = detectResizeDirection(event.clientX, event.clientY, rect, RESIZE_MARGIN);
    if (!direction) return;
    event.preventDefault();
    bringModalToFront(modal);
    modal.style.right = "auto";
    modal.style.bottom = "auto";
    activeDirection = direction;
    resizeContext = {
      startX: event.clientX,
      startY: event.clientY,
      startWidth: rect.width,
      startHeight: rect.height,
      startLeft: rect.left,
      startTop: rect.top,
      minWidth: 220,
      minHeight: 160
    };
    modal.style.cursor = cursorForDirection(direction) || modal.style.cursor;
    modal.setPointerCapture(event.pointerId);
    modal.addEventListener("pointermove", handlePointerMove);
    modal.addEventListener("pointerup", finalizeResize, { once: true });
    modal.addEventListener("lostpointercapture", finalizeResize);
  });

  modal.addEventListener("mousemove", updateCursor);
  modal.addEventListener("mouseleave", () => {
    if (!resizeContext) {
      modal.style.cursor = "";
    }
  });
};

modalElements.forEach((modal) => {
  initializeModalPosition(modal);
  const id = modal.dataset.modal;
  const saved = modalLayout[id] || {};
  const open = saved.open ?? !modal.classList.contains("is-hidden");
  modalState.set(id, open);
  modal.classList.toggle("is-hidden", !open);
  modal.setAttribute("aria-hidden", open ? "false" : "true");
  if (open) {
    bringModalToFront(modal);
  }
  updateModalLayout(id, { open });
  modal.addEventListener("pointerdown", () => bringModalToFront(modal));
  attachModalDrag(modal);
  attachModalResize(modal);
});
lastActiveModalId = null;

document.querySelectorAll("[data-modal-close]").forEach((button) => {
  const targetId = button.dataset.modalClose;
  button.addEventListener("click", () => {
    if (targetId) {
      closeModal(targetId, { skipFocus: true });
    }
  });
});

document.addEventListener("keydown", (event) => {
  if ((event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey) {
    const key = event.key?.toLowerCase();
    const targetModal = modalShortcutMap.get(key);
    if (targetModal) {
      event.preventDefault();
      toggleModal(targetModal);
      return;
    }
  }
  if (event.key === "Escape" && !event.defaultPrevented && lastActiveModalId && isModalVisible(lastActiveModalId)) {
    event.preventDefault();
    closeModal(lastActiveModalId, { skipFocus: true });
  }
});

window.addEventListener("resize", () => {
  modalElements.forEach((modal) => {
    ensureModalInViewport(modal);
    const updates = {};
    const leftValue = Number.parseFloat(modal.style.left);
    const topValue = Number.parseFloat(modal.style.top);
    if (Number.isFinite(leftValue)) updates.left = leftValue;
    if (Number.isFinite(topValue)) updates.top = topValue;
    if (modal.dataset.resizable === "true") {
      const widthValue = Number.parseFloat(modal.style.width);
      const heightValue = Number.parseFloat(modal.style.height);
      if (Number.isFinite(widthValue)) updates.width = widthValue;
      if (Number.isFinite(heightValue)) updates.height = heightValue;
    }
    if (Object.keys(updates).length) {
      updateModalLayout(modal.dataset.modal, updates);
    }
  });
});

const previewCanvas = document.getElementById("segmentation-preview");
const previewCtx = previewCanvas.getContext("2d", { willReadFrequently: true }) || previewCanvas.getContext("2d");
const previewSection = document.querySelector(".segment-preview");
const gestureEditorEl = document.getElementById("gesture-editor");
const gestureToolbar = document.getElementById("gesture-toolbar");
const gestureSvg = document.getElementById("gesture-svg");
const gestureSvgWrapper = document.querySelector(".gesture-svg-wrapper");
const gestureToolButtons = {
  select: document.getElementById("gesture-tool-select"),
  hand: document.getElementById("gesture-tool-hand"),
  freehand: document.getElementById("gesture-tool-freehand"),
  rect: document.getElementById("gesture-tool-rect"),
  ellipse: document.getElementById("gesture-tool-ellipse"),
  line: document.getElementById("gesture-tool-line"),
  eraser: document.getElementById("gesture-tool-eraser")
};
const gestureModeToggle = document.getElementById("gesture-mode-toggle");
const gestureClearBtn = document.getElementById("gesture-clear");
const assignmentModal = document.getElementById("assignment-modal");
const assignmentBackdrop = document.getElementById("assignment-backdrop");
const assignmentCloseBtn = document.getElementById("assignment-modal-close");
const assignmentCancelBtn = document.getElementById("assignment-modal-cancel");
const assignmentApplyBtn = document.getElementById("assignment-modal-apply");
const assignmentStreamSelect = document.getElementById("assignment-stream");
const assignmentLandmarkSelect = document.getElementById("assignment-landmark");
const assignmentMidiPortSelect = document.getElementById("assignment-midi-port");
const assignmentMidiPortRefreshBtn = document.getElementById("assignment-midi-port-refresh");
const assignmentEventList = document.getElementById("assignment-event-list");
const assignmentAddEventBtn = document.getElementById("assignment-add-event");
const editorShapeList = document.getElementById("editor-shape-list");
const editorDetailEl = document.getElementById("editor-detail");
const editorDetailEmpty = document.getElementById("editor-detail-empty");
const editorDetailForm = document.getElementById("editor-detail-form");
const editorStreamSelect = document.getElementById("editor-stream-select");
const editorLandmarkSelect = document.getElementById("editor-landmark-select");
const editorMidiPortSelect = document.getElementById("editor-midi-port");
const editorMidiPortRefreshBtn = document.getElementById("editor-midi-port-refresh");
const editorEventList = document.getElementById("editor-event-list");
const editorAddEventBtn = document.getElementById("editor-add-event");
const editorDeleteShapeBtn = document.getElementById("editor-delete-shape");
const editorOpenModalBtn = document.getElementById("editor-open-modal");
const snapshotExportBtn = document.getElementById("snapshot-export");
const snapshotImportBtn = document.getElementById("snapshot-import");
const snapshotImportInput = document.getElementById("snapshot-import-input");
const editorFormInputs = [
  editorStreamSelect,
  editorLandmarkSelect
].filter(Boolean);
const backgroundOpacityInput = document.getElementById("background-opacity");
const backgroundOpacityValue = document.getElementById("background-opacity-value");
const trailsCheckbox = document.getElementById("toggle-trails");

const SEGMENTATION_COLOR = { r: 15, g: 139, b: 168 };
const SEGMENTATION_ALPHA = 0.6;
const MIN_POLYLINE_SEGMENT = 0.01;

const segmentationTintCanvas = document.createElement("canvas");
const segmentationTintCtx = segmentationTintCanvas.getContext("2d", { willReadFrequently: true }) || segmentationTintCanvas.getContext("2d");

const waitForVideoReady = (video) => {
  if (video.readyState >= 2) {
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    const handleReady = () => {
      cleanup();
      resolve();
    };
    const handleError = (event) => {
      cleanup();
      reject(new Error(event?.message || "Video failed to load"));
    };
    const cleanup = () => {
      video.removeEventListener("loadeddata", handleReady);
      video.removeEventListener("loadedmetadata", handleReady);
      video.removeEventListener("error", handleError);
    };
    video.addEventListener("loadeddata", handleReady, { once: true });
    video.addEventListener("loadedmetadata", handleReady, { once: true });
    video.addEventListener("error", handleError, { once: true });
  });
};

const SAFE_POSE_CONNECTIONS = typeof POSE_CONNECTIONS !== "undefined"
  ? POSE_CONNECTIONS
  : [
      [11, 13], [13, 15], [12, 14], [14, 16],
      [11, 12], [23, 24], [11, 23], [12, 24],
      [23, 25], [25, 27], [24, 26], [26, 28],
      [27, 29], [28, 30]
    ];

const SAFE_HAND_CONNECTIONS = typeof HAND_CONNECTIONS !== "undefined"
  ? HAND_CONNECTIONS
  : [
      [0, 1], [1, 2], [2, 3], [3, 4],
      [0, 5], [5, 6], [6, 7], [7, 8],
      [5, 9], [9, 10], [10, 11], [11, 12],
      [9, 13], [13, 14], [14, 15], [15, 16],
      [13, 17], [17, 18], [18, 19], [19, 20],
      [0, 17]
    ];

const SAFE_FACEMESH_TESSELATION = typeof FACEMESH_TESSELATION !== "undefined"
  ? FACEMESH_TESSELATION
  : [];

    videoEl.muted = true;
    videoEl.loop = true;
    videoEl.crossOrigin = "anonymous";
    videoEl.setAttribute("playsinline", "");
    videoEl.setAttribute("webkit-playsinline", "");

    let holistic = null;

    let currentSource = "camera";
    let cameraStream = null;
    let cameraFrameHandle = null;
    let sampleHandle = null;
    let latestResults = null;
    const inputState = {
      holistic: null,
      pointer: {
        normalized: null,
        isDown: false,
        pointerId: null,
        isOverCanvas: false,
        lastUpdate: 0
      },
      keyboard: {
        keys: new Map()
      }
    };
    let holisticBusy = false;
let segmentationBuffer = null;
let segmentationMaskAvailable = false;

const DEFAULT_OVERLAY_STATE = {
  mirror: true,
  underlay: { main: true, preview: false },
  pose: { main: true, preview: false },
  leftHand: { main: true, preview: false },
  rightHand: { main: true, preview: false },
  face: { main: true, preview: false },
  segmentation: { main: false, preview: true },
  depth: { main: false, preview: true },
  performance: { main: false, preview: true },
  score: { main: true, preview: true }
};

const overlayState = {
  mirror: mirrorCheckbox?.checked ?? DEFAULT_OVERLAY_STATE.mirror
};
for (const [key, defaults] of Object.entries(DEFAULT_OVERLAY_STATE)) {
  if (key === "mirror") continue;
  overlayState[key] = { main: defaults.main, preview: defaults.preview };
}

const isScoreMainEnabled = () => overlayState.score?.main !== false;
const isScorePreviewEnabled = () => overlayState.score?.preview ?? false;

const CONFIG_STORAGE_KEY = "mediamime:config";
const DEFAULT_EDITOR_CONFIG = {
  midiPort: "broadcast",
  backgroundOpacity: 1,
  trailsEnabled: false
};
const SNAPSHOT_VERSION = 1;
const SNAPSHOT_FILE_PREFIX = "mediamime-snapshot";
const editorConfig = { ...DEFAULT_EDITOR_CONFIG };
let isSyncingConfig = false;

const ACTIVE_STROKE_COLOR = "#f97316";
const ACTIVE_FILL_COLOR = "rgba(249, 115, 22, 0.32)";
const ACTIVE_PREVIEW_STROKE_COLOR = "rgba(249, 115, 22, 0.88)";
const ACTIVE_PREVIEW_FILL_COLOR = "rgba(249, 115, 22, 0.24)";

const loadEditorConfig = () => {
  if (typeof localStorage === "undefined") {
    return;
  }
  try {
    const raw = localStorage.getItem(CONFIG_STORAGE_KEY);
    if (!raw) return;
    const stored = JSON.parse(raw);
    if (!stored || typeof stored !== "object") return;
    if (stored.midiPort) editorConfig.midiPort = String(stored.midiPort);
    if (typeof stored.backgroundOpacity === "number") {
      const opacity = Math.max(0, Math.min(1, stored.backgroundOpacity));
      editorConfig.backgroundOpacity = opacity;
    }
    if (typeof stored.trailsEnabled === "boolean") {
      editorConfig.trailsEnabled = stored.trailsEnabled;
    }
  } catch (err) {
    console.warn("Failed to load editor config", err);
  }
};

const saveEditorConfig = () => {
  if (typeof localStorage === "undefined") {
    return;
  }
  try {
    localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(editorConfig));
  } catch (err) {
    console.warn("Failed to save editor config", err);
  }
};

const updateEditorConfig = (changes = {}, options = {}) => {
  let didChange = false;
  for (const [key, value] of Object.entries(changes || {})) {
    if (value === undefined) continue;
    if (editorConfig[key] === value) continue;
    editorConfig[key] = value;
    didChange = true;
  }
  if (!didChange) return;
  saveEditorConfig();
  applyGlobalConnectionConfig();
};

const applyScoreVisibility = () => {
  const visible = isScoreMainEnabled();
  if (gestureSvg) {
    gestureSvg.style.visibility = visible ? "visible" : "hidden";
    gestureSvg.style.pointerEvents = visible ? "auto" : "none";
  }
};

const performanceMetrics = {
  fps: 0,
  frameMs: 0,
  inferenceMs: 0,
  source: "camera"
};

let lastFrameTimestamp = performance.now();
let smoothedFps = 0;
let smoothedFrameMs = 0;
let smoothedInferenceMs = 0;

const resetPerformanceMetrics = () => {
  performanceMetrics.fps = 0;
  performanceMetrics.frameMs = 0;
  performanceMetrics.inferenceMs = 0;
  performanceMetrics.source = currentSource;
  smoothedFps = 0;
  smoothedFrameMs = 0;
  smoothedInferenceMs = 0;
  lastFrameTimestamp = performance.now();
  drawPreviewCanvas();
};

const recordInferenceTime = (ms) => {
  if (!Number.isFinite(ms) || ms <= 0) return;
  smoothedInferenceMs = smoothedInferenceMs ? (smoothedInferenceMs * 0.8 + ms * 0.2) : ms;
  performanceMetrics.inferenceMs = smoothedInferenceMs;
};

const updateOverlayState = () => {
  for (const [key, controls] of Object.entries(overlayControls)) {
    if (!overlayState[key]) {
      overlayState[key] = { main: false, preview: false };
    }
    overlayState[key].main = controls.main?.checked ?? false;
    overlayState[key].preview = controls.preview?.checked ?? false;
  }
  overlayState.mirror = mirrorCheckbox?.checked ?? DEFAULT_OVERLAY_STATE.mirror;
  if (previewSection) {
    const previewVisible = Object.keys(overlayControls).some((key) => overlayState[key]?.preview);
    previewSection.style.display = previewVisible ? "" : "none";
    previewSection.setAttribute("aria-hidden", previewVisible ? "false" : "true");
  }
  setEditorMirrorActive(overlayState.mirror && currentSource === "camera");
  applyScoreVisibility();
  renderEditor();
  drawPreviewCanvas();
};

const waitForHolisticIdle = async () => {
  while (holisticBusy) {
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
};

const resetHolistic = async () => {
  await waitForHolisticIdle();
  if (holistic && typeof holistic.close === "function") {
    try {
      await holistic.close();
    } catch (err) {
      console.warn("Holistic close failed", err);
    }
  }
  holisticBusy = false;
  holistic = createHolistic();
};
    const overlayInputs = Object.values(overlayControls)
      .flatMap((controls) => [controls.main, controls.preview])
      .filter(Boolean);

    overlayInputs.forEach((input) => {
      input.addEventListener("change", updateOverlayState);
    });

    if (mirrorCheckbox) {
      mirrorCheckbox.addEventListener("change", updateOverlayState);
    }

    const applyStatus = (text) => {
      statusLabel.textContent = text;
    };

    const segmentationOffscreen = document.createElement("canvas");
    const segmentationOffCtx = segmentationOffscreen.getContext("2d", { willReadFrequently: true }) || segmentationOffscreen.getContext("2d");

function clearPreviewCanvas() {
  if (!previewCtx) return;
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
}

function drawPreviewCanvas() {
  if (!previewCtx || !previewCanvas) {
    return;
  }
  const previewActive = Object.keys(overlayControls).some((key) => overlayState[key]?.preview);
  if (!previewActive) {
    clearPreviewCanvas();
    return;
  }
  clearPreviewCanvas();

  const ctx = previewCtx;
  const width = previewCanvas.width;
  const height = previewCanvas.height;

  const surfaceOpacity = getSurfaceOpacity();
  if (overlayState.underlay?.preview && surfaceOpacity > 0) {
    ctx.save();
    ctx.globalAlpha = surfaceOpacity;
    ctx.fillStyle = "#050912";
    ctx.fillRect(0, 0, width, height);
    ctx.restore();
  }

  const shouldMirror = overlayState.mirror && currentSource === "camera";
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  if (shouldMirror) {
    ctx.translate(width, 0);
    ctx.scale(-1, 1);
  }

  if (overlayState.underlay?.preview && surfaceOpacity > 0 && videoEl.readyState >= 2) {
    ctx.globalAlpha = surfaceOpacity;
    ctx.drawImage(videoEl, 0, 0, width, height);
  }

  if (overlayState.segmentation?.preview && segmentationMaskAvailable && segmentationTintCanvas.width) {
    ctx.globalAlpha = surfaceOpacity || 1;
    ctx.drawImage(segmentationTintCanvas, 0, 0, width, height);
  }

  if (latestResults) {
    const { poseLandmarks, leftHandLandmarks, rightHandLandmarks, faceLandmarks } = latestResults;

    const drawConnectorSet = (landmarks, connections, color, lineWidth) => {
      if (!landmarks) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.globalAlpha = 0.9;
      for (let i = 0; i < connections.length; i++) {
        const [startIndex, endIndex] = connections[i];
        const start = landmarks[startIndex];
        const end = landmarks[endIndex];
        if (!start || !end) continue;
        ctx.beginPath();
        ctx.moveTo(start.x * width, start.y * height);
        ctx.lineTo(end.x * width, end.y * height);
        ctx.stroke();
      }
      ctx.restore();
    };

    const drawLandmarkDots = (landmarks, color, size) => {
      if (!landmarks) return;
      ctx.save();
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.9;
      for (const lm of landmarks) {
        ctx.beginPath();
        ctx.arc(lm.x * width, lm.y * height, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    };

    if (overlayState.pose?.preview && poseLandmarks) {
      drawConnectorSet(poseLandmarks, SAFE_POSE_CONNECTIONS, "rgba(76, 201, 240, 0.9)", Math.max(1.4, width * 0.0035));
      drawLandmarkDots(poseLandmarks, "rgba(76, 201, 240, 0.7)", Math.max(2.4, width * 0.01));
    }
    if (overlayState.leftHand?.preview && leftHandLandmarks) {
      drawConnectorSet(leftHandLandmarks, SAFE_HAND_CONNECTIONS, "rgba(255, 112, 150, 0.95)", Math.max(1.2, width * 0.003));
      drawLandmarkDots(leftHandLandmarks, "rgba(255, 112, 150, 0.9)", Math.max(2.2, width * 0.009));
    }
    if (overlayState.rightHand?.preview && rightHandLandmarks) {
      drawConnectorSet(rightHandLandmarks, SAFE_HAND_CONNECTIONS, "rgba(255, 143, 163, 0.95)", Math.max(1.2, width * 0.003));
      drawLandmarkDots(rightHandLandmarks, "rgba(255, 143, 163, 0.9)", Math.max(2.2, width * 0.009));
    }
    if (overlayState.face?.preview && faceLandmarks) {
      ctx.save();
      ctx.strokeStyle = "rgba(249, 199, 79, 0.85)";
      ctx.lineWidth = Math.max(0.8, width * 0.0025);
      ctx.globalAlpha = 0.85;
      if (SAFE_FACEMESH_TESSELATION.length) {
        ctx.beginPath();
        for (let i = 0; i < SAFE_FACEMESH_TESSELATION.length; i++) {
          const [startIndex, endIndex] = SAFE_FACEMESH_TESSELATION[i];
          const start = faceLandmarks[startIndex];
          const end = faceLandmarks[endIndex];
          if (!start || !end) continue;
          ctx.moveTo(start.x * width, start.y * height);
          ctx.lineTo(end.x * width, end.y * height);
        }
        ctx.stroke();
      } else {
        ctx.fillStyle = "rgba(249, 199, 79, 0.75)";
        for (const lm of faceLandmarks) {
          ctx.beginPath();
          ctx.arc(lm.x * width, lm.y * height, Math.max(1.5, width * 0.004), 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.restore();
    }
    if (overlayState.depth?.preview && poseLandmarks) {
      ctx.save();
      ctx.globalAlpha = 0.6;
      for (const lm of poseLandmarks) {
        const { color, size } = depthStyle(lm.z ?? 0);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(lm.x * width, lm.y * height, Math.max(size * 0.08, 2.4), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  drawScorePreview(ctx, width, height);

  ctx.restore();

  if (overlayState.performance?.preview) {
    const fpsText = Number.isFinite(performanceMetrics.fps) && performanceMetrics.fps > 0
      ? performanceMetrics.fps.toFixed(1)
      : "--";
    const frameText = Number.isFinite(performanceMetrics.frameMs) && performanceMetrics.frameMs > 0
      ? performanceMetrics.frameMs.toFixed(1)
      : "--";
    const inferenceText = Number.isFinite(performanceMetrics.inferenceMs) && performanceMetrics.inferenceMs > 0
      ? performanceMetrics.inferenceMs.toFixed(1)
      : "--";
    const lines = [
      `FPS: ${fpsText}`,
      `Frame: ${frameText} ms`,
      `Inference: ${inferenceText} ms`,
      `Source: ${performanceMetrics.source}`
    ];
    const padding = 8;
    const lineHeight = 16;
    const boxWidth = width - padding * 2;
    const boxHeight = padding * 2 + lines.length * lineHeight;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(9, 13, 22, 0.10)";
    ctx.fillRect(padding, padding, boxWidth, boxHeight);
    ctx.fillStyle = "rgba(245, 247, 255, 0.92)";
    ctx.font = "12px 'Inter', 'Helvetica Neue', Arial, sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
    lines.forEach((line, index) => {
      ctx.fillText(line, padding + 10, padding + 6 + index * lineHeight);
    });
    ctx.restore();
  }
}

const resetSegmentationData = () => {
  segmentationBuffer = null;
  segmentationMaskAvailable = false;
  segmentationTintCanvas.width = 0;
  segmentationTintCanvas.height = 0;
  latestResults = null;
  clearPreviewCanvas();
  drawPreviewCanvas();
};

const CAMERA_CONSTRAINTS = {
  video: {
    width: { ideal: 1280 },
    height: { ideal: 720 },
    aspectRatio: { ideal: 16 / 9 },
    facingMode: "user"
  },
  audio: false
};

const cancelCameraLoop = () => {
  if (cameraFrameHandle) {
    cancelAnimationFrame(cameraFrameHandle);
    cameraFrameHandle = null;
  }
};

const ensureCameraStream = async () => {
  if (cameraStream) {
    const liveTrack = cameraStream.getVideoTracks().find((track) => track.readyState === "live");
    if (liveTrack) {
      return cameraStream;
    }
  }
  cameraStream = await navigator.mediaDevices.getUserMedia(CAMERA_CONSTRAINTS);
  return cameraStream;
};

const startCameraLoop = () => {
  cancelCameraLoop();
  const loop = async () => {
    if (currentSource !== "camera") {
      cameraFrameHandle = requestAnimationFrame(loop);
      return;
    }
    if (!videoEl.videoWidth || !videoEl.videoHeight) {
      cameraFrameHandle = requestAnimationFrame(loop);
      return;
    }
    if (!holisticBusy) {
      holisticBusy = true;
      try {
        const inferenceStart = performance.now();
        await holistic.send({ image: videoEl });
        recordInferenceTime(performance.now() - inferenceStart);
      } catch (err) {
        console.warn("Holistic send failed on camera frame", err);
      } finally {
        holisticBusy = false;
      }
    }
    cameraFrameHandle = requestAnimationFrame(loop);
  };
  cameraFrameHandle = requestAnimationFrame(loop);
};

const pauseCameraStream = () => {
  cancelCameraLoop();
  if (cameraStream) {
    cameraStream.getVideoTracks().forEach((track) => {
      track.enabled = false;
    });
  }
  if (videoEl.srcObject === cameraStream) {
    videoEl.pause();
    videoEl.srcObject = null;
  }
};

function refreshSegmentationTint() {
  if (!segmentationBuffer) {
    segmentationTintCanvas.width = 0;
    segmentationTintCanvas.height = 0;
    segmentationMaskAvailable = false;
    clearPreviewCanvas();
    return;
  }
  const width = segmentationBuffer.width || segmentationOffscreen.width;
  const height = segmentationBuffer.height || segmentationOffscreen.height;
  segmentationTintCanvas.width = width;
  segmentationTintCanvas.height = height;
  const tinted = segmentationTintCtx.createImageData(width, height);
  const src = segmentationBuffer.data;
  const dst = tinted.data;
  const len = width * height;
  for (let i = 0; i < len; i++) {
    const alpha = src[i * 4] / 255;
    dst[i * 4] = SEGMENTATION_COLOR.r;
    dst[i * 4 + 1] = SEGMENTATION_COLOR.g;
    dst[i * 4 + 2] = SEGMENTATION_COLOR.b;
    dst[i * 4 + 3] = Math.round(alpha * SEGMENTATION_ALPHA * 255);
  }
  segmentationTintCtx.putImageData(tinted, 0, 0);
  segmentationMaskAvailable = true;
  drawPreviewCanvas();
}

const handleHolisticResults = (results) => {
  latestResults = results;
  inputState.holistic = results;
  if (results.segmentationMask) {
    segmentationOffscreen.width = results.segmentationMask.width || videoEl.videoWidth || 640;
    segmentationOffscreen.height = results.segmentationMask.height || videoEl.videoHeight || 480;
    segmentationOffCtx.globalCompositeOperation = "copy";
    segmentationOffCtx.drawImage(results.segmentationMask, 0, 0, segmentationOffscreen.width, segmentationOffscreen.height);
    segmentationBuffer = segmentationOffCtx.getImageData(0, 0, segmentationOffscreen.width, segmentationOffscreen.height);
    refreshSegmentationTint();
  } else {
    segmentationBuffer = null;
    refreshSegmentationTint();
  }
  evaluateShapeInteractions();
};

const createHolistic = () => {
  const instance = new Holistic({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
  });
  instance.setOptions({
    modelComplexity: 1,
    smoothLandmarks: true,
    enableSegmentation: true,
    refineFaceLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  instance.onResults(handleHolisticResults);
  return instance;
};

holistic = createHolistic();

    async function startCamera() {
      stopSampleVideo();
      const stream = await ensureCameraStream();
      stream.getVideoTracks().forEach((track) => {
        track.enabled = true;
      });
      if (videoEl.srcObject !== stream) {
        videoEl.pause();
        videoEl.srcObject = stream;
        videoEl.removeAttribute("src");
      }
      if (videoEl.readyState < 2) {
        await new Promise((resolve) => {
          const handleLoaded = () => {
            videoEl.removeEventListener("loadedmetadata", handleLoaded);
            resolve();
          };
          videoEl.addEventListener("loadedmetadata", handleLoaded, { once: true });
        });
      }
      await videoEl.play();
      await resetHolistic();
      resetSegmentationData();
      currentSource = "camera";
      resetPerformanceMetrics();
      startCameraLoop();
      applyStatus("Live camera ready");
      updateOverlayState();
    }

    async function startSampleVideo() {
      pauseCameraStream();
      if (sampleHandle) {
        cancelAnimationFrame(sampleHandle);
        sampleHandle = null;
      }
      await resetHolistic();
      resetSegmentationData();
      videoEl.srcObject = null;
      videoEl.src = SAMPLE_VIDEO_URL;
      try {
        await waitForVideoReady(videoEl);
      } catch (err) {
        console.error("Sample video failed to load", err);
        applyStatus("Sample video load failed");
        return;
      }
      await videoEl.play();
      applyStatus("Using sample video");
      currentSource = "sample";
      resetPerformanceMetrics();

      const loop = async () => {
        if (currentSource !== "sample") {
          return;
        }
        if (videoEl.ended) {
          videoEl.currentTime = 0;
          await videoEl.play();
        }
        if (currentSource === "sample" && !videoEl.paused && videoEl.readyState >= 2) {
          if (!holisticBusy) {
            holisticBusy = true;
            try {
              const inferenceStart = performance.now();
              await holistic.send({ image: videoEl });
              recordInferenceTime(performance.now() - inferenceStart);
            } catch (err) {
              console.warn("Holistic send failed on sample frame", err);
            } finally {
              holisticBusy = false;
            }
          }
        }
        if (currentSource === "sample") {
          sampleHandle = requestAnimationFrame(loop);
        }
      };
      sampleHandle = requestAnimationFrame(loop);
      updateOverlayState();
    }

    function stopCamera() {
      cancelCameraLoop();
      if (cameraStream) {
        cameraStream.getTracks().forEach((track) => track.stop());
        cameraStream = null;
      }
      if (videoEl.srcObject) {
        videoEl.pause();
        videoEl.srcObject = null;
      }
      if (currentSource === "camera") {
        currentSource = "none";
      }
      resetSegmentationData();
      updateOverlayState();
    }

    function stopSampleVideo() {
      if (currentSource === "sample") {
        currentSource = "none";
      }
      resetSegmentationData();
      if (sampleHandle) {
        cancelAnimationFrame(sampleHandle);
        sampleHandle = null;
      }
      if (!videoEl.paused && !videoEl.srcObject) {
        videoEl.pause();
      }
      if (!videoEl.srcObject && videoEl.src) {
        videoEl.removeAttribute("src");
        videoEl.load();
      }
      updateOverlayState();
    }

    toggleSourceBtn.addEventListener("click", async () => {
      toggleSourceBtn.disabled = true;
      try {
        if (currentSource === "camera") {
          applyStatus("Loading sample video…");
          await startSampleVideo();
        } else {
          applyStatus("Requesting camera…");
          await startCamera();
        }
      } catch (err) {
        console.error("Source switch error", err);
        applyStatus("Source switch failed");
      } finally {
        toggleSourceBtn.disabled = false;
      }
    });

    resetBtn.addEventListener("click", () => {
      for (const [key, controls] of Object.entries(overlayControls)) {
        const defaults = DEFAULT_OVERLAY_STATE[key];
        if (!defaults) continue;
        if (controls.main) {
          controls.main.checked = defaults.main;
        }
        if (controls.preview) {
          controls.preview.checked = defaults.preview;
        }
      }
      if (mirrorCheckbox) {
        if (currentSource === "camera") {
          mirrorCheckbox.checked = true;
        } else {
          mirrorCheckbox.checked = DEFAULT_OVERLAY_STATE.mirror;
        }
      }
      updateOverlayState();
    });

    window.addEventListener("beforeunload", () => {
      stopSampleVideo();
      stopCamera();
    });

    let p5Instance = null;

    const DEFAULT_WIDTH = 1280;
    const DEFAULT_HEIGHT = 720;
    const AUTO_REVERT_TOOLS = new Set(["line", "freehand", "rect", "ellipse"]);
    const FREEHAND_SIMPLIFY_TOLERANCE = 0.0025;
    const VERTEX_EPSILON = 1e-4;

    let canvasWidth = DEFAULT_WIDTH;
    let canvasHeight = DEFAULT_HEIGHT;
    const editorState = {
      mode: "edit",
      tool: "select",
      shapes: [],
      selectedId: null,
      selectedIds: new Set(),
      drawingShapeId: null,
      dragHandle: null,
      pointerId: null,
      pointerOrigin: null,
      initialRect: null,
      initialVertices: null,
      viewport: { width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT },
      mirror: false,
      isVisible: false,
      didMutate: false,
      activePolylineId: null,
      polylineHoverPoint: null,
      polylinePointerId: null,
      polylineExtendArmed: false,
      eraserActive: false,
      eraserPointerId: null,
      erasedShapeIds: new Set(),
      hoverShapeId: null,
      toolLocked: false,
      pan: { x: 0, y: 0 },
      panPointerId: null,
      panOrigin: null,
      selectionMarquee: null,
      selectionBounds: null,
      transformSession: null,
      selectionFrame: null,
      cursorHandle: null
    };
    const applyEditorPan = () => {
      if (!gestureSvgWrapper) return;
      gestureSvgWrapper.style.transform = `translate(${editorState.pan.x}px, ${editorState.pan.y}px)`;
    };

    const updateToolLockIndicator = () => {
      gestureToolbar?.classList.toggle("is-tool-locked", Boolean(editorState.toolLocked));
    };
    applyEditorPan();
    updateToolLockIndicator();

    const maybeAutoRevertTool = () => {
      if (!editorState.toolLocked && AUTO_REVERT_TOOLS.has(editorState.tool)) {
        setEditorTool("select");
      }
    };

    const beginPan = (event) => {
      editorState.panPointerId = event.pointerId;
      editorState.panOrigin = {
        x: event.clientX,
        y: event.clientY,
        panX: editorState.pan.x,
        panY: editorState.pan.y
      };
      gestureSvgWrapper?.classList.add("is-panning");
      if (gestureSvg?.setPointerCapture) {
        gestureSvg.setPointerCapture(event.pointerId);
      }
    };

    const updatePan = (event) => {
      if (editorState.panPointerId !== event.pointerId || !editorState.panOrigin) return;
      const dx = event.clientX - editorState.panOrigin.x;
      const dy = event.clientY - editorState.panOrigin.y;
      editorState.pan.x = editorState.panOrigin.panX + dx;
      editorState.pan.y = editorState.panOrigin.panY + dy;
      applyEditorPan();
    };

    const endPan = (event) => {
      if (editorState.panPointerId !== event.pointerId) return;
      if (gestureSvg?.hasPointerCapture?.(event.pointerId)) {
        gestureSvg.releasePointerCapture(event.pointerId);
      }
      editorState.panPointerId = null;
      editorState.panOrigin = null;
      gestureSvgWrapper?.classList.remove("is-panning");
    };
    const isPolylineTool = (tool) => tool === "line" || tool === "freehand";
    const STORAGE_KEY = "mediamime:gesture-shapes";
    const STORAGE_KEY_SVG = `${STORAGE_KEY}:svg`;
    let persistTimer = null;
    let activeAssignmentShapeId = null;
    let assignmentDraftInteraction = null;
    const CONTINUOUS_TRIGGER_INTERVAL_MS = 220;
    let editorSidebarDirty = true;
    let isSyncingEditorForm = false;
    let isSyncingAssignmentForm = false;

    const SHAPE_MIN_SIZE = 0.015;
    const DEFAULT_SHAPE_STYLE = {
      stroke: "rgba(82, 213, 255, 0.88)",
      fill: "rgba(82, 213, 255, 0.14)",
      strokeWidth: 2
    };
    const POSE_LANDMARKS_LIST = [
      { key: "nose", label: "Nose", index: 0 },
      { key: "left_eye_inner", label: "Left eye (inner)", index: 1 },
      { key: "left_eye", label: "Left eye", index: 2 },
      { key: "left_eye_outer", label: "Left eye (outer)", index: 3 },
      { key: "right_eye_inner", label: "Right eye (inner)", index: 4 },
      { key: "right_eye", label: "Right eye", index: 5 },
      { key: "right_eye_outer", label: "Right eye (outer)", index: 6 },
      { key: "left_ear", label: "Left ear", index: 7 },
      { key: "right_ear", label: "Right ear", index: 8 },
      { key: "mouth_left", label: "Mouth left", index: 9 },
      { key: "mouth_right", label: "Mouth right", index: 10 },
      { key: "left_shoulder", label: "Left shoulder", index: 11 },
      { key: "right_shoulder", label: "Right shoulder", index: 12 },
      { key: "left_elbow", label: "Left elbow", index: 13 },
      { key: "right_elbow", label: "Right elbow", index: 14 },
      { key: "left_wrist", label: "Left wrist", index: 15 },
      { key: "right_wrist", label: "Right wrist", index: 16 },
      { key: "left_pinky", label: "Left pinky", index: 17 },
      { key: "right_pinky", label: "Right pinky", index: 18 },
      { key: "left_index", label: "Left index", index: 19 },
      { key: "right_index", label: "Right index", index: 20 },
      { key: "left_thumb", label: "Left thumb", index: 21 },
      { key: "right_thumb", label: "Right thumb", index: 22 },
      { key: "left_hip", label: "Left hip", index: 23 },
      { key: "right_hip", label: "Right hip", index: 24 },
      { key: "left_knee", label: "Left knee", index: 25 },
      { key: "right_knee", label: "Right knee", index: 26 },
      { key: "left_ankle", label: "Left ankle", index: 27 },
      { key: "right_ankle", label: "Right ankle", index: 28 },
      { key: "left_heel", label: "Left heel", index: 29 },
      { key: "right_heel", label: "Right heel", index: 30 },
      { key: "left_foot_index", label: "Left foot index", index: 31 },
      { key: "right_foot_index", label: "Right foot index", index: 32 }
    ];
    const HAND_LANDMARKS_LIST = [
      { key: "wrist", label: "Wrist", index: 0 },
      { key: "thumb_cmc", label: "Thumb CMC", index: 1 },
      { key: "thumb_mcp", label: "Thumb MCP", index: 2 },
      { key: "thumb_ip", label: "Thumb IP", index: 3 },
      { key: "thumb_tip", label: "Thumb tip", index: 4 },
      { key: "index_mcp", label: "Index MCP", index: 5 },
      { key: "index_pip", label: "Index PIP", index: 6 },
      { key: "index_dip", label: "Index DIP", index: 7 },
      { key: "index_tip", label: "Index tip", index: 8 },
      { key: "middle_mcp", label: "Middle MCP", index: 9 },
      { key: "middle_pip", label: "Middle PIP", index: 10 },
      { key: "middle_dip", label: "Middle DIP", index: 11 },
      { key: "middle_tip", label: "Middle tip", index: 12 },
      { key: "ring_mcp", label: "Ring MCP", index: 13 },
      { key: "ring_pip", label: "Ring PIP", index: 14 },
      { key: "ring_dip", label: "Ring DIP", index: 15 },
      { key: "ring_tip", label: "Ring tip", index: 16 },
      { key: "pinky_mcp", label: "Pinky MCP", index: 17 },
      { key: "pinky_pip", label: "Pinky PIP", index: 18 },
      { key: "pinky_dip", label: "Pinky DIP", index: 19 },
      { key: "pinky_tip", label: "Pinky tip", index: 20 }
    ];
    const FACE_REFERENCE_POINTS = [
      { key: "centroid", label: "Face centroid" },
      { key: "nose_tip", label: "Nose tip", index: 1 }
    ];
    const POINTER_REFERENCE_POINTS = [
      { key: "position", label: "Pointer position" },
      { key: "button", label: "Pointer button (inside shape)" }
    ];
    const KEYBOARD_DIGIT_KEYS = Array.from({ length: 10 }, (_, index) => ({
      key: `Digit${index}`,
      label: `${index}`
    }));
    const KEYBOARD_LETTER_KEYS = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZ").map((char) => ({
      key: `Key${char}`,
      label: char
    }));
    const KEYBOARD_REFERENCE_KEYS = [
      { key: "Space", label: "Space" },
      { key: "Enter", label: "Enter" },
      { key: "Escape", label: "Escape" },
      { key: "Tab", label: "Tab" },
      { key: "Backspace", label: "Backspace" },
      { key: "ArrowUp", label: "Arrow Up" },
      { key: "ArrowDown", label: "Arrow Down" },
      { key: "ArrowLeft", label: "Arrow Left" },
      { key: "ArrowRight", label: "Arrow Right" },
      { key: "ShiftLeft", label: "Shift (Left)" },
      { key: "ShiftRight", label: "Shift (Right)" },
      { key: "AltLeft", label: "Option / Alt (Left)" },
      { key: "AltRight", label: "Option / Alt (Right)" },
      { key: "ControlLeft", label: "Control (Left)" },
      { key: "ControlRight", label: "Control (Right)" },
      { key: "MetaLeft", label: "Command (Left)" },
      { key: "MetaRight", label: "Command (Right)" },
      { key: "NumpadEnter", label: "Numpad Enter" },
      ...KEYBOARD_DIGIT_KEYS,
      ...KEYBOARD_LETTER_KEYS
    ];
    const KEYBOARD_REFERENCE_SET = new Set(KEYBOARD_REFERENCE_KEYS.map((entry) => entry.key));
    const STREAM_DEFINITIONS = {
      pose: {
        id: "pose",
        label: "Pose Landmarks",
        options: POSE_LANDMARKS_LIST
      },
      leftHand: {
        id: "leftHand",
        label: "Left Hand",
        options: HAND_LANDMARKS_LIST
      },
      rightHand: {
        id: "rightHand",
        label: "Right Hand",
        options: HAND_LANDMARKS_LIST
      },
      face: {
        id: "face",
        label: "Face",
        options: FACE_REFERENCE_POINTS
      },
      pointer: {
        id: "pointer",
        label: "Pointer Input",
        options: POINTER_REFERENCE_POINTS
      },
      keyboard: {
        id: "keyboard",
        label: "Keyboard",
        options: KEYBOARD_REFERENCE_KEYS
      }
    };
    const resetShapeRuntime = (shape) => {
      if (!shape) return;
      shape.runtime = {
        inside: false,
        hoverInside: false,
        lastTriggerAt: 0,
        lastContinuousAt: 0,
        noteOn: false,
        eventState: {},
        lastMetrics: { normX: 0, normY: 0, distance: 0 }
      };
    };
    const getStreamDefinition = (streamId) => STREAM_DEFINITIONS[streamId] ?? STREAM_DEFINITIONS.pose;
    const setElementVisibility = (element, visible) => {
      if (!element) return;
      element.style.display = visible ? "" : "none";
    };
    const populateLandmarkOptions = (streamId, selectedKey, selectEl = assignmentLandmarkSelect) => {
      const targetSelect = selectEl || assignmentLandmarkSelect;
      if (!targetSelect) return;
      const definition = getStreamDefinition(streamId);
      targetSelect.innerHTML = "";
      definition.options.forEach((option, index) => {
        const optionEl = document.createElement("option");
        optionEl.value = option.key;
        optionEl.textContent = option.label;
        if (option.key === selectedKey || (!selectedKey && index === 0)) {
          optionEl.selected = true;
        }
        targetSelect.appendChild(optionEl);
      });
      if (!targetSelect.value && definition.options.length) {
        targetSelect.value = definition.options[0].key;
      }
      return targetSelect.value;
    };
    const markEditorSidebarDirty = () => {
      editorSidebarDirty = true;
    };

    const setEditorVisibility = (visible) => {
      editorState.isVisible = Boolean(visible);
      if (gestureToolbar) {
        gestureToolbar.style.display = editorState.isVisible ? "" : "none";
        gestureToolbar.style.pointerEvents = editorState.isVisible ? "auto" : "none";
      }
    };

    const toggleEditorVisibility = () => {
      setEditorVisibility(!editorState.isVisible);
    };
    const updateEditorShapeList = () => {
      if (!editorShapeList) {
        return;
      }
      if (!editorState.shapes.length) {
        editorShapeList.innerHTML = `<div class="editor-detail-empty">No shapes yet. Draw on the canvas to add one.</div>`;
        editorShapeList.removeAttribute("aria-activedescendant");
        return;
      }
      const activeId = editorState.selectedId;
      const shapeMarkup = editorState.shapes.map((shape, index) => {
        const isActive = shape.id === activeId;
        let typeLabel = "Rect";
        if (shape.type === "ellipse") {
          typeLabel = "Ellipse";
        } else if (shape.type === "polyline") {
          typeLabel = shape.closed ? "Polygon" : "Polyline";
        }
        const streamDefinition = getStreamDefinition(shape.interaction?.stream || "pose");
        const streamLabel = streamDefinition?.label || "Stream";
        const events = Array.isArray(shape.interaction?.events) ? shape.interaction.events : [];
        const activeEvents = events.filter((event) => event && event.type && event.type !== "none");
        const primaryEvent = activeEvents[0];
        const extraEventCount = primaryEvent ? Math.max(0, activeEvents.length - 1) : 0;
        let eventLabel = "No events";
        let triggerLabel = null;
        if (primaryEvent) {
          eventLabel = primaryEvent.type === "midiCc" ? "MIDI CC" : primaryEvent.type === "midiNote" ? "MIDI Note" : "Event";
          const triggerId = typeof primaryEvent.trigger === "string" && primaryEvent.trigger ? primaryEvent.trigger : "enter";
          triggerLabel = triggerId.replace(/^\w/, (char) => char.toUpperCase());
          if (extraEventCount > 0) {
            eventLabel = `${eventLabel} (+${extraEventCount})`;
          }
        }
        const metaParts = [typeLabel, streamLabel, eventLabel];
        if (triggerLabel) {
          metaParts.push(triggerLabel);
        }
        const meta = metaParts.join(" · ");
        const classes = ["editor-shape-item"];
        if (isActive) {
          classes.push("is-active");
        }
        const highlight = shape.runtime?.inside ? " data-active=\"true\"" : "";
        return `<button type="button" id="editor-shape-${shape.id}" class="${classes.join(" ")}"${highlight} data-shape-id="${shape.id}" role="option" aria-selected="${isActive ? "true" : "false"}">
            <span class="shape-label">Shape ${index + 1}</span>
            <span class="shape-meta">${meta}</span>
          </button>`;
      }).join("");
      editorShapeList.innerHTML = shapeMarkup;
      if (activeId) {
        editorShapeList.setAttribute("aria-activedescendant", `editor-shape-${activeId}`);
      } else {
        editorShapeList.removeAttribute("aria-activedescendant");
      }
    };
    const syncEditorDetailForm = () => {
      if (!editorDetailForm) {
        return;
      }
      const shape = findShapeById(editorState.selectedId);
      const hasShape = Boolean(shape);
      setElementVisibility(editorDetailForm, hasShape);
      setElementVisibility(editorDetailEmpty, !hasShape);
      editorFormInputs.forEach((input) => {
        if (input) {
          input.disabled = !hasShape;
        }
      });
      if (editorDeleteShapeBtn) {
        editorDeleteShapeBtn.disabled = !hasShape;
      }
      if (editorOpenModalBtn) {
        editorOpenModalBtn.disabled = !hasShape;
      }
      if (!hasShape) {
        populateMidiPortSelect(editorMidiPortSelect, editorConfig.midiPort);
        if (editorEventList) editorEventList.innerHTML = `<div class="event-empty">Select a shape to configure events.</div>`;
        return;
      }
      const interaction = mergeInteraction(shape.interaction);
      shape.interaction = interaction;
      isSyncingEditorForm = true;
      if (editorStreamSelect) {
        editorStreamSelect.value = interaction.stream;
      }
      const resolvedLandmark = populateLandmarkOptions(interaction.stream, interaction.landmark, editorLandmarkSelect);
      if (editorLandmarkSelect && resolvedLandmark) {
        editorLandmarkSelect.value = resolvedLandmark;
      }
      populateMidiPortSelect(editorMidiPortSelect, editorConfig.midiPort);
      if (editorMidiPortSelect) editorMidiPortSelect.dataset.selectedPort = editorConfig.midiPort;
      renderEventList("editor", interaction.events);
      isSyncingEditorForm = false;
    };
    const updateEditorSidebar = () => {
      if (!isMapModalOpen()) {
        return;
      }
      updateEditorShapeList();
      syncEditorDetailForm();
      editorSidebarDirty = false;
    };
    onModalStateChange(({ id, open }) => {
      if (id === "map" && open) {
        markEditorSidebarDirty();
        updateEditorSidebar();
      }
    });
    const mutateSelectedShape = (mutator, { skipRender = false, skipSidebar = false, skipDirty = false } = {}) => {
      const shape = findShapeById(editorState.selectedId);
      if (!shape) {
        return;
      }
      const previousInteraction = shape.interaction ? { ...shape.interaction } : null;
      mutator(shape);
      if (shape.type === "polyline") {
        shape.vertices = normalizeVertices(shape.vertices);
        updatePolylineBounds(shape);
        ensurePolylineStyle(shape);
      }
      if (previousInteraction !== shape.interaction) {
        shape.interaction = mergeInteraction(shape.interaction);
        if (shape.interaction?.midi) {
          delete shape.interaction.midi.port;
        }
      }
      resetShapeRuntime(shape);
      refreshSelectionBounds();
      if (!skipDirty) {
        markEditorSidebarDirty();
      }
      queuePersist();
      if (skipRender) {
        if (!skipSidebar && isMapModalOpen()) {
          updateEditorSidebar();
        }
      } else {
        renderEditor();
      }
    };
    const deleteSelectedShape = () => {
      const ids = getSelectedIds();
      if (!ids.length) return;
      ids.forEach((id) => {
        if (editorState.activePolylineId === id) {
          clearActivePolylineState();
        }
        removeShapeById(id);
      });
      setSelectedShapes([], { suppressRender: true });
      refreshSelectionBounds();
      renderEditor();
      queuePersist();
    };
    const VALUE_SOURCE_OPTIONS = [
      { id: "constant", label: "Constant" },
      { id: "normX", label: "Norm X" },
      { id: "normY", label: "Norm Y" },
      { id: "distance", label: "Distance" }
    ];
    const EVENT_TYPE_OPTIONS = [
      { id: "none", label: "None" },
      { id: "midiNote", label: "MIDI Note" },
      { id: "midiCc", label: "MIDI CC" }
    ];
    const EVENT_TRIGGER_OPTIONS = [
      { id: "enter", label: "Enter" },
      { id: "exit", label: "Exit" },
      { id: "enterExit", label: "Enter + Exit" },
      { id: "inside", label: "While Inside" }
    ];
    const createDefaultEvent = (type = "none") => {
      const id = ensureUuid();
      switch (type) {
        case "midiNote":
          return {
            id,
            type,
            trigger: "enter",
            channel: 1,
            note: 60,
            velocityMode: "constant",
            velocityValue: 96
          };
        case "midiCc":
          return {
            id,
            type,
            trigger: "enter",
            channel: 1,
            cc: 1,
            ccValueMode: "constant",
            ccValue: 100
          };
        default:
          return {
            id,
            type: "none",
            trigger: "enter"
          };
      }
    };
    const cloneEvent = (event) => JSON.parse(JSON.stringify(event));
    const normalizeEvent = (event) => {
      if (!event || typeof event !== "object") {
        return createDefaultEvent("none");
      }
      const base = createDefaultEvent(event.type || "none");
      return {
        ...base,
        ...event,
        id: event.id || base.id
      };
    };
    const createDefaultInteraction = () => ({
      stream: "pose",
      landmark: "left_wrist",
      events: [createDefaultEvent("midiNote")]
    });
    const mergeInteraction = (input) => {
      const defaults = createDefaultInteraction();
      const source = input || {};
      const events = Array.isArray(source.events)
        ? source.events.map(normalizeEvent)
        : defaults.events.map(cloneEvent);
      return {
        ...defaults,
        ...source,
        events
      };
    };
    const migrateLegacyInteraction = (raw = {}) => {
      if (raw && Array.isArray(raw.events)) {
        return mergeInteraction(raw);
      }
      const interaction = createDefaultInteraction();
      if (raw && typeof raw === "object") {
        if (raw.stream) interaction.stream = raw.stream;
        if (raw.landmark) interaction.landmark = raw.landmark;
        const events = [];
        const legacyTrigger = raw.trigger || "enter";
        const legacyMidi = raw.midi || {};
        if (legacyMidi.type === "note") {
          events.push(
            normalizeEvent({
              type: "midiNote",
              trigger: legacyTrigger,
              channel: legacyMidi.channel ?? 1,
              note: legacyMidi.note ?? 60,
              velocityMode: "constant",
              velocityValue: legacyMidi.velocity ?? 96
            })
          );
        } else if (legacyMidi.type === "cc") {
          events.push(
            normalizeEvent({
              type: "midiCc",
              trigger: legacyTrigger,
              channel: legacyMidi.channel ?? 1,
              cc: legacyMidi.cc ?? 1,
              ccValueMode: "constant",
              ccValue: legacyMidi.value ?? 100
            })
          );
        }
        interaction.events = events.length ? events : interaction.events;
      }
      return mergeInteraction(interaction);
    };
    const escapeHtml = (value) => String(value ?? "").replace(/[&<>"']/g, (match) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[match]));
    const normalizeVertices = (vertices) => {
      if (!Array.isArray(vertices)) return [];
      const normalized = [];
      for (const vertex of vertices) {
        const x = clampUnit(vertex?.x ?? 0);
        const y = clampUnit(vertex?.y ?? 0);
        if (!normalized.length) {
          normalized.push({ x, y });
          continue;
        }
        const prev = normalized[normalized.length - 1];
        if (Math.hypot(x - prev.x, y - prev.y) <= VERTEX_EPSILON) {
          normalized[normalized.length - 1] = { x, y };
        } else {
          normalized.push({ x, y });
        }
      }
      if (normalized.length >= 2) {
        const first = normalized[0];
        const last = normalized[normalized.length - 1];
        if (Math.hypot(last.x - first.x, last.y - first.y) <= VERTEX_EPSILON) {
          normalized[normalized.length - 1] = { ...first };
        }
      }
      return normalized;
    };
    const RAD_TO_DEG = 180 / Math.PI;
    const SNAP_ROTATION_INCREMENT = Math.PI / 12;
    function normalizeAngle(angle) {
      if (!Number.isFinite(angle)) return 0;
      return Math.atan2(Math.sin(angle), Math.cos(angle));
    }
    const rotatePointAround = (x, y, cx, cy, angle) => {
      const dx = x - cx;
      const dy = y - cy;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: cx + dx * cos - dy * sin,
        y: cy + dx * sin + dy * cos
      };
    };
    const getRectCorners = (shape) => {
      const rotation = normalizeAngle(shape.rotation || 0);
      const width = shape.width ?? 0;
      const height = shape.height ?? 0;
      const cx = (shape.x ?? 0) + width / 2;
      const cy = (shape.y ?? 0) + height / 2;
      const hw = width / 2;
      const hh = height / 2;
      const offsets = [
        { x: -hw, y: -hh },
        { x: hw, y: -hh },
        { x: hw, y: hh },
        { x: -hw, y: hh }
      ];
      if (!rotation) {
        return offsets.map((offset) => ({
          x: clampUnit(cx + offset.x),
          y: clampUnit(cy + offset.y)
        }));
      }
      return offsets.map((offset) => rotatePointAround(cx + offset.x, cy + offset.y, cx, cy, rotation));
    };
    const computePolylineBounds = (vertices) => {
      const normalized = normalizeVertices(vertices);
      if (!normalized.length) {
        return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
      }
      let minX = 1;
      let minY = 1;
      let maxX = 0;
      let maxY = 0;
      for (const vertex of normalized) {
        minX = Math.min(minX, vertex.x);
        minY = Math.min(minY, vertex.y);
        maxX = Math.max(maxX, vertex.x);
        maxY = Math.max(maxY, vertex.y);
      }
      return { minX, minY, maxX, maxY };
    };
    const updatePolylineBounds = (shape) => {
      if (!shape || shape.type !== "polyline") return;
      const { minX, minY, maxX, maxY } = computePolylineBounds(shape.vertices);
      shape.x = clampUnit(minX);
      shape.y = clampUnit(minY);
      shape.width = clampRange(maxX - minX, 0, 1);
      shape.height = clampRange(maxY - minY, 0, 1);
    };
    const ensurePolylineStyle = (shape) => {
      if (!shape || shape.type !== "polyline") return;
      shape.style = { ...DEFAULT_SHAPE_STYLE, ...(shape.style || {}) };
      if (shape.closed) {
        shape.style.fill = DEFAULT_SHAPE_STYLE.fill;
      } else {
        shape.style.fill = "none";
      }
    };
    const distanceBetween = (a, b) => {
      if (!a || !b) return 0;
      const dx = (a.x ?? 0) - (b.x ?? 0);
      const dy = (a.y ?? 0) - (b.y ?? 0);
      return Math.hypot(dx, dy);
    };
    const squaredDistanceBetween = (a, b) => {
      if (!a || !b) return 0;
      const dx = (a.x ?? 0) - (b.x ?? 0);
      const dy = (a.y ?? 0) - (b.y ?? 0);
      return dx * dx + dy * dy;
    };
    const getSqSegDist = (p, p1, p2) => {
      let x = p1.x;
      let y = p1.y;
      let dx = p2.x - x;
      let dy = p2.y - y;
      if (dx !== 0 || dy !== 0) {
        const t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
          x = p2.x;
          y = p2.y;
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }
      dx = p.x - x;
      dy = p.y - y;
      return dx * dx + dy * dy;
    };
    const simplifyRadialDistance = (points, sqTolerance) => {
      if (!points.length) return [];
      let prevPoint = points[0];
      const newPoints = [prevPoint];
      for (let i = 1; i < points.length; i++) {
        const point = points[i];
        if (squaredDistanceBetween(point, prevPoint) > sqTolerance) {
          newPoints.push(point);
          prevPoint = point;
        }
      }
      if (prevPoint !== points[points.length - 1]) {
        newPoints.push(points[points.length - 1]);
      }
      return newPoints;
    };
    const simplifyDouglasPeucker = (points, sqTolerance) => {
      const len = points.length;
      if (len <= 2) return points.slice();
      const markers = new Uint8Array(len);
      markers[0] = markers[len - 1] = 1;
      const stack = [[0, len - 1]];
      while (stack.length) {
        const [first, last] = stack.pop();
        let maxSqDist = 0;
        let index = 0;
        for (let i = first + 1; i < last; i++) {
          const sqDist = getSqSegDist(points[i], points[first], points[last]);
          if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          markers[index] = 1;
          stack.push([first, index], [index, last]);
        }
      }
      const simplified = [];
      for (let i = 0; i < len; i++) {
        if (markers[i]) simplified.push(points[i]);
      }
      return simplified;
    };
    const simplifyPolyline = (points, tolerance = FREEHAND_SIMPLIFY_TOLERANCE) => {
      if (!Array.isArray(points) || points.length <= 2) {
        return Array.isArray(points) ? points.slice() : [];
      }
      const sqTolerance = tolerance * tolerance;
      const radial = simplifyRadialDistance(points, sqTolerance);
      return simplifyDouglasPeucker(radial, sqTolerance);
    };
    const distancePointToSegment = (px, py, ax, ay, bx, by) => {
      const abx = bx - ax;
      const aby = by - ay;
      const apx = px - ax;
      const apy = py - ay;
      const abLenSq = abx * abx + aby * aby;
      let t = abLenSq > 0 ? (apx * abx + apy * aby) / abLenSq : 0;
      t = clampRange(t, 0, 1);
      const closestX = ax + abx * t;
      const closestY = ay + aby * t;
      return Math.hypot(px - closestX, py - closestY);
    };
    const pointInPolygon = (vertices, x, y) => {
      let inside = false;
      for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x;
        const yi = vertices[i].y;
        const xj = vertices[j].x;
        const yj = vertices[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * (y - yi)) / ((yj - yi) || 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    };
    const distanceToPolyline = (vertices, x, y, closed = false) => {
      if (vertices.length === 1) {
        return Math.hypot(vertices[0].x - x, vertices[0].y - y);
      }
      let minDistance = Infinity;
      const segmentCount = closed ? vertices.length : vertices.length - 1;
      for (let i = 0; i < segmentCount; i++) {
        const a = vertices[i];
        const b = vertices[(i + 1) % vertices.length];
        const distance = distancePointToSegment(x, y, a.x, a.y, b.x, b.y);
        if (distance < minDistance) {
          minDistance = distance;
        }
      }
      return minDistance;
    };
    const removeShapeById = (shapeId) => {
      if (!shapeId) return;
      const index = editorState.shapes.findIndex((shape) => shape.id === shapeId);
      if (index >= 0) {
        editorState.shapes.splice(index, 1);
        if (editorState.activePolylineId === shapeId) {
          editorState.activePolylineId = null;
          editorState.polylineHoverPoint = null;
          editorState.initialVertices = null;
          editorState.pointerOrigin = null;
          editorState.pointerId = null;
        }
        if (editorState.selectedIds?.size) {
          editorState.selectedIds.delete(shapeId);
          if (editorState.selectedIds.size === 0) {
            editorState.selectedId = null;
          } else if (!editorState.selectedId || !editorState.selectedIds.has(editorState.selectedId)) {
            editorState.selectedId = Array.from(editorState.selectedIds)[0] || null;
          }
          refreshSelectionBounds();
        } else if (editorState.selectedId === shapeId) {
          editorState.selectedId = null;
          refreshSelectionBounds();
        }
        markEditorSidebarDirty();
        editorState.didMutate = true;
      }
    };
    const clearActivePolylineState = ({ pruneIncomplete = false } = {}) => {
      const activeId = editorState.activePolylineId;
      if (pruneIncomplete && activeId) {
        const shape = findShapeById(activeId);
        if (shape && shape.type === "polyline") {
          const vertexCount = Array.isArray(shape.vertices) ? shape.vertices.length : 0;
          if (vertexCount < 2 || (shape.closed && vertexCount < 3)) {
            removeShapeById(activeId);
          }
        }
      }
      editorState.activePolylineId = null;
      editorState.polylineHoverPoint = null;
      editorState.polylinePointerId = null;
      editorState.initialVertices = null;
      editorState.pointerOrigin = null;
      editorState.pointerId = null;
      editorState.polylineExtendArmed = false;
    };
    const finalizeActivePolyline = ({ commit = true } = {}) => {
      const activeId = editorState.activePolylineId;
      if (!activeId) return;
      const shape = findShapeById(activeId);
      clearActivePolylineState();
      if (!shape) {
        renderEditor();
        return;
      }
      const vertexCount = Array.isArray(shape.vertices) ? shape.vertices.length : 0;
      if (!commit || vertexCount < 2 || (shape.closed && vertexCount < 3)) {
        removeShapeById(shape.id);
        renderEditor();
        queuePersist();
        return;
      }
      shape.vertices = normalizeVertices(shape.vertices);
      shape.closed = Boolean(shape.closed);
      ensurePolylineStyle(shape);
      updatePolylineBounds(shape);
      setSelectedShape(shape.id, { suppressRender: true });
      renderEditor();
      queuePersist();
      maybeAutoRevertTool();
    };
    const cancelActivePolyline = () => finalizeActivePolyline({ commit: false });
    const startPolylineAt = (point) => {
      const shape = {
        id: ensureUuid(),
        type: "polyline",
        vertices: [{ ...point }],
        closed: false,
        style: { ...DEFAULT_SHAPE_STYLE },
        rotation: 0,
        interaction: createDefaultInteraction(),
        runtime: { inside: false, hoverInside: false, lastTriggerAt: 0, lastContinuousAt: 0, noteOn: false, eventState: {}, lastMetrics: { normX: 0, normY: 0, distance: 0 } }
      };
      ensurePolylineStyle(shape);
      updatePolylineBounds(shape);
      editorState.shapes.push(shape);
      editorState.activePolylineId = shape.id;
      editorState.polylineHoverPoint = null;
      editorState.polylineExtendArmed = false;
      editorState.didMutate = true;
      editorState.selectedId = null;
      editorState.selectedIds = new Set();
      editorState.selectionBounds = null;
      markEditorSidebarDirty();
      renderEditor();
    };
    const addPolylinePoint = (shape, point) => {
      if (!shape || shape.type !== "polyline" || !point) return;
      const vertices = Array.isArray(shape.vertices) ? shape.vertices : (shape.vertices = []);
      const lastVertex = vertices[vertices.length - 1];
      if (lastVertex && distanceBetween(lastVertex, point) < MIN_POLYLINE_SEGMENT) {
        return;
      }
      vertices.push({ ...point });
      updatePolylineBounds(shape);
      ensurePolylineStyle(shape);
      editorState.didMutate = true;
      markEditorSidebarDirty();
      renderEditor();
    };
    const sanitizeInteractionForStorage = (interaction) => {
      const merged = mergeInteraction(interaction);
      return {
        stream: merged.stream,
        landmark: merged.landmark,
        events: merged.events.map((event) => ({ ...normalizeEvent(event) }))
      };
    };
    const renderOptions = (options, selected) => options.map((option) => `<option value="${escapeHtml(option.id)}"${option.id === selected ? " selected" : ""}>${escapeHtml(option.label)}</option>`).join("");
    const renderEventCard = (event) => {
      const normalized = normalizeEvent(event);
      const typeOptions = renderOptions(EVENT_TYPE_OPTIONS, normalized.type);
      const triggerOptions = renderOptions(EVENT_TRIGGER_OPTIONS, normalized.trigger || "enter");
      const renderModeOptions = (mode) => renderOptions(VALUE_SOURCE_OPTIONS, mode || "constant");
      const velocityValueStyle = normalized.velocityMode === "constant" ? "" : "display:none;";
      const ccValueStyle = normalized.ccValueMode === "constant" ? "" : "display:none;";
      let bodyMarkup = `<div class="event-body"><div class="event-row"><span class="event-empty">Select an event type.</span></div></div>`;
      if (normalized.type === "midiNote") {
        bodyMarkup = `
          <div class="event-body">
            <div class="event-row">
              <label class="field-compact small" title="MIDI Channel">
                <span>Ch</span>
                <input type="number" min="1" max="16" value="${clampRange(Math.floor(normalized.channel ?? 1), 1, 16)}" data-field="channel">
              </label>
              <label class="field-compact small" title="Note">
                <span>Note</span>
                <input type="number" min="0" max="127" value="${clampRange(Math.floor(normalized.note ?? 60), 0, 127)}" data-field="note">
              </label>
            </div>
            <div class="event-row">
              <label class="field-compact" title="Velocity source">
                <span>Vel</span>
                <select data-field="velocityMode">${renderModeOptions(normalized.velocityMode)}</select>
              </label>
              <label class="field-compact" title="Velocity value" style="${velocityValueStyle}">
                <span>Val</span>
                <input type="number" min="0" max="127" value="${clampRange(Math.round(normalized.velocityValue ?? 96), 0, 127)}" data-field="velocityValue">
              </label>
            </div>
          </div>
        `;
      } else if (normalized.type === "midiCc") {
        bodyMarkup = `
          <div class="event-body">
            <div class="event-row">
              <label class="field-compact small" title="MIDI Channel">
                <span>Ch</span>
                <input type="number" min="1" max="16" value="${clampRange(Math.floor(normalized.channel ?? 1), 1, 16)}" data-field="channel">
              </label>
              <label class="field-compact small" title="Control Change number">
                <span>CC#</span>
                <input type="number" min="0" max="127" value="${clampRange(Math.floor(normalized.cc ?? 1), 0, 127)}" data-field="cc">
              </label>
            </div>
            <div class="event-row">
              <label class="field-compact" title="Value source">
                <span>Val</span>
                <select data-field="ccValueMode">${renderModeOptions(normalized.ccValueMode)}</select>
              </label>
              <label class="field-compact" title="Value amount" style="${ccValueStyle}">
                <span>Amt</span>
                <input type="number" min="0" max="127" value="${clampRange(Math.round(normalized.ccValue ?? 100), 0, 127)}" data-field="ccValue">
              </label>
            </div>
          </div>
        `;
      }
      return `
        <div class="event-card" data-event-id="${escapeHtml(normalized.id)}" data-event-type="${escapeHtml(normalized.type || "none")}">
          <div class="event-card-header">
            <select data-field="type">${typeOptions}</select>
            <select data-field="trigger">${triggerOptions}</select>
            <button type="button" class="icon-button event-remove" data-action="remove-event" title="Remove event" aria-label="Remove event">
              <span class="material-icons-outlined" aria-hidden="true">delete</span>
            </button>
          </div>
          ${bodyMarkup}
        </div>
      `;
    };
    const renderEventList = (scope, events = []) => {
      const listEl = scope === "editor" ? editorEventList : assignmentEventList;
      if (!listEl) return;
      const normalizedEvents = events.map(normalizeEvent);
      if (!normalizedEvents.length) {
        listEl.innerHTML = `<div class="event-empty">No events configured.</div>`;
        return;
      }
      listEl.innerHTML = normalizedEvents.map((event) => renderEventCard(event)).join("");
    };
    const getInteractionForScope = (scope) => {
      if (scope === "editor") {
        const shape = findShapeById(editorState.selectedId);
        if (!shape) return null;
        return mergeInteraction(shape.interaction);
      }
      if (!assignmentDraftInteraction) return null;
      return mergeInteraction(assignmentDraftInteraction);
    };
    const refreshEventCard = (scope, eventId) => {
      const listEl = scope === "editor" ? editorEventList : assignmentEventList;
      if (!listEl) return;
      const cards = Array.from(listEl.querySelectorAll(".event-card"));
      const cardEl = cards.find((card) => card.dataset.eventId === eventId);
      if (!cardEl) return;
      const activeEl = document.activeElement;
      const restoreField = activeEl && cardEl.contains(activeEl) ? activeEl.dataset?.field || null : null;
      let selection = null;
      const isInputElement = restoreField && typeof HTMLInputElement !== "undefined" && activeEl instanceof HTMLInputElement;
      if (isInputElement) {
        selection = {
          start: activeEl.selectionStart ?? activeEl.value.length,
          end: activeEl.selectionEnd ?? activeEl.value.length
        };
      }
      const interaction = getInteractionForScope(scope);
      if (!interaction) return;
      const nextEvent = interaction.events.find((evt) => evt.id === eventId);
      if (!nextEvent) return;
      cardEl.outerHTML = renderEventCard(normalizeEvent(nextEvent));
      if (!restoreField) return;
      const updatedCards = Array.from(listEl.querySelectorAll(".event-card"));
      const newCardEl = updatedCards.find((card) => card.dataset.eventId === eventId);
      if (!newCardEl) return;
      const nextFocusEl = newCardEl.querySelector(`[data-field="${restoreField}"]`);
      if (!nextFocusEl) return;
      nextFocusEl.focus({ preventScroll: true });
      const canRestoreSelection = selection && typeof HTMLInputElement !== "undefined" && nextFocusEl instanceof HTMLInputElement;
      if (canRestoreSelection) {
        const start = selection.start ?? nextFocusEl.value.length;
        const end = selection.end ?? start;
        nextFocusEl.setSelectionRange(start, end);
      }
    };
    const syncActiveEventFieldValue = (eventId, field, value) => {
      const activeEl = document.activeElement;
      if (!activeEl) return;
      if (activeEl.dataset?.field !== field) return;
      const cardEl = activeEl.closest(".event-card");
      if (!cardEl || cardEl.dataset.eventId !== eventId) return;
      const stringValue = value === undefined || value === null ? "" : String(value);
      if (activeEl.value !== stringValue) {
        activeEl.value = stringValue;
      }
    };
    const EVENT_CARD_REFRESH_FIELDS = new Set(["velocityMode", "ccValueMode"]);
    const addEventToScope = (scope, type = "midiNote") => {
      if (scope === "editor") {
        mutateSelectedShape((target) => {
          const interaction = mergeInteraction(target.interaction);
          interaction.events = [...interaction.events, createDefaultEvent(type)].map(normalizeEvent);
          target.interaction = interaction;
        }, { skipRender: true });
        syncEditorDetailForm();
        return;
      }
      if (!assignmentDraftInteraction) {
        assignmentDraftInteraction = createDefaultInteraction();
      }
      assignmentDraftInteraction = mergeInteraction({
        ...assignmentDraftInteraction,
        events: [...assignmentDraftInteraction.events, createDefaultEvent(type)]
      });
      syncAssignmentForm();
    };
    const removeEventFromScope = (scope, eventId) => {
      if (!eventId) return;
      if (scope === "editor") {
        mutateSelectedShape((target) => {
          const interaction = mergeInteraction(target.interaction);
          interaction.events = interaction.events.filter((event) => event.id !== eventId);
          target.interaction = interaction;
        }, { skipRender: true });
        syncEditorDetailForm();
        return;
      }
      if (!assignmentDraftInteraction) return;
      assignmentDraftInteraction = mergeInteraction({
        ...assignmentDraftInteraction,
        events: assignmentDraftInteraction.events.filter((event) => event.id !== eventId)
      });
      syncAssignmentForm();
    };
    const updateEventField = (scope, eventId, field, rawValue) => {
      if (!eventId) return;
      const requiresFullSync = field === "type";
      const requiresCardRefresh = EVENT_CARD_REFRESH_FIELDS.has(field);
      const applyUpdate = (interaction) => {
        const working = mergeInteraction(interaction);
        working.events = working.events.map((event) => {
          if (event.id !== eventId) return normalizeEvent(event);
          const current = normalizeEvent(event);
          switch (field) {
            case "type": {
              const nextType = rawValue || "none";
              const replacement = normalizeEvent(createDefaultEvent(nextType));
              replacement.id = current.id;
              replacement.trigger = EVENT_TRIGGER_OPTIONS.some((option) => option.id === current.trigger) ? current.trigger : "enter";
              return replacement;
            }
            case "trigger": {
              const nextTrigger = EVENT_TRIGGER_OPTIONS.some((option) => option.id === rawValue) ? rawValue : "enter";
              syncActiveEventFieldValue(eventId, field, nextTrigger);
              return { ...current, trigger: nextTrigger };
            }
            case "channel": {
              const channelValue = clampRange(parseInt(rawValue, 10) || 1, 1, 16);
              syncActiveEventFieldValue(eventId, field, channelValue);
              return { ...current, channel: channelValue };
            }
            case "note": {
              const noteValue = clampRange(parseInt(rawValue, 10) || 60, 0, 127);
              syncActiveEventFieldValue(eventId, field, noteValue);
              return { ...current, note: noteValue };
            }
            case "velocityMode": {
              const nextVelocityMode = rawValue || "constant";
              syncActiveEventFieldValue(eventId, field, nextVelocityMode);
              return { ...current, velocityMode: nextVelocityMode };
            }
            case "velocityValue": {
              const velocityValue = clampRange(parseInt(rawValue, 10) || 96, 0, 127);
              syncActiveEventFieldValue(eventId, field, velocityValue);
              return { ...current, velocityValue };
            }
            case "cc": {
              const ccValue = clampRange(parseInt(rawValue, 10) || 1, 0, 127);
              syncActiveEventFieldValue(eventId, field, ccValue);
              return { ...current, cc: ccValue };
            }
            case "ccValueMode": {
              const nextCcValueMode = rawValue || "constant";
              syncActiveEventFieldValue(eventId, field, nextCcValueMode);
              return { ...current, ccValueMode: nextCcValueMode };
            }
            case "ccValue": {
              const ccValueAmount = clampRange(parseInt(rawValue, 10) || 100, 0, 127);
              syncActiveEventFieldValue(eventId, field, ccValueAmount);
              return { ...current, ccValue: ccValueAmount };
            }
            default:
              return current;
          }
        });
        return working;
      };
      if (scope === "editor") {
        if (requiresFullSync) {
          mutateSelectedShape((target) => {
            const interaction = mergeInteraction(target.interaction);
            target.interaction = applyUpdate(interaction);
          }, { skipRender: true });
          refreshEventCard("editor", eventId);
          return;
        }
        const shape = findShapeById(editorState.selectedId);
        if (!shape) return;
        const interaction = applyUpdate(shape.interaction);
        shape.interaction = interaction;
        resetShapeRuntime(shape);
        queuePersist();
        if (requiresCardRefresh) {
          refreshEventCard("editor", eventId);
        }
      } else {
        if (!assignmentDraftInteraction) return;
        assignmentDraftInteraction = applyUpdate(assignmentDraftInteraction);
        if (requiresFullSync) {
          syncAssignmentForm();
        } else if (requiresCardRefresh) {
          refreshEventCard("modal", eventId);
        }
      }
    };
    const handleEventListMutation = (scope, domEvent) => {
      const target = domEvent.target;
      const card = target?.closest('.event-card');
      if (!card) return;
      const eventId = card.dataset.eventId;
      const field = target.dataset.field;
      if (!eventId || !field) return;
      if (scope === "editor" && isSyncingEditorForm) return;
      if (scope === "modal" && isSyncingAssignmentForm) return;
      updateEventField(scope, eventId, field, target.value);
    };
    const syncAssignmentForm = () => {
      if (!assignmentStreamSelect) return;
      isSyncingAssignmentForm = true;
      const draft = assignmentDraftInteraction ? mergeInteraction(assignmentDraftInteraction) : createDefaultInteraction();
      const stream = draft.stream || "pose";
      assignmentStreamSelect.value = stream;
      const resolvedLandmark = populateLandmarkOptions(stream, draft.landmark, assignmentLandmarkSelect) || draft.landmark;
      if (assignmentLandmarkSelect && resolvedLandmark) {
        assignmentLandmarkSelect.value = resolvedLandmark;
      }
      populateMidiPortSelect(assignmentMidiPortSelect, editorConfig.midiPort);
      if (assignmentMidiPortSelect) assignmentMidiPortSelect.dataset.selectedPort = editorConfig.midiPort;
      renderEventList("modal", draft.events);
      isSyncingAssignmentForm = false;
    };
    const getShapeStyle = (shape) => ({
      stroke: shape?.style?.stroke ?? DEFAULT_SHAPE_STYLE.stroke,
      fill: shape?.style?.fill ?? DEFAULT_SHAPE_STYLE.fill,
      strokeWidth: shape?.style?.strokeWidth ?? DEFAULT_SHAPE_STYLE.strokeWidth
    });
    const shapeToSvgMarkup = (shape, viewportWidth, viewportHeight) => {
      if (!shape) return "";
      const style = getShapeStyle(shape);
      const rotation = normalizeAngle(shape.rotation || 0);
      if (shape.type === "polyline") {
        const vertices = normalizeVertices(shape.vertices || []);
        if (!vertices.length) return "";
        const pointsAttribute = vertices.map((vertex) => `${(vertex.x * viewportWidth).toFixed(2)} ${(vertex.y * viewportHeight).toFixed(2)}`).join(" ");
        if (shape.closed && vertices.length >= 3) {
          return `<polygon points="${pointsAttribute}" fill="${style.fill}" stroke="${style.stroke}" stroke-width="${style.strokeWidth}"></polygon>`;
        }
        return `<polyline points="${pointsAttribute}" fill="none" stroke="${style.stroke}" stroke-width="${style.strokeWidth}" stroke-linecap="round" stroke-linejoin="round"></polyline>`;
      }
      const x = (shape.x ?? 0) * viewportWidth;
      const y = (shape.y ?? 0) * viewportHeight;
      const w = Math.max((shape.width ?? 0) * viewportWidth, 0);
      const h = Math.max((shape.height ?? 0) * viewportHeight, 0);
      if (w <= 0 || h <= 0) return "";
      if (shape.type === "ellipse") {
        const cx = x + w / 2;
        const cy = y + h / 2;
        const transformAttr = rotation ? ` transform="rotate(${(rotation * RAD_TO_DEG).toFixed(4)} ${cx.toFixed(2)} ${cy.toFixed(2)})"` : "";
        return `<ellipse cx="${cx.toFixed(2)}" cy="${cy.toFixed(2)}" rx="${(w / 2).toFixed(2)}" ry="${(h / 2).toFixed(2)}" fill="${style.fill}" stroke="${style.stroke}" stroke-width="${style.strokeWidth}"${transformAttr}></ellipse>`;
      }
      const cx = x + w / 2;
      const cy = y + h / 2;
      const transformAttr = rotation ? ` transform="rotate(${(rotation * RAD_TO_DEG).toFixed(4)} ${cx.toFixed(2)} ${cy.toFixed(2)})"` : "";
      return `<rect x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${w.toFixed(2)}" height="${h.toFixed(2)}" fill="${style.fill}" stroke="${style.stroke}" stroke-width="${style.strokeWidth}"${transformAttr}></rect>`;
    };
    const generateScoreSvg = (shapes = editorState.shapes, viewport = editorState.viewport) => {
      const viewportWidth = viewport.width || DEFAULT_WIDTH;
      const viewportHeight = viewport.height || DEFAULT_HEIGHT;
      const markup = shapes.map((shape) => shapeToSvgMarkup(shape, viewportWidth, viewportHeight)).filter(Boolean).join("");
      return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${viewportWidth} ${viewportHeight}" fill="none">${markup}</svg>`;
    };
    const serializeShapes = () => {
      const viewportWidth = editorState.viewport.width || DEFAULT_WIDTH;
      const viewportHeight = editorState.viewport.height || DEFAULT_HEIGHT;
      return editorState.shapes.map((shape) => ({
        id: shape.id,
        type: shape.type,
        x: shape.x,
        y: shape.y,
        width: shape.width,
        height: shape.height,
        rotation: typeof shape.rotation === "number" ? shape.rotation : 0,
        style: shape.style,
        interaction: sanitizeInteractionForStorage(shape.interaction),
        vertices: shape.vertices,
        closed: shape.closed ?? false,
        svg: shapeToSvgMarkup(shape, viewportWidth, viewportHeight)
      }));
    };
    const queuePersist = () => {
      if (typeof localStorage === "undefined") return;
      if (persistTimer) {
        clearTimeout(persistTimer);
      }
      persistTimer = window.setTimeout(() => {
        try {
          const payload = serializeShapes();
          localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
          const svgMarkup = generateScoreSvg();
          localStorage.setItem(STORAGE_KEY_SVG, svgMarkup);
        } catch (err) {
          console.warn("Failed to persist editor state", err);
        } finally {
          persistTimer = null;
        }
      }, 220);
    };
    const serializeOverlayState = () => {
      const snapshot = { mirror: Boolean(overlayState.mirror) };
      for (const key of Object.keys(overlayControls)) {
        const source = overlayState[key] || DEFAULT_OVERLAY_STATE[key] || { main: false, preview: false };
        snapshot[key] = {
          main: Boolean(source.main),
          preview: Boolean(source.preview)
        };
      }
      return snapshot;
    };
    const applyOverlaySnapshot = (snapshot) => {
      if (!snapshot || typeof snapshot !== "object") return;
      for (const [key, controls] of Object.entries(overlayControls)) {
        const defaults = DEFAULT_OVERLAY_STATE[key] || { main: false, preview: false };
        const target = snapshot[key];
        const mainValue = typeof target?.main === "boolean" ? target.main : defaults.main;
        const previewValue = typeof target?.preview === "boolean" ? target.preview : defaults.preview;
        if (controls.main) controls.main.checked = mainValue;
        if (controls.preview) controls.preview.checked = previewValue;
      }
      if (mirrorCheckbox) {
        const mirrorValue = typeof snapshot.mirror === "boolean" ? snapshot.mirror : DEFAULT_OVERLAY_STATE.mirror;
        mirrorCheckbox.checked = mirrorValue;
      }
      updateOverlayState();
    };
    const createSnapshotPayload = () => ({
      version: SNAPSHOT_VERSION,
      createdAt: new Date().toISOString(),
      config: { ...editorConfig },
      overlay: serializeOverlayState(),
      shapes: serializeShapes()
    });
    const formatSnapshotFilename = () => {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      return `${SNAPSHOT_FILE_PREFIX}-${timestamp}.json`;
    };
    const applySnapshotPayload = (payload) => {
      if (!payload || typeof payload !== "object") {
        throw new Error("Invalid snapshot payload");
      }
      if (payload.version && payload.version > SNAPSHOT_VERSION) {
        console.warn(`Snapshot version ${payload.version} is newer than supported version ${SNAPSHOT_VERSION}. Attempting to apply anyway.`);
      }
      closeAssignmentModal();
      const appliedShapes = Array.isArray(payload.shapes)
        ? loadPersistedShapes(payload.shapes)
        : false;
      if (!appliedShapes) {
        editorState.shapes = [];
        markEditorSidebarDirty();
      }
      const configSource = payload.config;
      if (configSource && typeof configSource === "object") {
        const patch = {};
        if (typeof configSource.midiPort === "string" && configSource.midiPort.trim()) {
          patch.midiPort = configSource.midiPort.trim();
        }
        if (typeof configSource.backgroundOpacity === "number") {
          patch.backgroundOpacity = Math.max(0, Math.min(1, configSource.backgroundOpacity));
        }
        if (Object.keys(patch).length) {
          updateEditorConfig(patch);
        } else {
          applyGlobalConnectionConfig();
        }
      } else {
        applyGlobalConnectionConfig();
      }
      if (payload.overlay && typeof payload.overlay === "object") {
        applyOverlaySnapshot(payload.overlay);
      } else {
        updateOverlayState();
      }
      editorState.shapes.forEach((shape) => resetShapeRuntime(shape));
      editorState.selectedId = null;
      editorState.activePolylineId = null;
      editorState.polylineHoverPoint = null;
      editorState.drawingShapeId = null;
      editorState.dragHandle = null;
      editorState.selectionBounds = null;
      editorState.selectionMarquee = null;
      markEditorSidebarDirty();
      if (isMapModalOpen()) {
        updateEditorSidebar();
      }
      syncEditorDetailForm();
      renderEditor();
      queuePersist();
    };
    const exportSnapshot = () => {
      try {
        const payload = createSnapshotPayload();
        const json = JSON.stringify(payload, null, 2);
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement("a");
        anchor.href = url;
        anchor.download = formatSnapshotFilename();
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
        URL.revokeObjectURL(url);
        applyStatus("Snapshot exported");
      } catch (err) {
        console.warn("Snapshot export failed", err);
        applyStatus("Snapshot export failed");
      }
    };
    const handleSnapshotFile = async (file) => {
      if (!file) return;
      try {
        const text = await file.text();
        const payload = JSON.parse(text);
        applySnapshotPayload(payload);
        applyStatus("Snapshot imported");
      } catch (err) {
        console.warn("Snapshot import failed", err);
        applyStatus("Snapshot import failed");
      }
    };
    const handleSnapshotImportChange = async (event) => {
      const file = event.target?.files?.[0];
      if (file) {
        await handleSnapshotFile(file);
      }
      if (snapshotImportInput) {
        snapshotImportInput.value = "";
      }
    };
    const loadPersistedShapes = (providedShapes = null, { persist = false } = {}) => {
      let data = providedShapes;
      if (!Array.isArray(data)) {
        if (typeof localStorage === "undefined") return false;
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return false;
          data = JSON.parse(raw);
        } catch (err) {
          console.warn("Failed to parse stored shapes", err);
          return false;
        }
      }
      if (!Array.isArray(data)) return false;
      editorState.shapes = data.map((shape) => {
        const type = shape.type === "ellipse" ? "ellipse" : (shape.type === "polyline" ? "polyline" : "rect");
        const mergedInteraction = migrateLegacyInteraction(shape.interaction);
        const normalized = {
          id: shape.id || ensureUuid(),
          type,
          x: clampUnit(shape.x ?? 0),
          y: clampUnit(shape.y ?? 0),
          width: clampRange(shape.width ?? SHAPE_MIN_SIZE, SHAPE_MIN_SIZE, 1),
          height: clampRange(shape.height ?? SHAPE_MIN_SIZE, SHAPE_MIN_SIZE, 1),
          rotation: typeof shape.rotation === "number" ? normalizeAngle(shape.rotation) : 0,
          style: { ...DEFAULT_SHAPE_STYLE, ...(shape.style || {}) },
          interaction: mergedInteraction,
          runtime: {
            inside: false,
            lastTriggerAt: 0,
            lastContinuousAt: 0,
            noteOn: false,
            eventState: {},
            lastMetrics: { normX: 0, normY: 0, distance: 0 }
          }
        };
        if (type === "polyline") {
          normalized.vertices = normalizeVertices(shape.vertices);
          normalized.closed = Boolean(shape.closed);
          ensurePolylineStyle(normalized);
          updatePolylineBounds(normalized);
        }
        return normalized;
      });
      editorState.selectedId = null;
      editorState.activePolylineId = null;
      editorState.polylineHoverPoint = null;
      editorState.drawingShapeId = null;
      editorState.dragHandle = null;
      markEditorSidebarDirty();
      if (persist) {
        queuePersist();
      }
      return true;
    };

    const ensureUuid = () => (typeof crypto !== "undefined" && crypto?.randomUUID
      ? crypto.randomUUID()
      : `shape-${Math.random().toString(36).slice(2, 10)}`);

    const clampRange = (value, min, max) => Math.min(max, Math.max(min, value));
    const clampUnit = (value) => clampRange(value, 0, 1);
    const getSurfaceOpacity = () => clampUnit(typeof globalThis.__mediamimeSurfaceOpacity === "number"
      ? globalThis.__mediamimeSurfaceOpacity
      : 1);
    if (typeof globalThis.__mediamimeSurfaceOpacity !== "number") {
      globalThis.__mediamimeSurfaceOpacity = 1;
    }
    const setBackgroundOpacity = (value) => {
      const alpha = clampUnit(typeof value === "number" ? value : Number.parseFloat(value) || 0);
      document.documentElement.style.setProperty("--surface-opacity", `${alpha}`);
      globalThis.__mediamimeSurfaceOpacity = alpha;
    };

    const setEditorViewport = (width, height) => {
      editorState.viewport.width = width || DEFAULT_WIDTH;
      editorState.viewport.height = height || DEFAULT_HEIGHT;
      if (gestureSvg) {
        gestureSvg.setAttribute("viewBox", `0 0 ${editorState.viewport.width} ${editorState.viewport.height}`);
      }
    };

    const setEditorMirrorActive = (enabled) => {
      editorState.mirror = Boolean(enabled);
      if (gestureSvgWrapper) {
        gestureSvgWrapper.classList.toggle("is-mirrored", editorState.mirror);
      }
    };

    const toSvgPoint = (event) => {
      if (!gestureSvg) return null;
      const rect = gestureSvg.getBoundingClientRect();
      if (!rect.width || !rect.height) return null;
      const viewportWidth = editorState.viewport.width || DEFAULT_WIDTH;
      const viewportHeight = editorState.viewport.height || DEFAULT_HEIGHT;
      if (!viewportWidth || !viewportHeight) return null;
      const scale = Math.min(rect.width / viewportWidth, rect.height / viewportHeight) || 0;
      if (!scale) return null;
      const contentWidth = viewportWidth * scale;
      const contentHeight = viewportHeight * scale;
      const offsetX = rect.left + (rect.width - contentWidth) / 2;
      const offsetY = rect.top + (rect.height - contentHeight) / 2;
      const relativeX = (event.clientX - offsetX) / contentWidth;
      const relativeY = (event.clientY - offsetY) / contentHeight;
      if (!Number.isFinite(relativeX) || !Number.isFinite(relativeY)) return null;
      const clampedX = clampRange(relativeX, 0, 1);
      const clampedY = clampRange(relativeY, 0, 1);
      const unmirroredX = clampedX * viewportWidth;
      const x = editorState.mirror
        ? viewportWidth - unmirroredX
        : unmirroredX;
      const y = clampedY * viewportHeight;
      return { x, y };
    };

    const toNormalizedPoint = (svgPoint) => ({
      x: clampUnit(svgPoint.x / editorState.viewport.width),
      y: clampUnit(svgPoint.y / editorState.viewport.height)
    });

    const findShapeById = (id) => editorState.shapes.find((shape) => shape.id === id);

    const updateToolButtons = () => {
      for (const [tool, button] of Object.entries(gestureToolButtons)) {
        if (!button) continue;
        button.classList.toggle("is-active", editorState.tool === tool);
        button.disabled = editorState.mode === "perform";
      }
    };

    const updateModeToggleLabel = () => {
      if (!gestureModeToggle) return;
      const icon = gestureModeToggle.querySelector(".material-icons-outlined");
      if (icon) {
        icon.textContent = editorState.mode === "perform" ? "draw" : "play_circle";
      }
      gestureModeToggle.setAttribute("aria-pressed", editorState.mode === "perform" ? "true" : "false");
    };

    const renderEditor = () => {
      if (!gestureSvg) return;
      const scoreVisible = isScoreMainEnabled();
      if (!scoreVisible) {
        clearActivePolylineState({ pruneIncomplete: true });
        gestureSvg.innerHTML = "";
        return;
      }
      const { width, height } = editorState.viewport;
      const selectedIds = getSelectedIds();
      const primarySelectedId = (editorState.selectedId && editorState.selectedIds?.has(editorState.selectedId))
        ? editorState.selectedId
        : (selectedIds[0] || null);
      const selectedShape = primarySelectedId ? findShapeById(primarySelectedId) : null;
      const selectionBounds = editorState.selectionBounds || (selectedIds.length ? computeSelectionBounds(selectedIds) : null);
      let previewMarkup = "";
      const shapesMarkup = editorState.shapes.map((shape) => {
        const classes = ["gesture-shape"];
        if (editorState.selectedIds?.has(shape.id)) {
          classes.push("is-selected");
        }
        if (shape.id === editorState.hoverShapeId && editorState.tool === "select") {
          classes.push("is-hovered");
        }
        if (shape.runtime?.hoverInside || shape.runtime?.inside) {
          classes.push("is-active");
        }
        const className = classes.join(" ");
        const baseFill = shape.style?.fill ?? DEFAULT_SHAPE_STYLE.fill;
        const baseStroke = shape.style?.stroke ?? DEFAULT_SHAPE_STYLE.stroke;
        const strokeWidth = shape.style?.strokeWidth ?? DEFAULT_SHAPE_STYLE.strokeWidth;
        const isActive = Boolean(shape.runtime?.hoverInside || shape.runtime?.inside);
        const strokeColor = isActive ? ACTIVE_STROKE_COLOR : baseStroke;
        const fillColor = isActive && baseFill !== "none" ? ACTIVE_FILL_COLOR : baseFill;
        if (shape.type === "polyline") {
          const vertices = normalizeVertices(shape.vertices);
          const pointsAttribute = vertices.map((vertex) => `${vertex.x * width} ${vertex.y * height}`).join(" ");
          const isActivePolyline = editorState.activePolylineId === shape.id;
          const hoverPoint = isActivePolyline ? editorState.polylineHoverPoint : null;
          if (isActivePolyline && hoverPoint && vertices.length) {
            const lastVertex = vertices[vertices.length - 1];
            const hoverX = hoverPoint.x * width;
            const hoverY = hoverPoint.y * height;
            previewMarkup += `<line class="gesture-polyline-preview" x1="${lastVertex.x * width}" y1="${lastVertex.y * height}" x2="${hoverX}" y2="${hoverY}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="4 4"></line>`;
            if (shape.closed && vertices.length >= 2) {
              const firstVertex = vertices[0];
              previewMarkup += `<line class="gesture-polyline-preview" x1="${hoverX}" y1="${hoverY}" x2="${firstVertex.x * width}" y2="${firstVertex.y * height}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="4 4"></line>`;
            }
          }
          const commonAttrs = `data-shape-id="${shape.id}" data-shape-type="polyline" class="${className}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round"`;
          if (shape.closed && vertices.length >= 3) {
            const polygonFill = fillColor === "none" ? "none" : fillColor;
            return `<polygon ${commonAttrs} points="${pointsAttribute}" fill="${polygonFill}"></polygon>`;
          }
          return `<polyline ${commonAttrs} points="${pointsAttribute}" fill="none"></polyline>`;
        }
        const x = shape.x * width;
        const y = shape.y * height;
        const w = Math.max(shape.width * width, 0);
        const h = Math.max(shape.height * height, 0);
        if (shape.type === "ellipse") {
          const cx = x + w / 2;
          const cy = y + h / 2;
          const ellipseFill = fillColor === "none" ? "none" : fillColor;
          const rotation = normalizeAngle(shape.rotation || 0);
          const transformAttr = rotation ? ` transform="rotate(${(rotation * RAD_TO_DEG).toFixed(4)}, ${cx}, ${cy})"` : "";
          return `<ellipse data-shape-id="${shape.id}" data-shape-type="ellipse" class="${className}" cx="${cx}" cy="${cy}" rx="${Math.max(w / 2, 1)}" ry="${Math.max(h / 2, 1)}" fill="${ellipseFill}" stroke="${strokeColor}" stroke-width="${strokeWidth}"${transformAttr}></ellipse>`;
        }
        const rectFill = fillColor === "none" ? "none" : fillColor;
        const rotation = normalizeAngle(shape.rotation || 0);
        const centerX = x + w / 2;
        const centerY = y + h / 2;
        const transformAttr = rotation ? ` transform="rotate(${(rotation * RAD_TO_DEG).toFixed(4)}, ${centerX}, ${centerY})"` : "";
        return `<rect data-shape-id="${shape.id}" data-shape-type="rect" class="${className}" x="${x}" y="${y}" width="${Math.max(w, 1)}" height="${Math.max(h, 1)}" fill="${rectFill}" stroke="${strokeColor}" stroke-width="${strokeWidth}"${transformAttr}></rect>`;
      }).join("");
      let transformMarkup = "";
      let vertexHandlesMarkup = "";
      const selectionFrame = editorState.selectionFrame;
      if (selectionFrame) {
        const frameRotation = normalizeAngle(selectionFrame.rotation || 0);
        const cx = selectionFrame.centerX * width;
        const cy = selectionFrame.centerY * height;
        const sw = Math.max(selectionFrame.width * width, 2);
        const sh = Math.max(selectionFrame.height * height, 2);
        const rotationDeg = (frameRotation * RAD_TO_DEG).toFixed(4);
        transformMarkup = `
          <g class="gesture-selection-group" transform="translate(${cx}, ${cy}) rotate(${rotationDeg})">
            <rect class="gesture-selection-outline" x="${-(sw / 2)}" y="${-(sh / 2)}" width="${sw}" height="${sh}"></rect>
          </g>
        `;
      } else if (selectionBounds) {
        const sx = selectionBounds.minX * width;
        const sy = selectionBounds.minY * height;
        const sw = Math.max(selectionBounds.width * width, 2);
        const sh = Math.max(selectionBounds.height * height, 2);
        transformMarkup = `
          <g class="gesture-selection-group">
            <rect class="gesture-selection-outline" x="${sx}" y="${sy}" width="${sw}" height="${sh}"></rect>
          </g>
        `;
      }
      if (selectedShape && selectedIds.length === 1 && selectedShape.type === "polyline") {
        const vertices = normalizeVertices(selectedShape.vertices);
        vertexHandlesMarkup = vertices.map((vertex, index) => {
          const vx = clampUnit(vertex.x) * width;
          const vy = clampUnit(vertex.y) * height;
          return `<circle class="gesture-vertex-handle" data-handle="vertex-${index}" cx="${vx}" cy="${vy}" r="7"></circle>`;
        }).join("");
        if (vertexHandlesMarkup) {
          vertexHandlesMarkup = `<g data-selected-controls="${selectedShape.id}" class="gesture-polyline-controls">${vertexHandlesMarkup}</g>`;
        }
      }
      let marqueeMarkup = "";
      if (editorState.selectionMarquee) {
        const { anchor, current } = editorState.selectionMarquee;
        if (anchor && current) {
          const minX = Math.min(anchor.x, current.x) * width;
          const minY = Math.min(anchor.y, current.y) * height;
          const w = Math.abs(anchor.x - current.x) * width;
          const h = Math.abs(anchor.y - current.y) * height;
          marqueeMarkup = `<rect class="gesture-selection-marquee" x="${minX}" y="${minY}" width="${w}" height="${h}"></rect>`;
        }
      }
      gestureSvg.innerHTML = `<g class="gesture-shapes">${shapesMarkup}${previewMarkup}</g>${transformMarkup}${vertexHandlesMarkup}${marqueeMarkup}`;
      if (editorSidebarDirty && isMapModalOpen()) {
        updateEditorSidebar();
      }
    };

    const drawScorePreview = (ctx, canvasWidth, canvasHeight) => {
      if (!isScorePreviewEnabled() || !editorState.shapes.length) return;
      ctx.save();
      for (const shape of editorState.shapes) {
        const baseFill = shape.style?.fill ?? DEFAULT_SHAPE_STYLE.fill;
        const baseStroke = shape.style?.stroke ?? DEFAULT_SHAPE_STYLE.stroke;
        const strokeWidth = shape.style?.strokeWidth ?? DEFAULT_SHAPE_STYLE.strokeWidth;
        const isActive = Boolean(shape.runtime?.inside);
        const strokeColor = isActive ? ACTIVE_PREVIEW_STROKE_COLOR : baseStroke;
        const fillColor = isActive && baseFill !== "none" ? ACTIVE_PREVIEW_FILL_COLOR : baseFill;
        ctx.globalAlpha = 1;
        if (shape.type === "polyline") {
          const vertices = normalizeVertices(shape.vertices);
          if (!vertices.length) continue;
          ctx.save();
          ctx.beginPath();
          const first = vertices[0];
          ctx.moveTo(first.x * canvasWidth, first.y * canvasHeight);
          for (let i = 1; i < vertices.length; i++) {
            const vertex = vertices[i];
            ctx.lineTo(vertex.x * canvasWidth, vertex.y * canvasHeight);
          }
          if (shape.closed && vertices.length >= 3) {
            ctx.closePath();
            if (fillColor && fillColor !== "none") {
              ctx.fillStyle = fillColor;
              ctx.globalAlpha = 0.7;
              ctx.fill();
              ctx.globalAlpha = 1;
            }
          }
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.stroke();
          ctx.restore();
          continue;
        }
        const x = shape.x * canvasWidth;
        const y = shape.y * canvasHeight;
        const w = Math.max(shape.width * canvasWidth, 0);
        const h = Math.max(shape.height * canvasHeight, 0);
        const rotation = normalizeAngle(shape.rotation || 0);
        if (shape.type === "ellipse") {
          const radiusX = Math.max(w / 2, 1);
          const radiusY = Math.max(h / 2, 1);
          const centerX = x + w / 2;
          const centerY = y + h / 2;
          ctx.save();
          ctx.translate(centerX, centerY);
          if (rotation) {
            ctx.rotate(rotation);
          }
          ctx.beginPath();
          ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
          if (fillColor && fillColor !== "none") {
            ctx.fillStyle = fillColor;
            ctx.globalAlpha = 0.7;
            ctx.fill();
          }
          ctx.globalAlpha = 1;
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
          ctx.restore();
        } else {
          const centerX = x + w / 2;
          const centerY = y + h / 2;
          ctx.save();
          ctx.translate(centerX, centerY);
          if (rotation) {
            ctx.rotate(rotation);
          }
          if (fillColor && fillColor !== "none") {
            ctx.fillStyle = fillColor;
            ctx.globalAlpha = 0.7;
            ctx.fillRect(-w / 2, -h / 2, w, h);
          }
          ctx.globalAlpha = 1;
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.strokeRect(-w / 2, -h / 2, w, h);
          ctx.restore();
        }
      }
      ctx.restore();
    };

    function getSelectedIds() {
      return Array.from(editorState.selectedIds || []);
    }
    function getShapeAabb(shape) {
      if (!shape) return null;
      if (shape.type === "polyline") {
        const { minX, minY, maxX, maxY } = computePolylineBounds(shape.vertices || []);
        return { minX, minY, maxX, maxY };
      }
      const corners = getRectCorners(shape);
      let minX = 1;
      let minY = 1;
      let maxX = 0;
      let maxY = 0;
      for (const corner of corners) {
        minX = Math.min(minX, corner.x);
        minY = Math.min(minY, corner.y);
        maxX = Math.max(maxX, corner.x);
        maxY = Math.max(maxY, corner.y);
      }
      return { minX, minY, maxX, maxY };
    }
    function computeSelectionBounds(shapeIds = getSelectedIds()) {
      const ids = Array.isArray(shapeIds) ? shapeIds : [];
      if (!ids.length) return null;
      let minX = 1;
      let minY = 1;
      let maxX = 0;
      let maxY = 0;
      for (const id of ids) {
        const shape = findShapeById(id);
        const bounds = getShapeAabb(shape);
        if (!bounds) continue;
        minX = Math.min(minX, bounds.minX);
        minY = Math.min(minY, bounds.minY);
        maxX = Math.max(maxX, bounds.maxX);
        maxY = Math.max(maxY, bounds.maxY);
      }
      if (maxX <= minX) {
        maxX = Math.min(1, minX + MIN_METRIC_SPAN);
      }
      if (maxY <= minY) {
        maxY = Math.min(1, minY + MIN_METRIC_SPAN);
      }
      const width = clampRange(maxX - minX, MIN_METRIC_SPAN, 1);
      const height = clampRange(maxY - minY, MIN_METRIC_SPAN, 1);
      const centerX = clampUnit(minX + width / 2);
      const centerY = clampUnit(minY + height / 2);
      return { minX, minY, maxX, maxY, x: minX, y: minY, width, height, centerX, centerY };
    }
    const cloneSelectionFrame = (frame) => frame ? {
      centerX: frame.centerX,
      centerY: frame.centerY,
      width: frame.width,
      height: frame.height,
      rotation: frame.rotation || 0
    } : null;
    const toSelectionLocal = (point, frame) => {
      if (!frame || !point) return null;
      const rotation = normalizeAngle(frame.rotation || 0);
      const cos = Math.cos(-rotation);
      const sin = Math.sin(-rotation);
      const dx = (point.x ?? 0) - frame.centerX;
      const dy = (point.y ?? 0) - frame.centerY;
      return {
        x: dx * cos - dy * sin,
        y: dx * sin + dy * cos
      };
    };
    const fromSelectionLocal = (point, frame) => {
      if (!frame || !point) return null;
      const rotation = normalizeAngle(frame.rotation || 0);
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      return {
        x: cos * point.x - sin * point.y + frame.centerX,
        y: sin * point.x + cos * point.y + frame.centerY
      };
    };
    const getSharedRotation = (shapeIds) => {
      let rotation = null;
      for (const id of shapeIds) {
        const shape = findShapeById(id);
        if (!shape) continue;
        const value = normalizeAngle(typeof shape.rotation === "number" ? shape.rotation : 0);
        if (rotation === null) {
          rotation = value;
        } else if (Math.abs(normalizeAngle(rotation - value)) > 1e-3) {
          return null;
        }
      }
      return rotation;
    };
    function updateSelectionFrame({ preserveRotation = false, frameOverride = null } = {}) {
      if (frameOverride) {
        editorState.selectionFrame = cloneSelectionFrame(frameOverride);
        return;
      }
      const ids = getSelectedIds();
      if (!ids.length) {
        editorState.selectionFrame = null;
        return;
      }
      const bounds = editorState.selectionBounds || computeSelectionBounds(ids);
      if (!bounds) {
        editorState.selectionFrame = null;
        return;
      }
      let centerX = bounds.centerX;
      let centerY = bounds.centerY;
      let width = bounds.width;
      let height = bounds.height;
      let rotation = 0;
      const previousRotation = editorState.selectionFrame?.rotation || 0;
      if (preserveRotation && editorState.selectionFrame) {
        rotation = previousRotation;
      } else if (ids.length === 1) {
        const shape = findShapeById(ids[0]);
        if (shape) {
          rotation = normalizeAngle(shape.rotation || 0);
          if (shape.type !== "polyline") {
            const shapeWidth = Math.max(shape.width ?? bounds.width, MIN_METRIC_SPAN);
            const shapeHeight = Math.max(shape.height ?? bounds.height, MIN_METRIC_SPAN);
            width = shapeWidth;
            height = shapeHeight;
            centerX = clampUnit((shape.x ?? 0) + shapeWidth / 2);
            centerY = clampUnit((shape.y ?? 0) + shapeHeight / 2);
          }
        }
      } else {
        const shared = getSharedRotation(ids);
        rotation = shared !== null ? shared : (preserveRotation ? previousRotation : 0);
      }
      editorState.selectionFrame = {
        centerX,
        centerY,
        width: Math.max(width, MIN_METRIC_SPAN),
        height: Math.max(height, MIN_METRIC_SPAN),
        rotation
      };
    }
    function refreshSelectionBounds(options = {}) {
      const { preserveRotation = false, frameOverride = null } = options;
      if (editorState.selectedIds && editorState.selectedIds.size) {
        editorState.selectionBounds = computeSelectionBounds(getSelectedIds());
        updateSelectionFrame({ preserveRotation, frameOverride });
      } else {
        editorState.selectionBounds = null;
        if (!frameOverride) {
          editorState.selectionFrame = null;
        }
      }
    }
    function getShapesInBounds(minX, minY, maxX, maxY, { contain = false } = {}) {
      if (!editorState.shapes.length) return [];
      const shapes = [];
      const safeMinX = clampUnit(Math.min(minX, maxX));
      const safeMaxX = clampUnit(Math.max(minX, maxX));
      const safeMinY = clampUnit(Math.min(minY, maxY));
      const safeMaxY = clampUnit(Math.max(minY, maxY));
      for (const shape of editorState.shapes) {
        const bounds = getShapeAabb(shape);
        if (!bounds) continue;
        if (contain) {
          const inside = bounds.minX >= safeMinX && bounds.maxX <= safeMaxX && bounds.minY >= safeMinY && bounds.maxY <= safeMaxY;
          if (inside) shapes.push(shape.id);
        } else {
          const overlaps = bounds.maxX >= safeMinX && bounds.minX <= safeMaxX && bounds.maxY >= safeMinY && bounds.minY <= safeMaxY;
          if (overlaps) shapes.push(shape.id);
        }
      }
      return shapes;
    }
    function setSelectedShapes(shapeIds, { append = false, suppressRender = false } = {}) {
      const nextIds = new Set(append ? getSelectedIds() : []);
      const incoming = Array.isArray(shapeIds) ? shapeIds.filter(Boolean) : [];
      if (!append) {
        editorState.selectedId = null;
      }
      incoming.forEach((id, index) => {
        nextIds.add(id);
        if (index === 0 && !editorState.selectedId) {
          editorState.selectedId = id;
        }
      });
      if (!incoming.length && !append) {
        editorState.selectedId = null;
      } else if (!incoming.length && append && !nextIds.size) {
        editorState.selectedId = null;
      } else if (!nextIds.has(editorState.selectedId)) {
        editorState.selectedId = nextIds.size ? Array.from(nextIds)[0] : null;
      }
      const changed = (() => {
        if (editorState.selectedIds?.size !== nextIds.size) return true;
        for (const id of nextIds) {
          if (!editorState.selectedIds.has(id)) return true;
        }
        return false;
      })();
      editorState.selectedIds = nextIds;
      refreshSelectionBounds();
      if (!nextIds.size) {
        editorState.activePolylineId = null;
        editorState.polylineHoverPoint = null;
      }
      if (!changed) {
        if (isMapModalOpen()) {
          syncEditorDetailForm();
        }
        return;
      }
      markEditorSidebarDirty();
      if (suppressRender) {
        if (isMapModalOpen()) {
          updateEditorSidebar();
        }
      } else {
        renderEditor();
      }
      if (!nextIds.size) {
        setSelectionCursor(null);
      }
    }
    function setSelectedShape(shapeId, options = {}) {
      if (!shapeId) {
        setSelectedShapes([], options);
      } else {
        setSelectedShapes([shapeId], options);
      }
    }
    const EDGE_HANDLE_TOLERANCE_PX = 12;
    const CORNER_HANDLE_TOLERANCE_PX = 18;
    const ROTATION_HANDLE_BAND_PX = 28;
    function getUnclampedNormalizedPoint(event) {
      if (!gestureSvg) return null;
      const rect = gestureSvg.getBoundingClientRect();
      const viewportWidth = editorState.viewport.width || DEFAULT_WIDTH;
      const viewportHeight = editorState.viewport.height || DEFAULT_HEIGHT;
      const scale = Math.min(rect.width / viewportWidth, rect.height / viewportHeight) || 0;
      if (!scale) return null;
      const contentWidth = viewportWidth * scale;
      const contentHeight = viewportHeight * scale;
      const offsetX = rect.left + (rect.width - contentWidth) / 2;
      const offsetY = rect.top + (rect.height - contentHeight) / 2;
      const relativeX = ((event.clientX ?? 0) - offsetX) / contentWidth;
      const relativeY = ((event.clientY ?? 0) - offsetY) / contentHeight;
      const normalizedX = editorState.mirror ? 1 - relativeX : relativeX;
      return { x: normalizedX, y: relativeY };
    }
    function resolveSelectionHandle(point, { allowRotation = true, rawPoint = null } = {}) {
      const frame = editorState.selectionFrame;
      const bounds = editorState.selectionBounds;
      if (!frame || !bounds) return null;
      const viewWidth = editorState.viewport.width || DEFAULT_WIDTH;
      const viewHeight = editorState.viewport.height || DEFAULT_HEIGHT;
      const localPoint = toSelectionLocal(point, frame);
      const rawLocalPoint = rawPoint ? toSelectionLocal(rawPoint, frame) : localPoint;
      if (!localPoint || !rawLocalPoint) return null;
      const halfWidth = frame.width / 2;
      const halfHeight = frame.height / 2;
      const edgeThresholdX = Math.min(EDGE_HANDLE_TOLERANCE_PX, Math.max(frame.width * viewWidth / 2, 1));
      const edgeThresholdY = Math.min(EDGE_HANDLE_TOLERANCE_PX, Math.max(frame.height * viewHeight / 2, 1));
      const cornerThresholdX = Math.min(CORNER_HANDLE_TOLERANCE_PX, Math.max(frame.width * viewWidth / 2, 1));
      const cornerThresholdY = Math.min(CORNER_HANDLE_TOLERANCE_PX, Math.max(frame.height * viewHeight / 2, 1));
      const verticalBand = Math.abs(rawLocalPoint.y) <= halfHeight + edgeThresholdY / viewHeight;
      const horizontalBand = Math.abs(rawLocalPoint.x) <= halfWidth + edgeThresholdX / viewWidth;
      const cornerVerticalBand = Math.abs(rawLocalPoint.y) <= halfHeight + cornerThresholdY / viewHeight;
      const cornerHorizontalBand = Math.abs(rawLocalPoint.x) <= halfWidth + cornerThresholdX / viewWidth;
      const distLeftPx = Math.abs(rawLocalPoint.x + halfWidth) * viewWidth;
      const distRightPx = Math.abs(rawLocalPoint.x - halfWidth) * viewWidth;
      const distTopPx = Math.abs(rawLocalPoint.y + halfHeight) * viewHeight;
      const distBottomPx = Math.abs(rawLocalPoint.y - halfHeight) * viewHeight;
      const nearLeft = distLeftPx <= edgeThresholdX && verticalBand;
      const nearRight = distRightPx <= edgeThresholdX && verticalBand;
      const nearTop = distTopPx <= edgeThresholdY && horizontalBand;
      const nearBottom = distBottomPx <= edgeThresholdY && horizontalBand;
      const nearLeftCorner = distLeftPx <= cornerThresholdX && cornerVerticalBand;
      const nearRightCorner = distRightPx <= cornerThresholdX && cornerVerticalBand;
      const nearTopCorner = distTopPx <= cornerThresholdY && cornerHorizontalBand;
      const nearBottomCorner = distBottomPx <= cornerThresholdY && cornerHorizontalBand;
      if (allowRotation) {
        const outsideLeft = rawLocalPoint.x < -halfWidth;
        const outsideRight = rawLocalPoint.x > halfWidth;
        const outsideTop = rawLocalPoint.y < -halfHeight;
        const outsideBottom = rawLocalPoint.y > halfHeight;
        if ((outsideLeft || outsideRight) && (outsideTop || outsideBottom)) {
          const rotationBandPx = ROTATION_HANDLE_BAND_PX;
          const outsideLeftPx = outsideLeft ? (-halfWidth - rawLocalPoint.x) * viewWidth : 0;
          const outsideRightPx = outsideRight ? (rawLocalPoint.x - halfWidth) * viewWidth : 0;
          const outsideTopPx = outsideTop ? (-halfHeight - rawLocalPoint.y) * viewHeight : 0;
          const outsideBottomPx = outsideBottom ? (rawLocalPoint.y - halfHeight) * viewHeight : 0;
          if (outsideLeft && outsideTop && outsideLeftPx <= rotationBandPx && outsideTopPx <= rotationBandPx) {
            return "rotate-nw";
          }
          if (outsideRight && outsideTop && outsideRightPx <= rotationBandPx && outsideTopPx <= rotationBandPx) {
            return "rotate-ne";
          }
          if (outsideRight && outsideBottom && outsideRightPx <= rotationBandPx && outsideBottomPx <= rotationBandPx) {
            return "rotate-se";
          }
          if (outsideLeft && outsideBottom && outsideLeftPx <= rotationBandPx && outsideBottomPx <= rotationBandPx) {
            return "rotate-sw";
          }
        }
      }
      if ((nearLeftCorner || nearRightCorner) && (nearTopCorner || nearBottomCorner)) {
        if (nearLeftCorner && nearTopCorner) return "transform-nw";
        if (nearRightCorner && nearTopCorner) return "transform-ne";
        if (nearRightCorner && nearBottomCorner) return "transform-se";
        if (nearLeftCorner && nearBottomCorner) return "transform-sw";
      }
      if (nearTop && !(nearLeftCorner || nearRightCorner)) return "transform-n";
      if (nearRight && !(nearTopCorner || nearBottomCorner)) return "transform-e";
      if (nearBottom && !(nearLeftCorner || nearRightCorner)) return "transform-s";
      if (nearLeft && !(nearTopCorner || nearBottomCorner)) return "transform-w";
      const insideX = Math.abs(rawLocalPoint.x) <= halfWidth;
      const insideY = Math.abs(rawLocalPoint.y) <= halfHeight;
      if (insideX && insideY) {
        return "move";
      }
      return null;
    }
    function cursorForHandle(handle, { active = false } = {}) {
      if (!handle) return "";
      if (handle === "move") {
        return active ? "grabbing" : "move";
      }
      if (handle.startsWith("transform-")) {
        if (handle.endsWith("n") || handle.endsWith("s")) {
          return "ns-resize";
        }
        if (handle.endsWith("e") || handle.endsWith("w")) {
          return "ew-resize";
        }
        if (handle.endsWith("ne") || handle.endsWith("sw")) {
          return "nesw-resize";
        }
        if (handle.endsWith("nw") || handle.endsWith("se")) {
          return "nwse-resize";
        }
      }
      if (handle.startsWith("rotate-")) {
        return "crosshair";
      }
      return "";
    }
    function setSelectionCursor(handle, { active = false } = {}) {
      if (editorState.tool !== "select") {
        gestureSvg.style.cursor = "";
        editorState.cursorHandle = null;
        return;
      }
      editorState.cursorHandle = handle || null;
      const cursor = cursorForHandle(handle, { active });
      gestureSvg.style.cursor = cursor;
    }
    const cloneVertices = (vertices = []) => vertices.map((vertex) => ({ x: vertex.x, y: vertex.y }));
    const snapshotShapeState = (shape, frame = null) => {
      if (!shape) return null;
      const base = {
        type: shape.type,
        x: shape.x,
        y: shape.y,
        width: shape.width,
        height: shape.height,
        rotation: normalizeAngle(shape.rotation || 0)
      };
      const bounds = getShapeAabb(shape) || { minX: shape.x ?? 0, minY: shape.y ?? 0, maxX: (shape.x ?? 0) + (shape.width ?? 0), maxY: (shape.y ?? 0) + (shape.height ?? 0) };
      base.centerX = clampUnit(((bounds.minX ?? 0) + (bounds.maxX ?? 0)) / 2);
      base.centerY = clampUnit(((bounds.minY ?? 0) + (bounds.maxY ?? 0)) / 2);
      if (shape.type === "polyline") {
        const normalizedVertices = cloneVertices(normalizeVertices(shape.vertices));
        base.vertices = normalizedVertices;
        if (frame) {
          base.localVertices = normalizedVertices.map((vertex) => toSelectionLocal(vertex, frame));
        }
      }
      if (frame) {
        base.localCenter = toSelectionLocal({ x: base.centerX, y: base.centerY }, frame);
      }
      return base;
    };
    const beginSelectionTransform = (handle, event) => {
      event.preventDefault();
      const selectedIds = getSelectedIds();
      if (!selectedIds.length) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      const normalized = toNormalizedPoint(svgPoint);
      const rawNormalized = getUnclampedNormalizedPoint(event) || normalized;
      const initialBounds = editorState.selectionBounds || computeSelectionBounds(selectedIds);
      if (!initialBounds) return;
      const initialFrame = cloneSelectionFrame(editorState.selectionFrame) || {
        centerX: initialBounds.centerX,
        centerY: initialBounds.centerY,
        width: initialBounds.width,
        height: initialBounds.height,
        rotation: 0
      };
      const initialShapes = new Map();
      for (const id of selectedIds) {
        const shape = findShapeById(id);
        if (!shape) continue;
        initialShapes.set(id, snapshotShapeState(shape, initialFrame));
      }
      if (!initialShapes.size) return;
      const mode = handle === "move" ? "move" : (handle.startsWith("rotate") ? "rotate" : "scale");
      const center = { x: initialFrame.centerX, y: initialFrame.centerY };
      const pointerForAngle = rawNormalized || normalized;
      const initialAngle = mode === "rotate" ? Math.atan2(pointerForAngle.y - center.y, pointerForAngle.x - center.x) : 0;
      if (mode === "rotate" && !Number.isFinite(initialAngle)) {
        return;
      }
      editorState.transformSession = {
        handle,
        mode,
        pointerId: event.pointerId,
        origin: normalized,
        originRaw: rawNormalized,
        initialBounds: { ...initialBounds },
        initialFrame: cloneSelectionFrame(initialFrame),
        frame: cloneSelectionFrame(initialFrame),
        initialShapes,
        didMutate: false,
        center,
        initialAngle,
        initialSelectionRotation: initialFrame.rotation || 0
      };
      editorState.pointerId = event.pointerId;
      editorState.pointerOrigin = { svg: svgPoint, normalized };
      editorState.didMutate = false;
      setSelectionCursor(handle, { active: true });
      if (gestureSvg?.setPointerCapture) {
        gestureSvg.setPointerCapture(event.pointerId);
      }
    };
    const applySelectionMove = (normalized, session) => {
      let dx = normalized.x - session.origin.x;
      let dy = normalized.y - session.origin.y;
      if (!Number.isFinite(dx) || !Number.isFinite(dy)) return;
      const bounds = session.initialBounds;
      if (bounds) {
        const minDx = -bounds.minX;
        const maxDx = 1 - bounds.maxX;
        const minDy = -bounds.minY;
        const maxDy = 1 - bounds.maxY;
        dx = clampRange(dx, minDx, maxDx);
        dy = clampRange(dy, minDy, maxDy);
      }
      if (Math.abs(dx) < 1e-6 && Math.abs(dy) < 1e-6) {
        return false;
      }
      for (const [id, initial] of session.initialShapes.entries()) {
        const shape = findShapeById(id);
        if (!shape) continue;
        if (initial.type === "polyline") {
          const originalVertices = initial.vertices || [];
          shape.vertices = originalVertices.map((vertex) => ({
            x: clampUnit(vertex.x + dx),
            y: clampUnit(vertex.y + dy)
          }));
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
        } else {
          const width = initial.width ?? 0;
          const height = initial.height ?? 0;
          shape.x = clampRange(initial.x + dx, 0, 1 - width);
          shape.y = clampRange(initial.y + dy, 0, 1 - height);
          shape.width = clampRange(width, SHAPE_MIN_SIZE, 1);
          shape.height = clampRange(height, SHAPE_MIN_SIZE, 1);
        }
      }
      const newFrame = session.initialFrame ? cloneSelectionFrame(session.initialFrame) : null;
      if (newFrame) {
        newFrame.centerX = clampUnit(newFrame.centerX + dx);
        newFrame.centerY = clampUnit(newFrame.centerY + dy);
        session.frame = newFrame;
        editorState.selectionFrame = cloneSelectionFrame(newFrame);
      }
      refreshSelectionBounds({ preserveRotation: true, frameOverride: session.frame || null });
      return true;
    };
    const applySelectionScale = (normalized, session) => {
      const initialFrame = session.initialFrame;
      if (!initialFrame) return false;
      const localPoint = toSelectionLocal(normalized, initialFrame);
      if (!localPoint) return false;
      const handle = session.handle || "transform-se";
      const minSpan = Math.max(SHAPE_MIN_SIZE * 1.5, 0.01);
      const initialMinX = -initialFrame.width / 2;
      const initialMaxX = initialFrame.width / 2;
      const initialMinY = -initialFrame.height / 2;
      const initialMaxY = initialFrame.height / 2;
      let newMinX = initialMinX;
      let newMaxX = initialMaxX;
      let newMinY = initialMinY;
      let newMaxY = initialMaxY;
      if (handle.includes("w")) {
        const clampMax = initialMaxX - minSpan;
        newMinX = clampRange(localPoint.x, initialMinX - initialFrame.width, clampMax);
      }
      if (handle.includes("e")) {
        const clampMin = initialMinX + minSpan;
        newMaxX = clampRange(localPoint.x, clampMin, initialMaxX + initialFrame.width);
      }
      if (!handle.includes("w") && !handle.includes("e")) {
        newMinX = initialMinX;
        newMaxX = initialMaxX;
      }
      if (handle.includes("n")) {
        const clampMax = initialMaxY - minSpan;
        newMinY = clampRange(localPoint.y, initialMinY - initialFrame.height, clampMax);
      }
      if (handle.includes("s")) {
        const clampMin = initialMinY + minSpan;
        newMaxY = clampRange(localPoint.y, clampMin, initialMaxY + initialFrame.height);
      }
      if (!handle.includes("n") && !handle.includes("s")) {
        newMinY = initialMinY;
        newMaxY = initialMaxY;
      }
      let newWidth = Math.max(newMaxX - newMinX, minSpan);
      let newHeight = Math.max(newMaxY - newMinY, minSpan);
      if (newWidth < minSpan) {
        const adjust = (minSpan - newWidth) / 2;
        newMinX -= adjust;
        newMaxX += adjust;
        newWidth = minSpan;
      }
      if (newHeight < minSpan) {
        const adjust = (minSpan - newHeight) / 2;
        newMinY -= adjust;
        newMaxY += adjust;
        newHeight = minSpan;
      }
      const widthDelta = Math.abs(newWidth - initialFrame.width);
      const heightDelta = Math.abs(newHeight - initialFrame.height);
      const newCenterLocalX = (newMinX + newMaxX) / 2;
      const newCenterLocalY = (newMinY + newMaxY) / 2;
      if (widthDelta < 1e-6 && heightDelta < 1e-6 && Math.abs(newCenterLocalX) < 1e-6 && Math.abs(newCenterLocalY) < 1e-6) {
        return false;
      }
      const scaleX = initialFrame.width > 0 ? newWidth / initialFrame.width : 1;
      const scaleY = initialFrame.height > 0 ? newHeight / initialFrame.height : 1;
      const newCenterGlobal = fromSelectionLocal({ x: newCenterLocalX, y: newCenterLocalY }, initialFrame);
      const newFrame = {
        centerX: clampUnit(newCenterGlobal.x),
        centerY: clampUnit(newCenterGlobal.y),
        width: Math.max(newWidth, MIN_METRIC_SPAN),
        height: Math.max(newHeight, MIN_METRIC_SPAN),
        rotation: normalizeAngle(initialFrame.rotation || 0)
      };
      for (const [id, initialShape] of session.initialShapes.entries()) {
        const shape = findShapeById(id);
        if (!shape) continue;
        const localCenter = initialShape.localCenter ?? toSelectionLocal({ x: initialShape.centerX, y: initialShape.centerY }, initialFrame) ?? { x: 0, y: 0 };
        const scaledLocalCenter = {
          x: localCenter.x * scaleX,
          y: localCenter.y * scaleY
        };
        const nextCenter = fromSelectionLocal(scaledLocalCenter, newFrame);
        if (initialShape.type === "polyline") {
          const sourceVertices = initialShape.localVertices && initialShape.localVertices.length
            ? initialShape.localVertices
            : (initialShape.vertices || []).map((vertex) => toSelectionLocal(vertex, initialFrame));
          const updatedVertices = sourceVertices.map((vertexLocal) => {
            const scaledLocal = {
              x: vertexLocal.x * scaleX,
              y: vertexLocal.y * scaleY
            };
            const globalPoint = fromSelectionLocal(scaledLocal, newFrame);
            return {
              x: clampUnit(globalPoint.x),
              y: clampUnit(globalPoint.y)
            };
          });
          shape.vertices = updatedVertices;
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
        } else {
          const baseWidth = initialShape.width ?? shape.width ?? 0;
          const baseHeight = initialShape.height ?? shape.height ?? 0;
          const nextWidth = clampRange(baseWidth * scaleX, SHAPE_MIN_SIZE, 1);
          const nextHeight = clampRange(baseHeight * scaleY, SHAPE_MIN_SIZE, 1);
          const nextX = clampRange(nextCenter.x - nextWidth / 2, 0, Math.max(1 - nextWidth, 0));
          const nextY = clampRange(nextCenter.y - nextHeight / 2, 0, Math.max(1 - nextHeight, 0));
          shape.x = clampUnit(nextX);
          shape.y = clampUnit(nextY);
          shape.width = nextWidth;
          shape.height = nextHeight;
          shape.rotation = initialShape.rotation;
        }
      }
      session.frame = cloneSelectionFrame(newFrame);
      editorState.selectionFrame = cloneSelectionFrame(newFrame);
      refreshSelectionBounds({ preserveRotation: true, frameOverride: session.frame });
      return true;
    };
    const applySelectionRotate = (normalized, rawNormalized, session, event) => {
      const initialFrame = session.initialFrame;
      if (!initialFrame) return false;
      const bounds = session.initialBounds;
      if (!bounds) return false;
      const centerX = session.center?.x ?? initialFrame.centerX ?? bounds.centerX;
      const centerY = session.center?.y ?? initialFrame.centerY ?? bounds.centerY;
      const pivot = rawNormalized || normalized;
      const angleNow = Math.atan2(pivot.y - centerY, pivot.x - centerX);
      if (!Number.isFinite(angleNow)) return false;
      let delta = angleNow - (session.initialAngle || 0);
      if (event?.shiftKey) {
        delta = Math.round(delta / SNAP_ROTATION_INCREMENT) * SNAP_ROTATION_INCREMENT;
      }
      delta = normalizeAngle(delta);
      if (Math.abs(delta) < 1e-6) {
        return false;
      }
      const cos = Math.cos(delta);
      const sin = Math.sin(delta);
      for (const [id, initialShape] of session.initialShapes.entries()) {
        const shape = findShapeById(id);
        if (!shape) continue;
        if (initialShape.type === "polyline") {
          const original = initialShape.vertices || [];
          shape.vertices = original.map((vertex) => rotatePointAround(vertex.x, vertex.y, centerX, centerY, delta)).map((vertex) => ({
            x: clampUnit(vertex.x),
            y: clampUnit(vertex.y)
          }));
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
          shape.rotation = 0;
        } else {
          const width = initialShape.width ?? shape.width ?? 0;
          const height = initialShape.height ?? shape.height ?? 0;
          const initialCenterX = initialShape.centerX ?? ((initialShape.x ?? 0) + width / 2);
          const initialCenterY = initialShape.centerY ?? ((initialShape.y ?? 0) + height / 2);
          const offsetX = initialCenterX - centerX;
          const offsetY = initialCenterY - centerY;
          const rotatedOffsetX = offsetX * cos - offsetY * sin;
          const rotatedOffsetY = offsetX * sin + offsetY * cos;
          const nextCenterX = centerX + rotatedOffsetX;
          const nextCenterY = centerY + rotatedOffsetY;
          const proposedX = nextCenterX - width / 2;
          const proposedY = nextCenterY - height / 2;
          const maxX = Math.max(1 - width, 0);
          const maxY = Math.max(1 - height, 0);
          shape.x = clampRange(proposedX, 0, maxX);
          shape.y = clampRange(proposedY, 0, maxY);
          shape.width = clampRange(width, SHAPE_MIN_SIZE, 1);
          shape.height = clampRange(height, SHAPE_MIN_SIZE, 1);
          shape.rotation = normalizeAngle((initialShape.rotation || 0) + delta);
        }
      }
      const newFrame = {
        centerX: clampUnit(centerX),
        centerY: clampUnit(centerY),
        width: initialFrame.width,
        height: initialFrame.height,
        rotation: normalizeAngle((session.initialSelectionRotation || 0) + delta)
      };
      session.frame = cloneSelectionFrame(newFrame);
      editorState.selectionFrame = cloneSelectionFrame(newFrame);
      session.center = { x: centerX, y: centerY };
      refreshSelectionBounds({ preserveRotation: true, frameOverride: session.frame });
      return true;
    };
    const updateSelectionTransform = (event) => {
      const session = editorState.transformSession;
      if (!session || event.pointerId !== session.pointerId) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      const normalized = toNormalizedPoint(svgPoint);
      const rawNormalized = getUnclampedNormalizedPoint(event) || normalized;
      setSelectionCursor(session.handle, { active: true });
      const mutated = session.mode === "move"
        ? applySelectionMove(normalized, session)
        : session.mode === "scale"
          ? applySelectionScale(normalized, session)
          : applySelectionRotate(normalized, rawNormalized, session, event);
      if (mutated) {
        session.didMutate = true;
        editorState.didMutate = true;
        markEditorSidebarDirty();
        renderEditor();
      }
    };
    const endSelectionTransform = (event) => {
      const session = editorState.transformSession;
      if (!session || (event && session.pointerId !== event.pointerId)) {
        return false;
      }
      if (gestureSvg?.hasPointerCapture?.(session.pointerId)) {
        gestureSvg.releasePointerCapture(session.pointerId);
      }
      editorState.transformSession = null;
      editorState.pointerId = null;
      editorState.pointerOrigin = null;
      if (session.didMutate) {
        refreshSelectionBounds({ preserveRotation: true, frameOverride: session.frame || null });
        queuePersist();
      }
      editorState.didMutate = false;
      let hoverHandle = null;
      if (event) {
        const svgPoint = toSvgPoint(event);
        if (svgPoint) {
          const normalizedPoint = toNormalizedPoint(svgPoint);
          const rawPoint = getUnclampedNormalizedPoint(event);
          hoverHandle = resolveSelectionHandle(normalizedPoint, { allowRotation: true, rawPoint });
        }
      }
      setSelectionCursor(hoverHandle);
      renderEditor();
      return true;
    };

    const setEditorTool = (tool) => {
      if (!tool || editorState.tool === tool) {
        updateToolButtons();
        updateToolLockIndicator();
        return;
      }
      const previousTool = editorState.tool;
      if (isPolylineTool(previousTool) && previousTool !== tool) {
        finalizeActivePolyline({ commit: true });
      }
      if (previousTool === "hand" && editorState.panPointerId !== null) {
        editorState.panPointerId = null;
        editorState.panOrigin = null;
        gestureSvgWrapper?.classList.remove("is-panning");
      }
      editorState.tool = tool;
      editorState.hoverShapeId = null;
      if (tool !== "eraser") {
        editorState.eraserActive = false;
        editorState.erasedShapeIds.clear();
        editorState.eraserPointerId = null;
      }
      if (tool === "eraser" || tool === "hand") {
        clearActivePolylineState();
        setSelectedShape(null, { suppressRender: true });
      }
      if (isPolylineTool(tool)) {
        editorState.polylineHoverPoint = null;
      } else {
        editorState.activePolylineId = null;
      }
      applyEditorPan();
      gestureEditorEl?.classList.toggle("is-hand-tool", tool === "hand");
      gestureSvgWrapper?.classList.toggle("is-hand-tool", tool === "hand");
      gestureToolbar?.classList.toggle("is-hand-tool", tool === "hand");
      updateToolButtons();
      updateToolLockIndicator();
      if (tool !== "select") {
        setSelectionCursor(null);
      }
      renderEditor();
    };

    const setEditorMode = (mode) => {
      editorState.mode = mode;
      if (mode === "perform") {
        finalizeActivePolyline({ commit: true });
      }
      if (gestureEditorEl) {
        gestureEditorEl.classList.toggle("is-performing", mode === "perform");
      }
      if (gestureSvg) {
        gestureSvg.style.pointerEvents = mode === "perform" ? "none" : "auto";
      }
      gestureModeToggle?.classList.toggle("is-active", mode === "perform");
      updateModeToggleLabel();
      updateToolButtons();
    };

    const beginDrawing = (tool, event) => {
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      const normalized = toNormalizedPoint(svgPoint);
      const shapeType = isPolylineTool(tool) ? "polyline" : tool;
      const shape = {
        id: ensureUuid(),
        type: shapeType,
        x: normalized.x,
        y: normalized.y,
        width: 0,
        height: 0,
        rotation: 0,
        style: { ...DEFAULT_SHAPE_STYLE },
        interaction: createDefaultInteraction(),
        runtime: { inside: false, hoverInside: false, lastTriggerAt: 0, lastContinuousAt: 0, noteOn: false, eventState: {}, lastMetrics: { normX: 0, normY: 0, distance: 0 } }
      };
      editorState.shapes.push(shape);
      setSelectedShape(shape.id, { suppressRender: true });
      editorState.drawingShapeId = shape.id;
      editorState.pointerId = event.pointerId;
      editorState.pointerOrigin = { svg: svgPoint, normalized };
      editorState.didMutate = true;
      if (gestureSvg?.setPointerCapture) {
        gestureSvg.setPointerCapture(event.pointerId);
      }
      renderEditor();
    };

    const handlePolylinePointerDown = (event) => {
      if (event.button && event.button !== 0) return;
      const shiftPressed = Boolean(event.shiftKey);
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      event.preventDefault();
      const normalized = toNormalizedPoint(svgPoint);
      let shape = editorState.activePolylineId ? findShapeById(editorState.activePolylineId) : null;
      if (shape && editorState.tool === "line") {
        const vertices = Array.isArray(shape.vertices) ? shape.vertices : (shape.vertices = []);
        if (vertices.length >= 2 && !shiftPressed) {
          finalizeActivePolyline({ commit: true });
          shape = null;
        }
      }
      if (!shape) {
        if (!isPolylineTool(editorState.tool)) {
          return;
        }
        startPolylineAt(normalized);
        shape = findShapeById(editorState.activePolylineId);
      }
      if (!shape) return;
      if (editorState.tool === "line") {
        const vertices = Array.isArray(shape.vertices) ? shape.vertices : (shape.vertices = []);
        const anchor = vertices.length ? vertices[vertices.length - 1] : normalized;
        if (!vertices.length) {
          vertices.push({ ...anchor });
        }
        vertices.push({ ...anchor });
        editorState.polylineHoverPoint = null;
        editorState.polylineExtendArmed = shiftPressed && vertices.length >= 2;
      } else if (editorState.tool === "freehand") {
        const vertices = Array.isArray(shape.vertices) ? shape.vertices : (shape.vertices = []);
        const lastVertex = vertices[vertices.length - 1];
        if (!lastVertex || distanceBetween(lastVertex, normalized) >= MIN_POLYLINE_SEGMENT * 0.25) {
          vertices.push({ ...normalized });
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
        }
        editorState.polylineExtendArmed = false;
      }
      editorState.polylinePointerId = event.pointerId;
      if (gestureSvg?.setPointerCapture) {
        gestureSvg.setPointerCapture(event.pointerId);
      }
      renderEditor();
    };

    const handlePolylinePointerMove = (event) => {
      if (!editorState.activePolylineId) return;
      const shape = findShapeById(editorState.activePolylineId);
      if (!shape) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      const normalized = toNormalizedPoint(svgPoint);
      if (editorState.tool === "freehand") {
        if (event.pointerId !== editorState.polylinePointerId) return;
        const vertices = Array.isArray(shape.vertices) ? shape.vertices : (shape.vertices = []);
        const lastVertex = vertices[vertices.length - 1];
        if (!lastVertex || distanceBetween(lastVertex, normalized) >= MIN_POLYLINE_SEGMENT * 0.5) {
          vertices.push({ ...normalized });
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
          editorState.didMutate = true;
          renderEditor();
        }
        return;
      }
      if (editorState.tool === "line") {
        if (event.pointerId === editorState.polylinePointerId) {
          const vertices = Array.isArray(shape.vertices) ? shape.vertices : (shape.vertices = []);
          if (vertices.length) {
            vertices[vertices.length - 1] = { ...normalized };
            updatePolylineBounds(shape);
            ensurePolylineStyle(shape);
            editorState.didMutate = true;
            renderEditor();
          }
        } else {
          const allowPreview = event.shiftKey && Array.isArray(shape.vertices) && shape.vertices.length > 0;
          const prevHover = editorState.polylineHoverPoint;
          if (allowPreview) {
            editorState.polylineHoverPoint = { ...normalized };
            editorState.polylineExtendArmed = true;
            if (!prevHover || Math.hypot((prevHover.x ?? 0) - normalized.x, (prevHover.y ?? 0) - normalized.y) > VERTEX_EPSILON) {
              renderEditor();
            }
          } else if (prevHover) {
            editorState.polylineHoverPoint = null;
            editorState.polylineExtendArmed = false;
            renderEditor();
          } else if (editorState.polylineExtendArmed) {
            editorState.polylineExtendArmed = false;
          }
        }
        return;
      }
    };

    const handlePolylinePointerUp = (event) => {
      if (!editorState.activePolylineId) return false;
      if (editorState.polylinePointerId !== null && editorState.polylinePointerId !== event.pointerId) {
        return false;
      }
      const shape = findShapeById(editorState.activePolylineId);
      if (!shape) {
        clearActivePolylineState();
        return true;
      }
      if (gestureSvg?.hasPointerCapture?.(event.pointerId)) {
        gestureSvg.releasePointerCapture(event.pointerId);
      }
      const svgPoint = toSvgPoint(event);
      const normalized = svgPoint ? toNormalizedPoint(svgPoint) : null;
      if (editorState.tool === "freehand") {
        if (normalized) {
          addPolylinePoint(shape, normalized);
        }
        if (Array.isArray(shape.vertices) && shape.vertices.length > 2) {
          shape.vertices = simplifyPolyline(shape.vertices, FREEHAND_SIMPLIFY_TOLERANCE);
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
          editorState.didMutate = true;
        }
        editorState.polylinePointerId = null;
        editorState.polylineHoverPoint = null;
        finalizeActivePolyline({ commit: true });
        return true;
      }
      if (editorState.tool === "line") {
        const vertices = Array.isArray(shape.vertices) ? shape.vertices : (shape.vertices = []);
        if (normalized && vertices.length) {
          vertices[vertices.length - 1] = { ...normalized };
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
        }
        editorState.polylinePointerId = null;
        editorState.polylineHoverPoint = null;
        const extend = Boolean(event.shiftKey);
        editorState.polylineExtendArmed = extend;
        if (extend) {
          renderEditor();
          return true;
        }
        finalizeActivePolyline({ commit: true });
        return true;
      }
      return false;
    };

    const eraseAtEvent = (event) => {
      const localTarget = event.target?.closest?.("[data-shape-id]");
      const fallbackTarget = document.elementFromPoint?.(event.clientX ?? 0, event.clientY ?? 0)?.closest?.("[data-shape-id]");
      const shapeTarget = localTarget || fallbackTarget;
      const shapeId = shapeTarget?.getAttribute?.("data-shape-id");
      if (!shapeId || editorState.erasedShapeIds.has(shapeId)) {
        return;
      }
      editorState.erasedShapeIds.add(shapeId);
      removeShapeById(shapeId);
      renderEditor();
      queuePersist();
    };

    const beginErasing = (event) => {
      editorState.eraserActive = true;
      editorState.eraserPointerId = event.pointerId;
      editorState.erasedShapeIds = new Set();
      eraseAtEvent(event);
      gestureSvg?.setPointerCapture?.(event.pointerId);
    };

    const handleEraserMove = (event) => {
      if (!editorState.eraserActive) return;
      eraseAtEvent(event);
    };

    const beginShapeDrag = (shapeId, handle, event) => {
      const shape = findShapeById(shapeId);
      if (!shape) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      setSelectedShape(shapeId, { suppressRender: true });
      editorState.dragHandle = handle || "move";
      editorState.pointerId = event.pointerId;
      editorState.pointerOrigin = { svg: svgPoint, normalized: toNormalizedPoint(svgPoint) };
      editorState.initialRect = {
        x: shape.x,
        y: shape.y,
        width: shape.width,
        height: shape.height
      };
      editorState.initialVertices = shape.type === "polyline"
        ? normalizeVertices(shape.vertices).map((vertex) => ({ ...vertex }))
        : null;
      if (gestureSvg?.setPointerCapture) {
        gestureSvg.setPointerCapture(event.pointerId);
      }
      renderEditor();
    };

    const applyDragToShape = (shape, normalized) => {
      if (!shape || !editorState.pointerOrigin || !editorState.initialRect) return;
      const dx = normalized.x - editorState.pointerOrigin.normalized.x;
      const dy = normalized.y - editorState.pointerOrigin.normalized.y;
      const handle = editorState.dragHandle || "move";
      const initial = editorState.initialRect;
      const initialRight = initial.x + initial.width;
      const initialBottom = initial.y + initial.height;
      let left = initial.x;
      let top = initial.y;
      let right = initialRight;
      let bottom = initialBottom;
      if (shape.type === "polyline") {
        const initialVertices = editorState.initialVertices || normalizeVertices(shape.vertices);
        if (!initialVertices.length) return;
        if (handle === "move") {
          const newLeft = clampRange(initial.x + dx, 0, 1 - initial.width);
          const newTop = clampRange(initial.y + dy, 0, 1 - initial.height);
          const moveX = newLeft - initial.x;
          const moveY = newTop - initial.y;
          shape.vertices = initialVertices.map((vertex) => ({
            x: clampUnit(vertex.x + moveX),
            y: clampUnit(vertex.y + moveY)
          }));
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
          editorState.didMutate = true;
          refreshSelectionBounds();
          return;
        }
        if (handle?.startsWith("vertex-")) {
          const index = Number.parseInt(handle.slice(7), 10);
          if (!Number.isInteger(index) || index < 0 || index >= initialVertices.length) {
            return;
          }
          const nextVertices = initialVertices.map((vertex, idx) => {
            if (idx !== index) {
              return { ...vertex };
            }
            return {
              x: clampUnit(normalized.x),
              y: clampUnit(normalized.y)
            };
          });
          if (shape.closed && nextVertices.length >= 2) {
            if (index === 0) {
              nextVertices[nextVertices.length - 1] = { ...nextVertices[0] };
            } else if (index === nextVertices.length - 1) {
              nextVertices[0] = { ...nextVertices[nextVertices.length - 1] };
            }
          }
          shape.vertices = nextVertices;
          updatePolylineBounds(shape);
          ensurePolylineStyle(shape);
          editorState.didMutate = true;
          refreshSelectionBounds();
          return;
        }
        if (handle.includes("w")) {
          left = clampRange(initial.x + dx, 0, initialRight - SHAPE_MIN_SIZE);
        }
        if (handle.includes("e")) {
          right = clampRange(initialRight + dx, left + SHAPE_MIN_SIZE, 1);
        }
        if (handle.includes("n")) {
          top = clampRange(initial.y + dy, 0, initialBottom - SHAPE_MIN_SIZE);
        }
        if (handle.includes("s")) {
          bottom = clampRange(initialBottom + dy, top + SHAPE_MIN_SIZE, 1);
        }
        const width = clampRange(right - left, SHAPE_MIN_SIZE, 1);
        const height = clampRange(bottom - top, SHAPE_MIN_SIZE, 1);
        const initialWidth = initial.width || 1;
        const initialHeight = initial.height || 1;
        shape.vertices = initialVertices.map((vertex) => {
          const relX = initial.width ? (vertex.x - initial.x) / initialWidth : 0;
          const relY = initial.height ? (vertex.y - initial.y) / initialHeight : 0;
          return {
            x: clampUnit(left + relX * width),
            y: clampUnit(top + relY * height)
          };
        });
        updatePolylineBounds(shape);
        ensurePolylineStyle(shape);
        editorState.didMutate = true;
        refreshSelectionBounds();
        return;
      }
      if (handle === "move") {
        const newX = clampRange(initial.x + dx, 0, 1 - initial.width);
        const newY = clampRange(initial.y + dy, 0, 1 - initial.height);
        shape.x = Number.isFinite(newX) ? newX : initial.x;
        shape.y = Number.isFinite(newY) ? newY : initial.y;
        editorState.didMutate = true;
        refreshSelectionBounds();
        return;
      }
      if (handle.includes("w")) {
        left = clampRange(initial.x + dx, 0, initialRight - SHAPE_MIN_SIZE);
      }
      if (handle.includes("e")) {
        right = clampRange(initialRight + dx, left + SHAPE_MIN_SIZE, 1);
      }
      if (handle.includes("n")) {
        top = clampRange(initial.y + dy, 0, initialBottom - SHAPE_MIN_SIZE);
      }
      if (handle.includes("s")) {
        bottom = clampRange(initialBottom + dy, top + SHAPE_MIN_SIZE, 1);
      }
      const width = clampRange(right - left, SHAPE_MIN_SIZE, 1);
      const height = clampRange(bottom - top, SHAPE_MIN_SIZE, 1);
      shape.x = clampUnit(left);
      shape.y = clampUnit(top);
      shape.width = clampRange(width, SHAPE_MIN_SIZE, 1);
      shape.height = clampRange(height, SHAPE_MIN_SIZE, 1);
      editorState.didMutate = true;
      refreshSelectionBounds();
    };

    const updateDrawingShape = (shape, normalized) => {
      if (!shape || !editorState.pointerOrigin) return;
      const origin = editorState.pointerOrigin.normalized;
      const x1 = clampUnit(origin.x);
      const y1 = clampUnit(origin.y);
      const x2 = clampUnit(normalized.x);
      const y2 = clampUnit(normalized.y);
      const left = Math.min(x1, x2);
      const top = Math.min(y1, y2);
      const width = Math.abs(x2 - x1);
      const height = Math.abs(y2 - y1);
      shape.x = clampUnit(left);
      shape.y = clampUnit(top);
      shape.width = clampRange(width, 0, 1);
      shape.height = clampRange(height, 0, 1);
      editorState.didMutate = true;
    };

    const finishPointerInteraction = (event) => {
      const wasDrawing = Boolean(editorState.drawingShapeId);
      if (event.pointerId !== editorState.pointerId) {
        return;
      }
      if (gestureSvg?.hasPointerCapture?.(event.pointerId)) {
        gestureSvg.releasePointerCapture(event.pointerId);
      }
      if (editorState.drawingShapeId) {
        const shape = findShapeById(editorState.drawingShapeId);
        if (shape) {
          if (shape.width < SHAPE_MIN_SIZE && shape.height < SHAPE_MIN_SIZE) {
            editorState.shapes = editorState.shapes.filter((item) => item.id !== shape.id);
            if (editorState.selectedId === shape.id) {
              setSelectedShape(null, { suppressRender: true });
            } else {
              markEditorSidebarDirty();
            }
          }
        }
      }
      const wasMutated = editorState.didMutate;
      editorState.drawingShapeId = null;
      editorState.dragHandle = null;
      editorState.pointerId = null;
      editorState.pointerOrigin = null;
      editorState.initialRect = null;
      editorState.initialVertices = null;
      editorState.didMutate = false;
      if (wasMutated) {
        queuePersist();
      }
      renderEditor();
      if (wasDrawing) {
        maybeAutoRevertTool();
      }
    };

    const handleEditorPointerDown = (event) => {
      if (editorState.mode === "perform") return;
      if (!gestureSvg) return;
      const handle = event.target?.dataset?.handle;
      const shapeTarget = event.target?.closest?.("[data-shape-id]");
      const shouldFocusSvg = (() => {
        if (!gestureSvg || typeof gestureSvg.focus !== "function") return false;
        if (handle) return true;
        if (shapeTarget) return true;
        return editorState.tool !== "select";
      })();
      if (shouldFocusSvg && typeof gestureSvg.focus === "function") {
        try {
          gestureSvg.focus({ preventScroll: true });
        } catch (err) {
          gestureSvg.focus();
        }
      }
      if (editorState.tool === "hand") {
        beginPan(event);
        return;
      }
      if (editorState.tool === "eraser") {
        beginErasing(event);
        return;
      }
      if (isPolylineTool(editorState.tool)) {
        handlePolylinePointerDown(event);
        return;
      }
      let svgPointForSelection = null;
      let normalizedPointForSelection = null;
      let rawNormalizedPointForSelection = null;
      if (editorState.tool === "select" || handle || shapeTarget) {
        svgPointForSelection = toSvgPoint(event);
        if (svgPointForSelection) {
          normalizedPointForSelection = toNormalizedPoint(svgPointForSelection);
        }
        rawNormalizedPointForSelection = getUnclampedNormalizedPoint(event);
      }
      if (handle) {
        if (handle.startsWith("vertex-")) {
          const controlGroup = event.target.closest("[data-selected-controls]");
          const shapeId = controlGroup?.getAttribute("data-selected-controls");
          if (shapeId) {
            beginShapeDrag(shapeId, handle, event);
          }
          return;
        }
        if (handle.startsWith("transform-")) {
          beginSelectionTransform(handle, event);
          return;
        }
        return;
      }
      let selectionHandle = normalizedPointForSelection
        ? resolveSelectionHandle(normalizedPointForSelection, { allowRotation: true, rawPoint: rawNormalizedPointForSelection })
        : null;
      const shapeId = shapeTarget?.getAttribute?.("data-shape-id");
      if (shapeId) {
        const selectedIds = getSelectedIds();
        const isSelected = editorState.selectedIds?.has?.(shapeId) || editorState.selectedId === shapeId;
        if (event.altKey) {
          if (event.shiftKey) {
            if (isSelected) {
              const remaining = selectedIds.filter((id) => id !== shapeId);
              setSelectedShapes(remaining);
            }
          } else {
            if (!isSelected) {
              setSelectedShape(shapeId);
            }
            openAssignmentModal(shapeId);
          }
          event.preventDefault();
          return;
        }
        if (event.shiftKey) {
          if (!isSelected) {
            setSelectedShapes([shapeId], { append: true });
          }
          event.preventDefault();
          return;
        }
        if (!isSelected) {
          setSelectedShape(shapeId);
          if (normalizedPointForSelection) {
            selectionHandle = resolveSelectionHandle(normalizedPointForSelection, { allowRotation: true, rawPoint: rawNormalizedPointForSelection });
          }
        }
        if (selectionHandle && selectionHandle !== "move" && selectionHandle !== null) {
          event.preventDefault();
          beginSelectionTransform(selectionHandle, event);
          return;
        }
        event.preventDefault();
        beginSelectionTransform("move", event);
        return;
      }
      if (editorState.tool === "select") {
        if (!svgPointForSelection) {
          setSelectedShape(null);
          return;
        }
        if (selectionHandle) {
          beginSelectionTransform(selectionHandle, event);
          return;
        }
        const marqueeMode = event.shiftKey ? "add" : event.altKey ? "subtract" : "replace";
        const initialSelection = getSelectedIds();
        editorState.selectionMarquee = {
          anchor: normalizedPointForSelection,
          current: { ...normalizedPointForSelection },
          mode: marqueeMode,
          initialSelection
        };
        editorState.pointerId = event.pointerId;
        editorState.pointerOrigin = { svg: svgPointForSelection, normalized: normalizedPointForSelection };
        if (marqueeMode === "replace") {
          setSelectedShapes([], { suppressRender: true });
        }
        if (gestureSvg?.setPointerCapture) {
          gestureSvg.setPointerCapture(event.pointerId);
        }
        renderEditor();
        return;
      }
      beginDrawing(editorState.tool, event);
    };

    const handleEditorPointerMove = (event) => {
      const session = editorState.transformSession;
      if (session && event.pointerId === session.pointerId) {
        updateSelectionTransform(event);
        return;
      }
      const marquee = editorState.selectionMarquee;
      if (marquee && editorState.pointerId === event.pointerId) {
        const svgPoint = toSvgPoint(event);
        if (!svgPoint) return;
        const normalized = toNormalizedPoint(svgPoint);
        marquee.current = { ...normalized };
        renderEditor();
        return;
      }
      if (editorState.tool === "hand") {
        updatePan(event);
        return;
      }
      if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
        handlePolylinePointerMove(event);
        return;
      }
      if (editorState.tool === "eraser" && editorState.eraserActive) {
        handleEraserMove(event);
        return;
      }
      if (editorState.tool === "select" && !editorState.dragHandle && !editorState.drawingShapeId && !editorState.activePolylineId) {
        const hoveredId = event.target?.closest?.("[data-shape-id]")?.getAttribute("data-shape-id") || null;
        if (editorState.hoverShapeId !== hoveredId) {
          editorState.hoverShapeId = hoveredId;
          renderEditor();
        }
        if (!editorState.transformSession && editorState.pointerId === null) {
          const hoverSvgPoint = toSvgPoint(event);
          if (hoverSvgPoint) {
            const hoverNormalized = toNormalizedPoint(hoverSvgPoint);
            const hoverRaw = getUnclampedNormalizedPoint(event);
            const hoverHandle = resolveSelectionHandle(hoverNormalized, { allowRotation: true, rawPoint: hoverRaw });
            setSelectionCursor(hoverHandle);
          } else {
            setSelectionCursor(null);
          }
        }
      }
      if (event.pointerId !== editorState.pointerId) return;
      const svgPoint = toSvgPoint(event);
      if (!svgPoint) return;
      const normalized = toNormalizedPoint(svgPoint);
      if (editorState.drawingShapeId) {
        const shape = findShapeById(editorState.drawingShapeId);
        if (shape) {
          updateDrawingShape(shape, normalized);
          renderEditor();
        }
        return;
      }
      if (editorState.dragHandle && editorState.selectedId) {
        const shape = findShapeById(editorState.selectedId);
        if (shape) {
          applyDragToShape(shape, normalized);
          renderEditor();
        }
      }
    };

    const handleEditorPointerUp = (event) => {
      if (editorState.transformSession && event.pointerId === editorState.transformSession.pointerId) {
        endSelectionTransform(event);
        return;
      }
      if (editorState.selectionMarquee && event.pointerId === editorState.pointerId) {
        const marquee = editorState.selectionMarquee;
        const anchor = marquee?.anchor;
        const current = marquee?.current;
        const marqueeMode = marquee?.mode || "replace";
        const initialSelection = Array.isArray(marquee?.initialSelection) ? marquee.initialSelection : [];
        editorState.selectionMarquee = null;
        if (gestureSvg?.hasPointerCapture?.(event.pointerId)) {
          gestureSvg.releasePointerCapture(event.pointerId);
        }
        const svgPoint = toSvgPoint(event);
        const normalized = svgPoint ? toNormalizedPoint(svgPoint) : null;
        const rawNormalized = getUnclampedNormalizedPoint(event);
        if (anchor && current) {
          const minX = clampUnit(anchor.x);
          const minY = clampUnit(anchor.y);
          const maxX = clampUnit(current.x);
          const maxY = clampUnit(current.y);
          const selected = getShapesInBounds(minX, minY, maxX, maxY);
          let nextSelection;
          if (marqueeMode === "add") {
            const union = new Set(initialSelection);
            selected.forEach((id) => union.add(id));
            nextSelection = Array.from(union);
          } else if (marqueeMode === "subtract") {
            const removal = new Set(selected);
            nextSelection = initialSelection.filter((id) => !removal.has(id));
          } else {
            nextSelection = selected;
          }
          setSelectedShapes(nextSelection, { suppressRender: true });
          const hoverHandle = normalized ? resolveSelectionHandle(normalized, { allowRotation: true, rawPoint: rawNormalized }) : null;
          setSelectionCursor(hoverHandle);
        }
        editorState.pointerId = null;
        editorState.pointerOrigin = null;
        renderEditor();
        return;
      }
      if (editorState.tool === "hand" && event.pointerId === editorState.panPointerId) {
        endPan(event);
        return;
      }
      if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
        if (handlePolylinePointerUp(event)) {
          return;
        }
      }
      if (editorState.eraserActive && event.pointerId === editorState.eraserPointerId) {
        editorState.eraserActive = false;
        editorState.eraserPointerId = null;
        editorState.erasedShapeIds.clear();
        gestureSvg?.releasePointerCapture?.(event.pointerId);
      }
      finishPointerInteraction(event);
    };

    const handleEditorPointerLeave = (event) => {
      if (editorState.transformSession && editorState.transformSession.pointerId === event.pointerId) {
        endSelectionTransform(event);
      }
      if (editorState.tool === "hand" && editorState.panPointerId === event.pointerId) {
        endPan(event);
      }
      finishPointerInteraction(event);
      if (!editorState.transformSession) {
        setSelectionCursor(null);
      }
      if (editorState.activePolylineId && editorState.polylineHoverPoint) {
        editorState.polylineHoverPoint = null;
        editorState.polylineExtendArmed = false;
        renderEditor();
      } else if (editorState.polylineExtendArmed) {
        editorState.polylineExtendArmed = false;
      }
      if (editorState.tool === "select" && editorState.hoverShapeId) {
        editorState.hoverShapeId = null;
        renderEditor();
      }
      if (editorState.eraserActive && event.pointerId === editorState.eraserPointerId) {
        editorState.eraserActive = false;
        editorState.eraserPointerId = null;
        editorState.erasedShapeIds.clear();
        gestureSvg?.releasePointerCapture?.(event.pointerId);
      }
      if (editorState.selectionMarquee && event.pointerId === editorState.pointerId) {
        editorState.selectionMarquee = null;
        editorState.pointerId = null;
        editorState.pointerOrigin = null;
        if (gestureSvg?.hasPointerCapture?.(event.pointerId)) {
          gestureSvg.releasePointerCapture(event.pointerId);
        }
        setSelectionCursor(null);
        renderEditor();
      }
    };
    const handleGlobalShortcut = (event) => {
      if (!(event.metaKey || event.ctrlKey)) return;
      if (event.altKey) return;
      if (event.repeat) return;
      const key = event.key?.toLowerCase();
      if (key === "e") {
        event.preventDefault();
        toggleEditorVisibility();
      }
    };
    const handleEditorKeyDown = (event) => {
      if (event.defaultPrevented) return;
      if (assignmentModal?.classList.contains("is-visible")) return;
      if (event.ctrlKey || event.metaKey || event.altKey) return;
      if (editorState.mode !== "edit") return;
      const activeTag = document.activeElement?.tagName?.toLowerCase() || "";
      if (["input", "textarea", "select"].includes(activeTag)) return;
      const key = event.key?.toLowerCase();
      switch (key) {
        case "v":
          setEditorTool("select");
          event.preventDefault();
          break;
        case "h":
          setEditorTool("hand");
          event.preventDefault();
          break;
        case "r":
          setEditorTool("rect");
          event.preventDefault();
          break;
        case "e":
          setEditorTool("eraser");
          event.preventDefault();
          break;
        case "o":
          setEditorTool("ellipse");
          event.preventDefault();
          break;
        case "l":
          setEditorTool("line");
          event.preventDefault();
          break;
        case "d":
          setEditorTool("freehand");
          event.preventDefault();
          break;
        case "q":
          editorState.toolLocked = !editorState.toolLocked;
          updateToolLockIndicator();
          event.preventDefault();
          break;
        case "backspace":
          if (editorState.activePolylineId) {
            cancelActivePolyline();
            event.preventDefault();
          }
          break;
        case "delete":
          if (editorState.activePolylineId) {
            cancelActivePolyline();
            event.preventDefault();
          } else {
            deleteSelectedShape();
            event.preventDefault();
          }
          break;
        case "enter":
          if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
            const activeShape = findShapeById(editorState.activePolylineId);
            if (event.shiftKey && activeShape) {
              activeShape.closed = true;
            }
            finalizeActivePolyline({ commit: true });
            event.preventDefault();
          } else if (editorState.selectedId) {
            openAssignmentModal(editorState.selectedId);
            event.preventDefault();
          }
          break;
        case "escape":
          if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
            cancelActivePolyline();
            event.preventDefault();
          } else if (editorState.selectedId) {
            setSelectedShape(null);
            event.preventDefault();
          }
          break;
        default:
          break;
      }
    };

    const openAssignmentModal = (shapeId) => {
      if (!assignmentModal || !assignmentBackdrop) return;
      const shape = findShapeById(shapeId);
      if (!shape) return;
      refreshMidiPortOptions();
      activeAssignmentShapeId = shapeId;
      assignmentDraftInteraction = JSON.parse(JSON.stringify(mergeInteraction(shape.interaction)));
      syncAssignmentForm();
      assignmentBackdrop.classList.add("is-visible");
      assignmentModal.classList.add("is-visible");
      assignmentBackdrop.setAttribute("aria-hidden", "false");
      assignmentModal.setAttribute("aria-hidden", "false");
      setTimeout(() => {
        assignmentStreamSelect?.focus();
      }, 20);
    };

    const closeAssignmentModal = () => {
      if (!assignmentModal || !assignmentBackdrop) return;
      assignmentBackdrop.classList.remove("is-visible");
      assignmentModal.classList.remove("is-visible");
      assignmentBackdrop.setAttribute("aria-hidden", "true");
      assignmentModal.setAttribute("aria-hidden", "true");
      activeAssignmentShapeId = null;
      assignmentDraftInteraction = null;
    };

    const applyAssignmentModal = () => {
      if (!activeAssignmentShapeId || !assignmentDraftInteraction) {
        closeAssignmentModal();
        return;
      }
      const stream = assignmentStreamSelect?.value || assignmentDraftInteraction.stream || "pose";
      const landmark = assignmentLandmarkSelect?.value || assignmentDraftInteraction.landmark || getStreamDefinition(stream)?.options?.[0]?.key || "";
      assignmentDraftInteraction = mergeInteraction({
        ...assignmentDraftInteraction,
        stream,
        landmark
      });
      const targetId = activeAssignmentShapeId;
      if (editorState.selectedId !== targetId) {
        setSelectedShape(targetId, { suppressRender: true });
      }
      mutateSelectedShape((target) => {
        if (target.id === targetId) {
          target.interaction = assignmentDraftInteraction;
        }
      }, { skipRender: true });
      updateEditorConfig({
        midiPort: assignmentMidiPortSelect?.value || editorConfig.midiPort
      });
      syncEditorDetailForm();
      closeAssignmentModal();
    };
    const midiManager = {
      supported: typeof navigator !== "undefined" && typeof navigator.requestMIDIAccess === "function",
      ready: false,
      pending: null,
      access: null,
      outputs: []
    };
    const getMidiOutputs = () => Array.isArray(midiManager.outputs) ? midiManager.outputs : [];
    const midiOptionLabel = (output, index) => {
      const baseName = output?.name && output.name.trim() ? output.name.trim() : `Port ${index + 1}`;
      const manufacturer = output?.manufacturer && output.manufacturer.trim() ? output.manufacturer.trim() : "";
      return manufacturer ? `${baseName} (${manufacturer})` : baseName;
    };
    const populateMidiPortSelect = (selectEl, selectedId = editorConfig.midiPort) => {
      if (!selectEl) return;
      const outputs = getMidiOutputs();
      const options = [
        { id: "broadcast", label: "All Outputs" },
        ...outputs.map((output, index) => ({ id: output.id || `port-${index}`, label: midiOptionLabel(output, index) }))
      ];
      selectEl.innerHTML = options.map((option) => `<option value="${escapeHtml(option.id)}">${escapeHtml(option.label)}</option>`).join("");
      const normalized = options.some((option) => option.id === selectedId) ? selectedId : "broadcast";
      selectEl.value = normalized;
      selectEl.dataset.selectedPort = normalized;
    };
    function applyGlobalConnectionConfig() {
      isSyncingConfig = true;
      populateMidiPortSelect(assignmentMidiPortSelect, editorConfig.midiPort);
      populateMidiPortSelect(editorMidiPortSelect, editorConfig.midiPort);
      if (assignmentMidiPortSelect) assignmentMidiPortSelect.dataset.selectedPort = editorConfig.midiPort;
      if (editorMidiPortSelect) editorMidiPortSelect.dataset.selectedPort = editorConfig.midiPort;
      if (backgroundOpacityInput) {
        backgroundOpacityInput.value = String(editorConfig.backgroundOpacity ?? 1);
      }
      if (backgroundOpacityValue) {
        const percent = Math.round((editorConfig.backgroundOpacity ?? 1) * 100);
        backgroundOpacityValue.textContent = `${percent}%`;
      }
      setBackgroundOpacity(editorConfig.backgroundOpacity ?? 1);
      if (trailsCheckbox) {
        trailsCheckbox.checked = Boolean(editorConfig.trailsEnabled);
      }
      isSyncingConfig = false;
    }
    const refreshMidiPortOptions = async () => {
      await ensureMidiAccess();
      applyGlobalConnectionConfig();
    };
    const ensureMidiAccess = () => {
      if (!midiManager.supported) {
        return Promise.resolve(null);
      }
      if (midiManager.ready) {
        return Promise.resolve(midiManager.outputs);
      }
      if (!midiManager.pending) {
        midiManager.pending = navigator.requestMIDIAccess({ sysex: false, software: false }).then((access) => {
          midiManager.access = access;
          midiManager.outputs = Array.from(access.outputs.values());
          midiManager.ready = true;
          access.addEventListener("statechange", () => {
            midiManager.outputs = Array.from(access.outputs.values());
            applyGlobalConnectionConfig();
          });
          applyGlobalConnectionConfig();
          return midiManager.outputs;
        }).catch((err) => {
          console.warn("MIDI access unavailable", err);
          midiManager.supported = false;
          return null;
        });
      }
      return midiManager.pending;
    };
    const sendMidiMessage = (status, data1, data2, portId = "broadcast") => {
      if (!midiManager.supported) {
        console.info("[MIDI]", { status, data1, data2, port: portId });
        return;
      }
      ensureMidiAccess().then((outputs) => {
        if (!outputs || !outputs.length) {
          console.info("[MIDI pending output]", { status, data1, data2, port: portId });
          return;
        }
        const targets = portId && portId !== "broadcast"
          ? outputs.filter((output) => output.id === portId)
          : outputs;
        if (!targets.length) {
          console.info("[MIDI no matching port]", { port: portId, status, data1, data2 });
          return;
        }
        targets.forEach((output) => {
          try {
            output.send([status, data1, data2]);
          } catch (err) {
            console.warn("MIDI send failed", err);
          }
        });
      });
    };
    const sendMidiNote = (channel, note, velocity, type = "on", portId = editorConfig.midiPort) => {
      const normalizedChannel = clampRange(Math.floor(channel) || 1, 1, 16);
      const normalizedNote = clampRange(Math.floor(note) || 0, 0, 127);
      const normalizedVelocity = clampRange(Math.floor(velocity) || 0, 0, 127);
      const status = (type === "off" ? 0x80 : 0x90) | ((normalizedChannel - 1) & 0x0f);
      sendMidiMessage(status, normalizedNote, normalizedVelocity, portId);
    };
    const sendMidiCc = (channel, cc, value, portId = editorConfig.midiPort) => {
      const normalizedChannel = clampRange(Math.floor(channel) || 1, 1, 16);
      const normalizedCc = clampRange(Math.floor(cc) || 0, 0, 127);
      const normalizedValue = clampRange(Math.floor(value) || 0, 0, 127);
      const status = 0xb0 | ((normalizedChannel - 1) & 0x0f);
      sendMidiMessage(status, normalizedCc, normalizedValue, portId);
    };
    const findLandmarkIndex = (list, key) => {
      const match = list.find((item) => item.key === key);
      if (match && typeof match.index === "number") {
        return match.index;
      }
      return typeof list[0]?.index === "number" ? list[0].index : 0;
    };
    const shapeContainsPoint = (shape, point) => {
      if (!shape || !point) return false;
      const px = clampUnit(point.x ?? 0);
      const py = clampUnit(point.y ?? 0);
      if (shape.type === "polyline") {
        const vertices = normalizeVertices(shape.vertices);
        if (!vertices.length) return false;
        if (shape.closed && vertices.length >= 3) {
          return pointInPolygon(vertices, px, py);
        }
        const distance = distanceToPolyline(vertices, px, py, Boolean(shape.closed));
        return distance <= 0.02;
      }
      const rotation = normalizeAngle(shape.rotation || 0);
      const width = shape.width ?? 0;
      const height = shape.height ?? 0;
      if (width <= 0 || height <= 0) return false;
      const cx = (shape.x ?? 0) + width / 2;
      const cy = (shape.y ?? 0) + height / 2;
      let localX = px;
      let localY = py;
      if (rotation) {
        const rotated = rotatePointAround(px, py, cx, cy, -rotation);
        localX = rotated.x;
        localY = rotated.y;
      }
      const dx = localX - cx;
      const dy = localY - cy;
      const halfWidth = width / 2;
      const halfHeight = height / 2;
      if (shape.type === "ellipse") {
        const nx = halfWidth > 0 ? dx / halfWidth : 0;
        const ny = halfHeight > 0 ? dy / halfHeight : 0;
        return (nx * nx + ny * ny) <= 1;
      }
      return Math.abs(dx) <= halfWidth && Math.abs(dy) <= halfHeight;
    };
    const getLandmarkPoint = (landmarks, index) => {
      if (!landmarks || typeof index !== "number") return null;
      const landmark = landmarks[index];
      if (!landmark) return null;
      return {
        x: clampUnit(landmark.x ?? 0),
        y: clampUnit(landmark.y ?? 0),
        z: landmark.z ?? 0
      };
    };
    const resolveFacePoint = (key, landmarks) => {
      if (!landmarks || !landmarks.length) return null;
      if (key === "centroid") {
        let sumX = 0;
        let sumY = 0;
        for (let i = 0; i < landmarks.length; i++) {
          sumX += clampUnit(landmarks[i].x ?? 0);
          sumY += clampUnit(landmarks[i].y ?? 0);
        }
        const count = landmarks.length || 1;
        return { x: clampUnit(sumX / count), y: clampUnit(sumY / count) };
      }
      if (key === "nose_tip") {
        const index = findLandmarkIndex(FACE_REFERENCE_POINTS, key);
        return getLandmarkPoint(landmarks, index);
      }
      return null;
    };
    const resolveStreamPoint = (streamId, landmarkKey, results) => {
      if (!results) return null;
      switch (streamId) {
        case "pose": {
          const index = findLandmarkIndex(POSE_LANDMARKS_LIST, landmarkKey);
          return getLandmarkPoint(results.poseLandmarks, index);
        }
        case "leftHand": {
          const index = findLandmarkIndex(HAND_LANDMARKS_LIST, landmarkKey);
          return getLandmarkPoint(results.leftHandLandmarks, index);
        }
        case "rightHand": {
          const index = findLandmarkIndex(HAND_LANDMARKS_LIST, landmarkKey);
          return getLandmarkPoint(results.rightHandLandmarks, index);
        }
        case "face": {
          return resolveFacePoint(landmarkKey, results.faceLandmarks);
        }
        default:
          return null;
      }
    };
    const adjustPointForMirror = (point) => {
      if (!point) return null;
      // Shapes persist in the camera's native coordinate system even when the UI is mirrored,
      // so incoming landmark points can be compared as-is without flipping them again.
      return point;
    };
    const getNow = () => (typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now());
    const DEFAULT_METRICS = Object.freeze({ normX: 0, normY: 0, distance: 0 });
    const MIN_METRIC_SPAN = 1e-4;
    const computeShapeBounds = (shape) => {
      if (!shape) {
        return { minX: 0, minY: 0, width: 1, height: 1, centerX: 0.5, centerY: 0.5 };
      }
      const bounds = getShapeAabb(shape) || { minX: 0, minY: 0, maxX: 1, maxY: 1 };
      const width = Math.max((bounds.maxX ?? 0) - (bounds.minX ?? 0), MIN_METRIC_SPAN);
      const height = Math.max((bounds.maxY ?? 0) - (bounds.minY ?? 0), MIN_METRIC_SPAN);
      const centerX = clampUnit((bounds.minX ?? 0) + width / 2);
      const centerY = clampUnit((bounds.minY ?? 0) + height / 2);
      return { minX: bounds.minX ?? 0, minY: bounds.minY ?? 0, width, height, centerX, centerY };
    };
    const computeShapeMetrics = (shape, point) => {
      if (!shape || !point) {
        return { ...DEFAULT_METRICS };
      }
      const bounds = computeShapeBounds(shape);
      const px = clampUnit(point.x ?? 0);
      const py = clampUnit(point.y ?? 0);
      const hasWidth = bounds.width > MIN_METRIC_SPAN;
      const hasHeight = bounds.height > MIN_METRIC_SPAN;
      const normX = hasWidth ? clampUnit((px - bounds.minX) / bounds.width) : 0.5;
      const normY = hasHeight ? clampUnit((py - bounds.minY) / bounds.height) : 0.5;
      const radius = Math.max(bounds.width, bounds.height) / 2;
      const distance = radius > MIN_METRIC_SPAN
        ? clampUnit(Math.hypot(px - bounds.centerX, py - bounds.centerY) / radius)
        : 0;
      return { normX, normY, distance };
    };
    const resolveValueFromMode = (mode, metrics, constantValue, { midi = false } = {}) => {
      const safeMetrics = { ...DEFAULT_METRICS, ...(metrics || {}) };
      const asUnit = (value) => clampUnit(Number.isFinite(value) ? value : 0);
      const asMidi = (value) => clampRange(Math.round(Number.isFinite(value) ? value : 0), 0, 127);
      switch (mode) {
        case "normX": {
          const scalar = asUnit(safeMetrics.normX);
          return midi ? asMidi(scalar * 127) : scalar;
        }
        case "normY": {
          const scalar = asUnit(safeMetrics.normY);
          return midi ? asMidi(scalar * 127) : scalar;
        }
        case "distance": {
          const scalar = asUnit(safeMetrics.distance);
          return midi ? asMidi(scalar * 127) : scalar;
        }
        case "constant":
        default: {
          if (midi) {
            return asMidi(Number(constantValue));
          }
          return asUnit(Number(constantValue));
        }
      }
    };
    const evaluateShapeInteractions = () => {
      if (!editorState.shapes.length || !isScoreMainEnabled()) return;
      const holisticResults = inputState.holistic;
      const pointerState = inputState.pointer;
      const pointerPoint = pointerState.normalized;
      const pointerIsDown = pointerState.isDown;
      const now = getNow();
      const pointCache = new Map();
      for (const shape of editorState.shapes) {
        if (!shape.interaction) continue;
        shape.interaction = mergeInteraction(shape.interaction);
        const interaction = shape.interaction;
        const events = interaction.events?.filter((event) => event && event.type && event.type !== "none") || [];
        if (!events.length) continue;
        const runtime = shape.runtime || (shape.runtime = {
          inside: false,
          hoverInside: false,
          lastTriggerAt: 0,
          lastContinuousAt: 0,
          noteOn: false,
          eventState: {},
          lastMetrics: { normX: 0, normY: 0, distance: 0 }
        });
        if (!runtime.eventState) runtime.eventState = {};
        if (!runtime.lastMetrics) runtime.lastMetrics = { normX: 0, normY: 0, distance: 0 };
        let inside = false;
        let hoverInside = false;
        let metrics = runtime.lastMetrics;
        const streamId = interaction.stream || "pose";
        const landmarkKey = interaction.landmark;
        if (streamId === "pointer") {
          const pointerInside = pointerPoint ? shapeContainsPoint(shape, pointerPoint) : false;
          hoverInside = pointerInside;
          if (pointerInside && pointerPoint) {
            metrics = computeShapeMetrics(shape, pointerPoint);
            runtime.lastMetrics = metrics;
          }
          inside = landmarkKey === "button" ? pointerInside && pointerIsDown : pointerInside;
        } else if (streamId === "keyboard") {
          const keyId = landmarkKey || "Space";
          const keyState = inputState.keyboard.keys.get(keyId);
          inside = Boolean(keyState?.isDown);
          hoverInside = inside;
          metrics = runtime.lastMetrics;
        } else {
          const cacheKey = `${streamId}:${landmarkKey}`;
          if (!pointCache.has(cacheKey)) {
            const point = resolveStreamPoint(streamId, landmarkKey, holisticResults);
            pointCache.set(cacheKey, adjustPointForMirror(point));
          }
          const targetPoint = pointCache.get(cacheKey);
          const isInsideShape = targetPoint ? shapeContainsPoint(shape, targetPoint) : false;
          inside = isInsideShape;
          hoverInside = isInsideShape;
          if (isInsideShape && targetPoint) {
            metrics = computeShapeMetrics(shape, targetPoint);
            runtime.lastMetrics = metrics;
          }
        }
        const justEntered = inside && !runtime.inside;
        const justExited = !inside && runtime.inside;
        runtime.hoverInside = hoverInside;
        events.forEach((event) => {
          const normalizedEvent = normalizeEvent(event);
          const eventState = runtime.eventState[normalizedEvent.id] || (runtime.eventState[normalizedEvent.id] = { noteOn: false, lastContinuousAt: 0 });
          const trigger = normalizedEvent.trigger || "enter";
          switch (normalizedEvent.type) {
            case "midiNote": {
              const channel = normalizedEvent.channel ?? 1;
              const note = normalizedEvent.note ?? 60;
              const velocity = resolveValueFromMode(normalizedEvent.velocityMode, metrics, normalizedEvent.velocityValue ?? 96, { midi: true });
              if (trigger === "enterExit") {
                if (justEntered) {
                  sendMidiNote(channel, note, velocity, "on", editorConfig.midiPort);
                  eventState.noteOn = true;
                }
                if (justExited && eventState.noteOn) {
                  sendMidiNote(channel, note, 0, "off", editorConfig.midiPort);
                  eventState.noteOn = false;
                }
                break;
              }
              if (trigger === "enter" && justEntered) {
                sendMidiNote(channel, note, velocity, "on", editorConfig.midiPort);
                eventState.noteOn = true;
                break;
              }
              if (trigger === "exit" && justExited) {
                sendMidiNote(channel, note, 0, "off", editorConfig.midiPort);
                eventState.noteOn = false;
                break;
              }
              if (trigger === "inside" && inside) {
                if (now - (eventState.lastContinuousAt || 0) >= CONTINUOUS_TRIGGER_INTERVAL_MS) {
                  eventState.lastContinuousAt = now;
                  sendMidiNote(channel, note, velocity, "on", editorConfig.midiPort);
                  eventState.noteOn = true;
                }
              }
              if (justExited && eventState.noteOn) {
                sendMidiNote(channel, note, 0, "off", editorConfig.midiPort);
                eventState.noteOn = false;
              }
              break;
            }
            case "midiCc": {
              const channel = normalizedEvent.channel ?? 1;
              const ccNumber = normalizedEvent.cc ?? 1;
              const value = resolveValueFromMode(normalizedEvent.ccValueMode, metrics, normalizedEvent.ccValue ?? 100, { midi: true });
              const sendValue = (val) => sendMidiCc(channel, ccNumber, val, editorConfig.midiPort);
              if (trigger === "enterExit") {
                if (justEntered) sendValue(value);
                if (justExited) sendValue(0);
                break;
              }
              if (trigger === "enter" && justEntered) {
                sendValue(value);
                break;
              }
              if (trigger === "exit" && justExited) {
                sendValue(0);
                break;
              }
              if (trigger === "inside" && inside) {
                if (now - (eventState.lastContinuousAt || 0) >= CONTINUOUS_TRIGGER_INTERVAL_MS) {
                  eventState.lastContinuousAt = now;
                  sendValue(value);
                }
              }
              break;
            }
            default:
              break;
          }
        });
        runtime.inside = inside;
        runtime.lastTriggerAt = now;
        if (!inside && runtime.eventState) {
          Object.values(runtime.eventState).forEach((state) => {
            state.lastContinuousAt = 0;
            state.noteOn = false;
          });
        }
        if (isMapModalOpen()) {
          const item = document.getElementById(`editor-shape-${shape.id}`);
          if (item) {
            if (hoverInside || inside) {
              item.setAttribute("data-active", "true");
            } else {
              item.removeAttribute("data-active");
            }
          }
        }
      }
      renderEditor();
    };

    const getPointerNormalized = (event) => {
      if (!event || !gestureSvg) return null;
      const raw = getUnclampedNormalizedPoint(event);
      if (!raw || !Number.isFinite(raw.x) || !Number.isFinite(raw.y)) {
        return null;
      }
      if (raw.x < 0 || raw.x > 1 || raw.y < 0 || raw.y > 1) {
        return null;
      }
      return { x: clampUnit(raw.x), y: clampUnit(raw.y) };
    };

    const applyPointerState = (updates = {}) => {
      const target = inputState.pointer;
      let changed = false;
      if ("normalized" in updates) {
        const nextPoint = updates.normalized;
        const prevPoint = target.normalized;
        const bothNull = !prevPoint && !nextPoint;
        let samePoint = false;
        if (prevPoint && nextPoint) {
          samePoint = Math.abs(prevPoint.x - nextPoint.x) < 1e-4 && Math.abs(prevPoint.y - nextPoint.y) < 1e-4;
        }
        if (!bothNull && !samePoint) {
          changed = true;
        }
        target.normalized = nextPoint || null;
      }
      if ("isDown" in updates) {
        if (updates.isDown !== target.isDown) {
          changed = true;
        }
        target.isDown = Boolean(updates.isDown);
      }
      if ("pointerId" in updates) {
        if (updates.pointerId !== target.pointerId) {
          changed = true;
        }
        target.pointerId = updates.pointerId;
      }
      if ("isOverCanvas" in updates) {
        if (Boolean(updates.isOverCanvas) !== Boolean(target.isOverCanvas)) {
          changed = true;
        }
        target.isOverCanvas = Boolean(updates.isOverCanvas);
      }
      target.lastUpdate = getNow();
      return changed;
    };

    const handleInputPointerMove = (event) => {
      const normalized = getPointerNormalized(event);
      if (applyPointerState({
        normalized,
        isOverCanvas: Boolean(normalized)
      })) {
        evaluateShapeInteractions();
      }
    };

    const handleInputPointerDown = (event) => {
      const normalized = getPointerNormalized(event);
      const isPrimaryButton = event.button === 0 || event.button === -1;
      const updates = {
        normalized,
        isOverCanvas: Boolean(normalized)
      };
      if (isPrimaryButton && normalized) {
        updates.pointerId = event.pointerId;
        updates.isDown = true;
      } else if (isPrimaryButton) {
        updates.pointerId = null;
        updates.isDown = false;
      }
      if (applyPointerState(updates)) {
        evaluateShapeInteractions();
      }
    };

    const handleInputPointerUp = (event) => {
      const normalized = getPointerNormalized(event);
      const isPrimaryButton = event.button === 0 || event.button === -1;
      const shouldRelease = isPrimaryButton && (inputState.pointer.pointerId === event.pointerId || inputState.pointer.pointerId === null);
      const updates = {
        normalized,
        isOverCanvas: Boolean(normalized)
      };
      if (shouldRelease) {
        updates.pointerId = null;
        updates.isDown = false;
      }
      if (applyPointerState(updates)) {
        evaluateShapeInteractions();
      }
    };

    const handleInputPointerCancel = (event) => {
      if (inputState.pointer.pointerId !== null && event.pointerId !== inputState.pointer.pointerId) {
        return;
      }
      if (applyPointerState({
        normalized: null,
        isOverCanvas: false,
        isDown: false,
        pointerId: null
      })) {
        evaluateShapeInteractions();
      }
    };

    const shouldCaptureKeyboardInput = (event) => {
      if (!event) return false;
      const code = event.code;
      if (!code || !KEYBOARD_REFERENCE_SET.has(code)) {
        return false;
      }
      const target = event.target;
      if (!target) return true;
      const tag = target.tagName?.toLowerCase?.() || "";
      if (["input", "textarea", "select"].includes(tag)) {
        return false;
      }
      if (target.isContentEditable) {
        return false;
      }
      return true;
    };

    const updateKeyboardState = (code, isDown) => {
      const keys = inputState.keyboard.keys;
      const existing = keys.get(code) || { isDown: false, lastDownAt: 0, lastUpAt: 0 };
      const nextState = {
        isDown: Boolean(isDown),
        lastDownAt: existing.lastDownAt,
        lastUpAt: existing.lastUpAt
      };
      const timestamp = getNow();
      if (isDown) {
        nextState.lastDownAt = timestamp;
      } else {
        nextState.lastUpAt = timestamp;
      }
      const changed = existing.isDown !== nextState.isDown;
      keys.set(code, nextState);
      return changed;
    };

    const handleInputKeyDown = (event) => {
      if (!shouldCaptureKeyboardInput(event)) return;
      const changed = updateKeyboardState(event.code, true);
      if (changed || event.repeat) {
        evaluateShapeInteractions();
      }
    };

    const handleInputKeyUp = (event) => {
      if (!shouldCaptureKeyboardInput(event)) return;
      if (updateKeyboardState(event.code, false)) {
        evaluateShapeInteractions();
      }
    };


    const handleEditorDoubleClick = (event) => {
      if (isPolylineTool(editorState.tool) && editorState.activePolylineId) {
        finalizeActivePolyline({ commit: true });
        return;
      }
      const shapeTarget = event.target?.closest?.("[data-shape-id]");
      if (!shapeTarget) return;
      const shapeId = shapeTarget.getAttribute("data-shape-id");
      if (!shapeId) return;
      setSelectedShape(shapeId);
      openAssignmentModal(shapeId);
    };

    if (gestureSvg) {
      gestureSvg.addEventListener("pointerdown", handleEditorPointerDown);
      gestureSvg.addEventListener("pointermove", handleEditorPointerMove);
      gestureSvg.addEventListener("pointerup", handleEditorPointerUp);
      gestureSvg.addEventListener("pointerleave", handleEditorPointerLeave);
      gestureSvg.addEventListener("lostpointercapture", handleEditorPointerUp);
      gestureSvg.addEventListener("lostpointercapture", handleInputPointerCancel);
      gestureSvg.addEventListener("dblclick", handleEditorDoubleClick);
    }
    window.addEventListener("pointermove", handleInputPointerMove, { passive: true });
    window.addEventListener("pointerdown", handleInputPointerDown, { passive: true });
    window.addEventListener("pointerup", handleInputPointerUp, { passive: true });
    window.addEventListener("pointercancel", handleInputPointerCancel);
    window.addEventListener("keydown", handleInputKeyDown, true);
    window.addEventListener("keyup", handleInputKeyUp);
    window.addEventListener("keydown", handleGlobalShortcut);
    window.addEventListener("keydown", handleEditorKeyDown);
    if (typeof window !== "undefined") {
      window.mediamime = window.mediamime || {};
      window.mediamime.generateScoreSvg = () => generateScoreSvg();
    }

    for (const [tool, button] of Object.entries(gestureToolButtons)) {
      button?.addEventListener("click", () => {
        if (editorState.mode === "perform") {
          setEditorMode("edit");
        }
        setEditorTool(tool);
      });
    }

    gestureModeToggle?.addEventListener("click", () => {
      const nextMode = editorState.mode === "perform" ? "edit" : "perform";
      setEditorMode(nextMode);
    });

    gestureClearBtn?.addEventListener("click", () => {
      editorState.shapes = [];
      clearActivePolylineState();
      setSelectedShape(null, { suppressRender: true });
      renderEditor();
      queuePersist();
    });
    assignmentStreamSelect?.addEventListener("change", () => {
      if (isSyncingAssignmentForm) return;
      const streamId = assignmentStreamSelect.value || "pose";
      const currentLandmark = assignmentLandmarkSelect?.value || null;
      const landmarkValue = populateLandmarkOptions(streamId, currentLandmark, assignmentLandmarkSelect) || currentLandmark;
      if (assignmentDraftInteraction) {
        assignmentDraftInteraction = mergeInteraction({
          ...assignmentDraftInteraction,
          stream: streamId,
          landmark: landmarkValue
        });
        syncAssignmentForm();
      }
    });
    assignmentLandmarkSelect?.addEventListener("change", () => {
      if (isSyncingAssignmentForm) return;
      const landmark = assignmentLandmarkSelect.value || "";
      if (!assignmentDraftInteraction) return;
      assignmentDraftInteraction = mergeInteraction({
        ...assignmentDraftInteraction,
        landmark
      });
      syncAssignmentForm();
    });
    assignmentMidiPortSelect?.addEventListener("change", () => {
      if (isSyncingConfig) return;
      const value = assignmentMidiPortSelect.value || "broadcast";
      updateEditorConfig({ midiPort: value });
    });
    assignmentMidiPortRefreshBtn?.addEventListener("click", () => {
      refreshMidiPortOptions();
    });
    assignmentAddEventBtn?.addEventListener("click", () => {
      addEventToScope("modal", "midiNote");
    });
    assignmentEventList?.addEventListener("click", (event) => {
      const target = event.target?.closest('[data-action="remove-event"]');
      if (!target) return;
      const card = target.closest('.event-card');
      const eventId = card?.dataset?.eventId;
      if (!eventId) return;
      removeEventFromScope("modal", eventId);
    });
    assignmentEventList?.addEventListener("change", (event) => {
      handleEventListMutation("modal", event);
    });
    assignmentEventList?.addEventListener("input", (event) => {
      handleEventListMutation("modal", event);
    });
    assignmentCloseBtn?.addEventListener("click", closeAssignmentModal);
    assignmentCancelBtn?.addEventListener("click", closeAssignmentModal);
    assignmentBackdrop?.addEventListener("click", closeAssignmentModal);
    assignmentApplyBtn?.addEventListener("click", applyAssignmentModal);
    assignmentModal?.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        event.preventDefault();
        closeAssignmentModal();
      }
    });
    editorShapeList?.addEventListener("click", (event) => {
      const target = event.target?.closest("button[data-shape-id]");
      if (!target) return;
      const shapeId = target.getAttribute("data-shape-id");
      if (!shapeId) return;
      setSelectedShape(shapeId);
    });
    editorShapeList?.addEventListener("keydown", (event) => {
      const key = event.key?.toLowerCase();
      if (key !== "enter" && key !== " ") return;
      const target = event.target?.closest("button[data-shape-id]");
      if (!target) return;
      event.preventDefault();
      const shapeId = target.getAttribute("data-shape-id");
      if (!shapeId) return;
      setSelectedShape(shapeId);
    });
    editorStreamSelect?.addEventListener("change", () => {
      if (isSyncingEditorForm) return;
      const shape = findShapeById(editorState.selectedId);
      if (!shape) return;
      const stream = editorStreamSelect.value || "pose";
      const interaction = mergeInteraction(shape.interaction);
      const nextLandmark = populateLandmarkOptions(stream, interaction.landmark, editorLandmarkSelect) || interaction.landmark;
      mutateSelectedShape((target) => {
        target.interaction = {
          ...interaction,
          stream,
          landmark: nextLandmark
        };
      }, { skipRender: true });
    });
    editorLandmarkSelect?.addEventListener("change", () => {
      if (isSyncingEditorForm) return;
      const landmark = editorLandmarkSelect.value || "";
      mutateSelectedShape((target) => {
        const interaction = mergeInteraction(target.interaction);
        interaction.landmark = landmark;
        target.interaction = interaction;
      }, { skipRender: true });
    });
    editorMidiPortSelect?.addEventListener("change", () => {
      if (isSyncingConfig) return;
      const value = editorMidiPortSelect.value || "broadcast";
      updateEditorConfig({ midiPort: value });
    });
    snapshotExportBtn?.addEventListener("click", () => {
      exportSnapshot();
    });
    snapshotImportBtn?.addEventListener("click", () => {
      snapshotImportInput?.click();
    });
    snapshotImportInput?.addEventListener("change", handleSnapshotImportChange);
    editorMidiPortRefreshBtn?.addEventListener("click", () => {
      refreshMidiPortOptions();
    });
    editorAddEventBtn?.addEventListener("click", () => {
      addEventToScope("editor", "midiNote");
    });
    editorEventList?.addEventListener("click", (event) => {
      const target = event.target?.closest('[data-action="remove-event"]');
      if (!target) return;
      const card = target.closest('.event-card');
      const eventId = card?.dataset?.eventId;
      if (!eventId) return;
      removeEventFromScope("editor", eventId);
    });
    editorEventList?.addEventListener("change", (event) => {
      handleEventListMutation("editor", event);
    });
    editorEventList?.addEventListener("input", (event) => {
      handleEventListMutation("editor", event);
    });
    backgroundOpacityInput?.addEventListener("input", (event) => {
      const rawValue = Number.parseFloat(event.target.value);
      const nextOpacity = clampUnit(Number.isFinite(rawValue) ? rawValue : 0);
      if (backgroundOpacityValue) {
        backgroundOpacityValue.textContent = `${Math.round(nextOpacity * 100)}%`;
      }
      setBackgroundOpacity(nextOpacity);
      updateEditorConfig({ backgroundOpacity: nextOpacity });
    });
    trailsCheckbox?.addEventListener("change", (event) => {
      updateEditorConfig({ trailsEnabled: Boolean(event.target.checked) });
    });
    editorDeleteShapeBtn?.addEventListener("click", () => {
      deleteSelectedShape();
    });
    editorOpenModalBtn?.addEventListener("click", () => {
      if (editorState.selectedId) {
        openAssignmentModal(editorState.selectedId);
      }
    });

    loadEditorConfig();
    setEditorViewport(DEFAULT_WIDTH, DEFAULT_HEIGHT);
    setEditorVisibility(editorState.isVisible);
    applyGlobalConnectionConfig();
    refreshMidiPortOptions();
    loadPersistedShapes();
    setEditorMode(editorState.mode);
    setEditorTool(editorState.tool);
    populateLandmarkOptions("pose", "left_wrist", assignmentLandmarkSelect);
    populateLandmarkOptions("pose", "left_wrist", editorLandmarkSelect);
    syncEditorDetailForm();
    renderEditor();
    updateOverlayState();

    const setCanvasDimensions = (p, width, height) => {
      const nextWidth = width || DEFAULT_WIDTH;
      const nextHeight = height || DEFAULT_HEIGHT;
      if (canvasWidth !== nextWidth || canvasHeight !== nextHeight) {
        canvasWidth = nextWidth;
        canvasHeight = nextHeight;
        p.resizeCanvas(canvasWidth, canvasHeight);
        setEditorViewport(canvasWidth, canvasHeight);
        renderEditor();
      }
    };

    const clampDepth = (value) => Math.max(-0.8, Math.min(0.8, value || 0));

    const hexToRgb = (hex) => {
      const normalized = hex.replace("#", "");
      const bigint = parseInt(normalized, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    };

    const interpolateColor = (fromHex, toHex, t) => {
      const from = hexToRgb(fromHex);
      const to = hexToRgb(toHex);
      const mix = (start, end) => Math.round(start + (end - start) * t);
      return `rgb(${mix(from.r, to.r)}, ${mix(from.g, to.g)}, ${mix(from.b, to.b)})`;
    };

    const depthStyle = (value) => {
      const clamped = clampDepth(value);
      const magnitude = Math.abs(clamped) / 0.8;
      const pivotProximity = 1 - magnitude;
      const pivotShrink = Math.pow(pivotProximity, 3);
      const baseSize = 2.5 + pivotShrink * 2.5;
      const size = baseSize + magnitude * 58;
      const pivotColor = "#a855f7";
      const farColor = "#ff4d4f";
      const nearColor = "#3b82f6";
      const color = clamped >= 0
        ? interpolateColor(pivotColor, farColor, magnitude)
        : interpolateColor(pivotColor, nearColor, magnitude);
      return { color, size };
    };

    const drawLandmarks = (p, results) => {
      if (!results) return;
      const { poseLandmarks, leftHandLandmarks, rightHandLandmarks, faceLandmarks } = results;

      const drawConnectorSet = (landmarks, connections, color, weight) => {
        p.stroke(color);
        p.strokeWeight(weight);
        for (let i = 0; i < connections.length; i++) {
          const [startIndex, endIndex] = connections[i];
          const start = landmarks[startIndex];
          const end = landmarks[endIndex];
          if (!start || !end) continue;
          p.line(start.x * canvasWidth, start.y * canvasHeight, end.x * canvasWidth, end.y * canvasHeight);
        }
      };

      const drawLandmarkPoints = (landmarks, color, size = 6) => {
        p.fill(color);
        p.noStroke();
        for (const lm of landmarks) {
          p.circle(lm.x * canvasWidth, lm.y * canvasHeight, size);
        }
      };

      if (overlayState.pose?.main && poseLandmarks) {
        drawConnectorSet(poseLandmarks, SAFE_POSE_CONNECTIONS, "#4cc9f0", 3);
        drawLandmarkPoints(poseLandmarks, "rgba(76, 201, 240, 0.7)", 5);
      }
      if (overlayState.leftHand?.main && leftHandLandmarks) {
        drawConnectorSet(leftHandLandmarks, SAFE_HAND_CONNECTIONS, "#ff7096", 2.5);
        drawLandmarkPoints(leftHandLandmarks, "rgba(255, 112, 150, 0.9)", 4);
      }
      if (overlayState.rightHand?.main && rightHandLandmarks) {
        drawConnectorSet(rightHandLandmarks, SAFE_HAND_CONNECTIONS, "#ff8fa3", 2.5);
        drawLandmarkPoints(rightHandLandmarks, "rgba(255, 143, 163, 0.9)", 4);
      }
      if (overlayState.face?.main && faceLandmarks) {
        p.noFill();
        p.stroke("#f9c74f");
        p.strokeWeight(1.2);
        if (SAFE_FACEMESH_TESSELATION.length) {
          for (let i = 0; i < SAFE_FACEMESH_TESSELATION.length; i++) {
            const [startIndex, endIndex] = SAFE_FACEMESH_TESSELATION[i];
            const start = faceLandmarks[startIndex];
            const end = faceLandmarks[endIndex];
            if (!start || !end) continue;
            p.line(start.x * canvasWidth, start.y * canvasHeight, end.x * canvasWidth, end.y * canvasHeight);
          }
        } else {
          drawLandmarkPoints(faceLandmarks, "rgba(249, 199, 79, 0.8)", 3);
        }
      }
      if (overlayState.depth?.main && poseLandmarks) {
        p.noStroke();
        for (const lm of poseLandmarks) {
          const { color, size } = depthStyle(lm.z ?? 0);
          p.fill(color);
          p.drawingContext.save();
          p.drawingContext.globalAlpha = 0.5;
          p.circle(lm.x * canvasWidth, lm.y * canvasHeight, size);
          p.drawingContext.restore();
        }
      }
    };

    const drawPerformanceOverlay = (p) => {
      const fpsText = Number.isFinite(performanceMetrics.fps) && performanceMetrics.fps > 0
        ? performanceMetrics.fps.toFixed(1)
        : "--";
      const frameText = Number.isFinite(performanceMetrics.frameMs) && performanceMetrics.frameMs > 0
        ? performanceMetrics.frameMs.toFixed(1)
        : "--";
      const inferenceText = Number.isFinite(performanceMetrics.inferenceMs) && performanceMetrics.inferenceMs > 0
        ? performanceMetrics.inferenceMs.toFixed(1)
        : "--";
      const lines = [
        `FPS: ${fpsText}`,
        `Frame: ${frameText} ms`,
        `Inference: ${inferenceText} ms`,
        `Source: ${performanceMetrics.source}`
      ];
      const padding = 16;
      const boxWidth = 240;
      const lineHeight = 20;
      const boxHeight = padding * 1.5 + lines.length * lineHeight;
      p.push();
      p.noStroke();
      p.fill(10, 14, 24, 220);
      p.rect(padding, padding, boxWidth, boxHeight, 12);
      p.fill(245, 247, 255);
      p.textSize(15);
      p.textAlign(p.LEFT, p.TOP);
      lines.forEach((line, index) => {
        p.text(line, padding + 12, padding + 10 + index * lineHeight);
      });
      p.pop();
    };

const clearCanvas = (p) => {
  const ctx = p.drawingContext;
  const canvas = ctx.canvas;
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
};

const paintBackground = (p, alpha) => {
  const ctx = p.drawingContext;
  const canvas = ctx.canvas;
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.globalAlpha = Math.max(0, Math.min(1, alpha / 255));
  ctx.fillStyle = "#04070d";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
};

const drawSegmentation = (p) => {
  if (!overlayState.segmentation?.main || !segmentationMaskAvailable || !segmentationTintCanvas.width) {
    return;
  }
  const surfaceOpacity = getSurfaceOpacity();
  if (surfaceOpacity <= 0) {
    return;
  }
  const ctx = p.drawingContext;
  ctx.save();
  ctx.globalAlpha = surfaceOpacity;
  ctx.drawImage(segmentationTintCanvas, 0, 0, canvasWidth, canvasHeight);
  ctx.restore();
};

    p5Instance = new p5((p) => {
      p.setup = () => {
        const canvas = p.createCanvas(DEFAULT_WIDTH, DEFAULT_HEIGHT);
        canvas.parent(sketchContainer);
        const surfaceOpacity = getSurfaceOpacity();
        if (surfaceOpacity <= 0) {
          clearCanvas(p);
        } else {
          p.background(4, 7, 13, surfaceOpacity * 255);
        }
        p.noStroke();
      };

      p.draw = () => {
        const now = performance.now();
        const delta = now - lastFrameTimestamp;
        lastFrameTimestamp = now;
        if (delta > 0 && delta < 1000) {
          const instantFps = 1000 / delta;
          smoothedFps = smoothedFps ? smoothedFps * 0.9 + instantFps * 0.1 : instantFps;
          smoothedFrameMs = smoothedFrameMs ? smoothedFrameMs * 0.9 + delta * 0.1 : delta;
          performanceMetrics.fps = smoothedFps;
          performanceMetrics.frameMs = smoothedFrameMs;
        }
        performanceMetrics.source = currentSource;

        const videoWidth = videoEl.videoWidth || DEFAULT_WIDTH;
        const videoHeight = videoEl.videoHeight || DEFAULT_HEIGHT;

        if (!videoWidth || !videoHeight) {
          drawPreviewCanvas();
          return;
        }

        if (p.width !== videoWidth || p.height !== videoHeight) {
          p.resizeCanvas(videoWidth, videoHeight);
        }
        setCanvasDimensions(p, videoWidth, videoHeight);

        p.canvas.style.width = "auto";
        p.canvas.style.height = "auto";
        p.canvas.style.maxWidth = "100%";
        p.canvas.style.maxHeight = "100%";

        const surfaceOpacity = getSurfaceOpacity();
        const trailsEnabled = Boolean(editorConfig.trailsEnabled);
        if (surfaceOpacity <= 0 || !trailsEnabled) {
          clearCanvas(p);
        }

        p.push();
        if (overlayState.mirror && currentSource === "camera") {
          p.translate(canvasWidth, 0);
          p.scale(-1, 1);
        }

        if (surfaceOpacity > 0) {
          if (overlayState.underlay?.main) {
            const baseAlpha = Math.min(255, 180 * surfaceOpacity);
            paintBackground(p, baseAlpha);
          } else if (trailsEnabled) {
            const fadeAlpha = Math.min(255, 64 * surfaceOpacity);
            paintBackground(p, fadeAlpha);
          }
        }

        if (overlayState.underlay?.main && surfaceOpacity > 0 && videoEl.readyState >= 2) {
          const ctx = p.drawingContext;
          ctx.save();
          ctx.globalAlpha = surfaceOpacity;
          ctx.drawImage(videoEl, 0, 0, canvasWidth, canvasHeight);
          ctx.restore();
        }

        drawSegmentation(p);
        drawLandmarks(p, latestResults);

        p.pop();

        if (overlayState.performance?.main) {
          drawPerformanceOverlay(p);
        }

        drawPreviewCanvas();
      };
    });

    (async () => {
      try {
        applyStatus("Requesting camera…");
        await startCamera();
      } catch (err) {
        console.warn("Camera unavailable, falling back to sample video.", err);
        applyStatus("Camera blocked — using sample video");
        await startSampleVideo();
      }
    })();
  </script>
</body>
</html>
    
